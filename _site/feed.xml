<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elyo</title>
    <description>진심을 다해서 
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 06 Aug 2021 15:53:22 +0900</pubDate>
    <lastBuildDate>Fri, 06 Aug 2021 15:53:22 +0900</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>jenkins 간단 사용법</title>
        <description>&lt;h2 id=&quot;jenkins&quot;&gt;jenkins&lt;/h2&gt;

&lt;p&gt;jenkins는 속된말로 노예라고 불립니다
  여러가지 일을 대신 수행하기 때문입니다.&lt;/p&gt;

&lt;p&gt;지속적인 통합/지속적 제공 즉 CICD를 수행을 위해서 자주 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지속적인 통합 : 프로그램 코드를 git등을 이용해서 새로운 코드 변경 사항을 정기적으로 통합합니다.(ex n명의 개발자 빌드 및 데스트 통합)&lt;/li&gt;
  &lt;li&gt;지속적 제공 : 운영중인 프로그램서버 , 통합 개발 브런치에 자동으로 업로드 되는것을 의미 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 다음과정으로 jenkins를 알아보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AWS(ubuntu)를 이용한 2대의서버 개설&lt;/li&gt;
  &lt;li&gt;1대는 젠킨스 서버, 1대는 springboot배포서버(실행서버)&lt;/li&gt;
  &lt;li&gt;젠킨스 서버에 도커,젠킨스,git,자바 설치&lt;/li&gt;
  &lt;li&gt;배포서버에 도커, 자바 설치&lt;/li&gt;
  &lt;li&gt;젠킨스 서버에서 젠킨스 실행후 설정&lt;/li&gt;
  &lt;li&gt;배포서버와 젠킨스서버 ssh연동&lt;/li&gt;
  &lt;li&gt;젠킨스 서버와 git연동 및 확인&lt;/li&gt;
  &lt;li&gt;젠킨스에서 git webhook을 통해 자동으로 push를 인지하는 webhook 설정&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-awsubuntu를-이용한-2대의서버-개설&quot;&gt;1. AWS(ubuntu)를 이용한 2대의서버 개설&lt;/h2&gt;

&lt;p&gt;우선 젠킨스서버와 배포서버를 AWS를 이용해서 개설 했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS에 접속후 인스턴스 생성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;t2.medium(2cpu,4memory), t2.micro(1cpu,1memory)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;t2.medium 서버는 젠킨스서버로 활용될것입니다.&lt;/li&gt;
  &lt;li&gt;ssh를 사용할것이므로 키는 잘 받아주시기 바랍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-1대는-젠킨스-서버-1대는-springboot배포서버실행서버&quot;&gt;2. 1대는 젠킨스 서버, 1대는 springboot배포서버(실행서버&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;젠킨스 서버는 도커,젠킨스,git,자바 등을 설치하기에 프리티어(t2.micro)보다 좋은 성능을 선택하였습니다.&lt;/li&gt;
  &lt;li&gt;t2.micro는 배포 서버로 활용될것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-젠킨스-서버에-도커젠킨스git자바-설치&quot;&gt;3. 젠킨스 서버에 도커,젠킨스,git,자바 설치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ssh를 이용하여 젠킨스 서버에 접속합니다.&lt;/li&gt;
  &lt;li&gt;java, docker, jenkins를 설치합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설치하기전에 기본적으로 apt update &amp;amp; apt upgrade를 먼저 진행합니다.&lt;/p&gt;

&lt;p&gt;### 자바 설치 
  자바 설치를 위해 다음과 같이 터미널에 작성해주세요&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt install openjdk-11-jdk 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### &lt;code class=&quot;highlighter-rouge&quot;&gt;도커 설치&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;### 필수 패키지 설치&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### GPG  key 인증&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;ok가 나오면 됩니다.&lt;/p&gt;

&lt;p&gt;### docker repository 등록
  아키텍쳐에 맞춰서 docker repository를 등록합니다. 아키텍처 확인은 arch를 터미널에 입력하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  arch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo add-apt-repository \
  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;~~블라블라 &lt;br /&gt;
  Reading package lists… Done&lt;/p&gt;

&lt;p&gt;이라고 출력되면 정상입니다.&lt;/p&gt;

&lt;p&gt;### apt docker 설치&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker -v&lt;/code&gt; 를 통해서 확인해봅니다.  &lt;br /&gt;
  Docker version ~~ 라고 나오면 잘설치 된겁니다.&lt;/p&gt;

&lt;p&gt;### 도커 실행
  우분투 시스템이 도커를 인지해야합니다.
  다음과 같은 명령어로 실행하고 잘 실행되었는지 확인합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo systemctl enable docker &amp;amp;&amp;amp; service docker start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  service docker status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### &lt;code class=&quot;highlighter-rouge&quot;&gt;젠킨스 설치&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;### Jenkins 설치를 위해 Repository key 추가&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 서버의 sources.list에 Jenkins 패키지 저장소를 추가&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo sh -c 'echo deb https://pkg.jenkins.io/debian-stable binary/ &amp;gt; \
  /etc/apt/sources.list.d/jenkins.list'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 패키지 인덱스 정보 업데이트&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 젠킨스 설치&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt-get install jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 젠킨스 실행&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo systemctl start jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 젠킨스 실행확인&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo systemctl status jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### jenkins 포트변경
  Jenkins를 실행시켰을 때 기본적으로 8080 포트에서 동작합니다. 하지만 Spring Project의 경우 기본 포트가 8080이기 때문에 중복되어 불편할 수 있음으로 Jenkins 포트를 9090포트로 바꾸어 주도록 하겠습니다.(우리는 젠킨스서버에 배포할것은 아니여서 상관없지만.. 연습으로.. ㅎ)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo vi /etc/default/jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;vi를 통해서 해당 파일에 들어가면 
  HTTP_PORT=8080을 9090으로 변경합니다.&lt;/p&gt;

&lt;p&gt;그리고 이때 젠킨스를 다시 실행해야합니다. 변경된 내용이 적용되도록&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo systemctl restart jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 방화벽 설정&lt;/p&gt;

&lt;p&gt;ufw를 이용해서 방화벽 설정을 합니다. ufw명령어가 안듣는다면 설치해야합니다.  &lt;br /&gt;
  인터넷에 설치방법을 확인하고 옵니다.&lt;/p&gt;

&lt;p&gt;ufw를 이용하여 나의 9090을 접근가능하게 열어둡니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo ufw allow 9090
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음의 명령어를 입력하시고&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo ufw status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;9090포트의 여부를 확인합니다.&lt;/p&gt;

&lt;p&gt;### AWS에서 젠킨스 서버 port 열기
  우리는 AWS를 이용하므로 AWS 콘솔(웹)에서 젠킨스 서버에 들어갈수있도록 보안설정을 해야합니다.&lt;/p&gt;

&lt;p&gt;우리는 여기서 젠킨스 서버의 보안그룹을 확인해야합니다.
  EC2대시보드에서 젠킨스 서버의 보안 그룹이름을 확인합니다.&lt;/p&gt;

&lt;p&gt;EC2대시보드 -&amp;gt; 네트워크및 보안그룹 -&amp;gt; 보안그룹  &lt;br /&gt;
  로 들어가서 해당 보안그룹을 들어가고 여기서 인바운드 규칙을 설정해야합니다.&lt;/p&gt;

&lt;p&gt;인바운드 규칙에서 edit inbound를 클릭하시고 9090포트를 추가합니다. 그리고 내 IP로 설정합니다.&lt;/p&gt;

&lt;p&gt;### 젠킨스(웹에서 계정등록)&lt;/p&gt;

&lt;p&gt;AWS의 퍼블릭IP로 9090 포트로 들어갑니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  13.125.12.164:9090 
  (이건 예시입니다.)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;계정 등록은 타 블로그를 잡고 하세요&lt;/p&gt;

&lt;h2 id=&quot;4배포-서버에-도커-설치&quot;&gt;4.배포 서버에 도커 설치&lt;/h2&gt;
&lt;p&gt;도커,자바 설치는 위와같이 하면된다.&lt;/p&gt;
&lt;h2 id=&quot;5젠킨스-서버에서-젠킨스-실행후-설정&quot;&gt;5.젠킨스 서버에서 젠킨스 실행후 설정&lt;/h2&gt;
&lt;p&gt;젠킨스 웹에서 계정 등록하는 방법이다.&lt;/p&gt;

&lt;p&gt;아래블로그를 참고했으나 내가 겪은 문제가 발생했었다. 이를 참고하시기바랍니다. 아래 목록에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@haeny01/AWS-Jenkins%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Docker-x-SpringBoot-CICD-%EA%B5%AC%EC%B6%95&quot;&gt;참고 블로그&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-배포서버와-젠킨스서버-ssh-연결&quot;&gt;6. 배포서버와 젠킨스서버 ssh 연결&lt;/h2&gt;
&lt;p&gt;젠킨스 서버에 젠킨스 폴더는&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /var/lib/jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;로 구성되어있다. 
  우리는 여기에 /var/lib/jenkins/.ssh 파일을 만들고 ssh 설정을 할것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd /var/lib/jenkins/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이동한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo mkdir -p ./ssh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;를 실행한다.&lt;/p&gt;

&lt;p&gt;ssh명령을 통해서 ssh 키를 만들어야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo ssh-keygen -t rsa -C &quot;jenkins&quot; -m PEM -P &quot;&quot; -f /var/lib/jenkins/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;ssh-keygen : ssh키를 만들기 위한 명령어 &lt;br /&gt;
  - t : 암호화 타입 정할수있습니다. rsa로 해야함 &lt;br /&gt;
  - c : 주석을 입력할수있습니다. 이게 필요한게 특정 서버를 명시하는 역할입니다. &lt;br /&gt;
  - m : 키 확장자를 설정 pem키로 설정하는것입니다.  &lt;br /&gt;
  - p : 암호를 없는것으로 설정하기위한 옵션 &lt;br /&gt;
  - f : 생성 폴더를 지정합니다. + 키 이름&lt;/p&gt;

&lt;p&gt;이렇게 생성한 id_rsa키를 공개키인 id_rsa.pub은 배포서버에 입력합니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  vi ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;7-젠킨스-서버와-git연동-및-확인&quot;&gt;7. 젠킨스 서버와 git연동 및 확인&lt;/h2&gt;

&lt;p&gt;아래블로그를 참고했으나 내가 겪은 문제가 발생했었다. 이를 참고하시기바랍니다. 아래 목록에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@haeny01/AWS-Jenkins%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Docker-x-SpringBoot-CICD-%EA%B5%AC%EC%B6%95&quot;&gt;참고 블로그&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;8-젠킨스에서-git-webhook을-통해-자동으로-push를-인지하는-webhook-설정&quot;&gt;8. 젠킨스에서 git webhook을 통해 자동으로 push를 인지하는 webhook 설정&lt;/h2&gt;

&lt;p&gt;아래블로그를 참고했으나 내가 겪은 문제가 발생했었다. 이를 참고하시기바랍니다. 아래 목록에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@haeny01/AWS-Jenkins%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Docker-x-SpringBoot-CICD-%EA%B5%AC%EC%B6%95&quot;&gt;참고 블로그&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;9-겪은-문제&quot;&gt;9. 겪은 문제&lt;/h2&gt;

&lt;p&gt;CICD를 실습하면서 겪은 문제는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;젠킨스서버와 배포서버의 ssh연결이 안됬었다.
    &lt;ul&gt;
      &lt;li&gt;이 문제는 아래와 같은 명령어를 통해서 해결할수있었다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   sudo ssh-keygen -t rsa -C &quot;jenkins&quot; -m PEM -P &quot;&quot; -f /var/lib/jenkins/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;일반적으로 ssh-keygen 하면 안되가지고 뭐가 문제인지는 모르지만 -C 옵션을 주고 해결되었다.&lt;/li&gt;
      &lt;li&gt;또한 이렇게 파일을 생성하고 나니 디렉터리의 그룹이 jenkins가 아니라 root여서 jenkins가 실질적으로 해당 폴더를 못 사용한것이 아닐까 생각하기도 하여&lt;/li&gt;
      &lt;li&gt;/var/lib/jenkins/.ssh/id_rsa의 그룹을 모두 jenkins로 바꾸었다.&lt;/li&gt;
      &lt;li&gt;그리고 jenkins 유저가 모든 권한을 사용하기 위해서 sudoers에 jenkins유저를 등록하였다. ALL로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;젠킨스에서 springboot jar파일 도커 이미지로 만들지 못했었다.
    &lt;ul&gt;
      &lt;li&gt;젠킨스에서 github poll을 진행하고 이를 통해서 Dokerfile을 통해 이미지를 만들려고 할때 문제가 발생하였다.&lt;/li&gt;
      &lt;li&gt;원인은 jar 파일이 2개생겨서 이고 springboot 2.5 부터는 기본적으로 jar파일이 하나 더생기는데 이를 build.gradle에서 막아야한다.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jar {
enabled = false
  }
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;을 통해서 막을수있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 04 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/08/04/jenkins/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/08/04/jenkins/</guid>
        
        <category>CICD</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>타입스크립트 grammer - 1</title>
        <description>&lt;h2 id=&quot;타입스크립트-grammer&quot;&gt;타입스크립트 grammer&lt;/h2&gt;

&lt;p&gt;타입스크립트 문법 학습 내용을 기록&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수 및 타입&lt;/li&gt;
  &lt;li&gt;배열 및 enum&lt;/li&gt;
  &lt;li&gt;튜플과 오브젝트&lt;/li&gt;
  &lt;li&gt;function의 리턴값 , 익명함수, 애로우 펑션&lt;/li&gt;
  &lt;li&gt;Scope에 대해서 학습&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 타입을 지정할수있다. 
let myName : string = &quot;eri&quot;
let v2 : number = 123
let v3 : boolean = true

// 아무거나 가능한 타입
let value: any;

// 배열 
let array1 : string[] = [&quot;12&quot;,&quot;12312&quot;,&quot;123123&quot;]
let array2 : number[] = [12,123,1234]
let array3 : any[] = [12,123,1234]

//tuple
let classB : [string,number] = [&quot;students&quot;,20]
classB = [&quot;Teachers&quot;, 19]
console.log(classB)


//enum 
enum Color{
    Blue=&quot;장난하냐&quot;,
    Green = &quot;asdfasdf&quot;,
    Red = &quot;good&quot;
}

let color1 = Color.Blue;
console.log(color1)


// function return type
function returnMyName() : string {
    return myName
}

// function argument types
function testArgument(value1: number ,value2:number) : number{
    return value1 * value2
}
console.log(testArgument(3,2))

// function types
let superMultiply : (a: number, b:number) =&amp;gt; number

superMultiply = testArgument
let resultMultiply = testArgument(4,6);
console.log(resultMultiply);
console.log(superMultiply);
console.log(superMultiply(2,20))


// Types of Objects : Properties = key + value
// Custom type 만들기
type heroName = {name : string, age : number,address : string}

let heroOne : heroName = {name :'Batman', age : 29,address :&quot;jeju&quot;}
let heroTwo: heroName = {name :'Superman', age : 29,address :&quot;jeju&quot;}
let heroThree: heroName = {name :'ironman', age : 29,address :&quot;jeju&quot;}


// 둘이상의 type : Union types
let hreoTeam : string[] | number[] | boolean[] = ['Superman','Batman'] 


// check types = typeof
let finalWinner = &quot;Batman&quot;

if(typeof finalWinner == &quot;string&quot;){
    console.log(finalWinner);
}


// Scope
// 호출순서를 주의해라 
let batman = 'Level One';
console.log(batman);

function superman(){
    let spiderman = 'Level two';
    console.log(spiderman);

    function ironman(){
        let hulk = 'Levelthree';
        console.log(hulk);
        
    }
    ironman();  
}

// anonymous function
let multifly2 = function (number1 : number, number2 : number) : number{
    return number1 + number2;
}
// Arrow Function
let multifly3 = (number1 : number, number2 : number) =&amp;gt; number1 + number2
// 익명함수를 애로우펑션으로 바꿀수잇다.

console.log(multifly3(3,5));


// Rest &amp;amp; Spread
// ...을 통해서 스프레트 가능하다.
// Math.max(1,2,3,4) 이런식으로 와야하는데 배열이오면 함수를 실행치 못하므로 
// 이럴때 스프레드를 사용한다. 
let numbers = [1,2,3,4,5]
console.log(Math.max(...numbers));

// Rest 
// 고정적인 아규먼트와, 스프레드 아규먼트를 좀더 간략하게 사용하는것이 
// restArgument
function totatlWage(fixedPayment : number, ...number : number[]){
     
    for (let i in number){
        sum += number[i];
    }
    return sum + fixedPayment
}
console.log(totatlWage(50,19,29));


// Template Literals
let hero1 = &quot;Superman&quot;
let address = &quot;jejudo&quot;

let introduction1= hero1 + &quot; lives at &quot; + address;
let introduction2= `From 2007, ${hero1} lives at ${address}`;


console.log(introduction1);
console.log(introduction2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 31 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/js/2021/07/31/ts-1/</link>
        <guid isPermaLink="true">http://localhost:4000/js/2021/07/31/ts-1/</guid>
        
        <category>js</category>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>kotlinStudy-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;kotlin 스터디&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;변수-및-자료형&quot;&gt;변수 및 자료형&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주석은 자바와 동일하다.&lt;/li&gt;
  &lt;li&gt;세미콜론은 붙이지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;클래스는 파스칼표기법&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수, 함수는 카멜표기법을 지켜야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;var : 일반적인 변수이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;val : 불변 변수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;var a : int 등의 방법으로 자료형을 표현해야한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;println()함수 로 CLI로 출력 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린은 무조건 변수에 초기값을 선언해야한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;var a? = null을 허용하는 변수가 선언된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;자료형은 자바와 거의 동일하다.&lt;/li&gt;
  &lt;li&gt;다른점은 String타입인데 “”” 블라블라 “””&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”&quot;”으로 감싸진 String은 특수문자까지 String으로 표현가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린에서는 프리미티브 타입이 Int 이런 형식으로 대문자로 시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;형변환과-배열&quot;&gt;형변환과 배열&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;toLong(), toInteger() 등 명시적 형변환을 제공한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;형변환을 위해서는 사용자가 직접 변경하여야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;var intArr = arrOf(1,2,3,4,5)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위와같은 형식으로 배열을 선언할수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;var nullArr = arrayOfNulls&lt;Int&gt;(5)&lt;/Int&gt;&lt;/li&gt;
  &lt;li&gt;위와같은 형식으로 배열을 길이를 제한하고 null로 채울수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;타입추론과-함수&quot;&gt;타입추론과 함수&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;변수 var는 다양한 함수추론을 제공한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본적인 int,string,double,char등 타입추론이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;함수작성은 자바와 비슷하다.&lt;/li&gt;
  &lt;li&gt;인자를 받고 리턴값을 설정한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun add(a:Int, b:Int, c:Int): Int{
  return a+b+c;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 코드처럼 리턴값의 자료형은 함수선언부에 같이 작성 해야한다.&lt;/p&gt;

&lt;p&gt;그리고 코틀린에서 함수를 단일 표현식 함수를 허용한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  fun add(a:Int,b:Int,c:Int) = a+b+c;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의코드는 단일표현식을 허용하기 때문에 선언부에서 함수의 리턴값의 정의를 표현할수있으며, 타입추론으로 인해 리턴타입이 생략된 코드이다.&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/2021/07/29/kotlinStudy-1/</link>
        <guid isPermaLink="true">http://localhost:4000/book/2021/07/29/kotlinStudy-1/</guid>
        
        <category>java</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>spring cloud study - 4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;7-장애-허용-시스템-구축&quot;&gt;7. 장애 허용 시스템 구축&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;resilience4j 를 활용한 circuit breaker 패턴 적용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;resilience + 4j : 회복탄력성(데미지를 받았을때 극복하는성질) + 4j(for java)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;질병관리, 트래픽제어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트래픽양을 조절할수는 없지만 어떻게 받고 어디로 보낼지를 설정할수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;격백 패턴 : 장애가 발생했을때 그것을 차단하는 패턴
    &lt;ul&gt;
      &lt;li&gt;나의 기능이 a-z에서 사용되는데 어떤 부분에(d-api) 에러가 발생했을시 d 서비스를 차단하는것&lt;/li&gt;
      &lt;li&gt;장애가 발생한 일부분의 api를(시스템)을 막는 기능이라고 볼수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;bulkhead 패턴을 메소드 호출 방식으로 구현 with resilience4j
    - 메소드로 설정한 조건을 만족하지 않으면 거절하는 방식&lt;/li&gt;
  &lt;li&gt;circuit 
    - 안정성 회복을 위해서 사용됨 
    - 상태값이 존재하여 특정 오류횟수에 도달하면 요청을 처리하지 못하게 하는것
    - 그리고 일정시간 지난뒤 정상적이 요청이 들어왔을 받아들입니다. 
    - 즉 상태값에 따라 열었다 닫았다 하는 기능입니다.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 19 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/19/spring-cloud-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/19/spring-cloud-4/</guid>
        
        <category>cloud</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>security batch-2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spring-batch-task--chunk&quot;&gt;spring batch Task &amp;amp; Chunk&lt;/h2&gt;

&lt;h2 id=&quot;1-task--chunk&quot;&gt;1. Task &amp;amp; Chunk&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;배치를 처리할 수 있는 방법은 크게 2가지&lt;/li&gt;
  &lt;li&gt;Tasklet을 사용한 Task 기반처리
    &lt;ul&gt;
      &lt;li&gt;배치 처리 과정이 비교적 쉬운 경우 쉽게 사용&lt;/li&gt;
      &lt;li&gt;대량 처리를 하는 경우 더 복잡&lt;/li&gt;
      &lt;li&gt;하나의 큰 덩어리를 여러 덩어리로 나누어 처리하기 부적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Chunk를 사용한 chunk 기반 처리
    &lt;ul&gt;
      &lt;li&gt;ItemReader, ItemProcessor, ItemWrtier의 관계 이해 필요&lt;/li&gt;
      &lt;li&gt;대량처리를 하는 경우 Tasklet보다 비교적 쉽게 구현&lt;/li&gt;
      &lt;li&gt;예를 들면 10,000개의 데이터 중 1000개씩 10개의 덩어리로 수행
        &lt;ul&gt;
          &lt;li&gt;이를 Tasklet으로 처리하면 10000개를 한번에 처리하거나, 수동으로 1000개씩 분할&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-jobscope-stepscope&quot;&gt;2. jobScope, stepScope&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;jobScope는 job이 생성될고 소멸될때의 사이클을 가진다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stepScope도 step이 생성될고 소멸될때의 사이클을 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이들은 빈자체가 생성주기를 갖게 되고 범위를 가지게 되면서 스레드 세잎 해진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-itemreader&quot;&gt;3. ItemReader&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;배치 대상 데이터를 읽기 위한 설정
    &lt;ul&gt;
      &lt;li&gt;파일,DB,네트워크 등에서 읽기 위함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;step에 itemReader는 필수&lt;/li&gt;
  &lt;li&gt;기본제공되는 ItemReader 구현체
    &lt;ul&gt;
      &lt;li&gt;file,jdbc,jpa,hibernate,kafka&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ItemReader 구현체가 없으면 직접개발&lt;/li&gt;
  &lt;li&gt;ItemStream은 ExecutionContext로 read, write정보를 저장&lt;/li&gt;
  &lt;li&gt;CustomItemReader예제 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-itemwriter&quot;&gt;4. ItemWriter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ItemWriter 구현체가 없으면 직접개발&lt;/li&gt;
  &lt;li&gt;csv, jdbc, jpa등이 사용됨&lt;/li&gt;
  &lt;li&gt;jdbc
    &lt;ul&gt;
      &lt;li&gt;JdbcBatchItemWriter를 이용해 insert/update/delete가능&lt;/li&gt;
      &lt;li&gt;단건 처리가 아니기 때문에 비교적 높은 성능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jpa
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Bean
public Step jpaItemWriterStep() throws Exception {
    return stepBuilderFactory.get(&quot;jpaItemWriterStep&quot;)
            .&amp;lt;Person, Person&amp;gt;chunk(10)
            .reader(itemReader())
            .writer(jpaItemWriter())
            .build();
}

private ItemWriter&amp;lt;Person&amp;gt; jpaItemWriter() throws Exception {
    JpaItemWriter&amp;lt;Person&amp;gt; itemWriter = new JpaItemWriterBuilder&amp;lt;Person&amp;gt;()
            .entityManagerFactory(entityManagerFactory)
          //.usePersist(true)
            .build();

    itemWriter.afterPropertiesSet();
    return itemWriter;
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;jpaItemWriter는 위와같이 실행된다.&lt;/p&gt;

    &lt;p&gt;JPA는 변경감지가 되면 merge를 진행하는데 이를 방지하기 위한 메소드가 .usePersist이다.&lt;/p&gt;

    &lt;p&gt;itemReader값을 가져오고 이 데이터가 id 혹은 변경감지 대상이 되지 않는다면 .usePersist를 사용하지 않아도 되긴한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-itemprocessor&quot;&gt;5. ItemProcessor&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;itemReader, itemWriter 의 기능을 할수있지만 명확한 책임을 부여하기 위해서 각각의 기능을 수행하는것이 좋다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ItemProcessor는 추가적인 필터링 기능을 수행함이 좋다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;CompositeItemProcessorBuilder()를 통해서 여러개의 processor를 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;delegates(param1, param2,..) 등을 통해서 여러개의 함수를 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-itemwriter&quot;&gt;6. ItemWriter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ItemReader()가 CSV 파일을 읽었을때&lt;/li&gt;
  &lt;li&gt;JpaWriterBuilder()를 통해서 Writer를 생성할수있다.&lt;/li&gt;
  &lt;li&gt;그리고 entityManagerFactory()로 영속화 한다음 Jpa에 넣을수있는것이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 19 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/19/spring-batch-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/19/spring-batch-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>security batch-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spring-batch&quot;&gt;spring batch&lt;/h2&gt;

&lt;h2 id=&quot;1spring-batch&quot;&gt;1.spring batch&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;큰 단위의 작업을 일괄처리&lt;/li&gt;
  &lt;li&gt;대부분 처리량이 많고 비 실시간성 처리에 사용
    &lt;ul&gt;
      &lt;li&gt;대용량 데이터 계산, 정산, 통계, 데이터베이스,변환 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴퓨처 자원을 최대로 활용
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 자원 사용이 낮은 시간대에 배치를 처리하거나&lt;/li&gt;
      &lt;li&gt;배치만 처리하기 위해 사용자가 사용하지 않는 또 다른 컴퓨터 자원을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 상호작용으로 실행되기 보단, 스케줄러와 같은 시스템에 의해 실행되는 대상
    &lt;ul&gt;
      &lt;li&gt;예를들면 매일 오전 10시에 배치 실행, 매주 월요일 12 시마다 실행&lt;/li&gt;
      &lt;li&gt;crontab, jenkins…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;배치 처리를 하기 위한 spring Framework기반 기술
    &lt;ul&gt;
      &lt;li&gt;spring에서 지원하는 기술 적용 가능&lt;/li&gt;
      &lt;li&gt;DI, AOP 서비스 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 배치의 실행 단위인 Jop과 step&lt;/li&gt;
  &lt;li&gt;비교적 간단한 작업(Tasklet) 단위처리와 대량 묶음(Chunk) 단위처리 알아볼것&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-스프링-배치-example를-위한-프로젝트-설정&quot;&gt;2. 스프링 배치 example를 위한 프로젝트 설정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;spring boot 기반&lt;/li&gt;
  &lt;li&gt;java8&lt;/li&gt;
  &lt;li&gt;gradle&lt;/li&gt;
  &lt;li&gt;JPA, JDBC&lt;/li&gt;
  &lt;li&gt;SpringBatch&lt;/li&gt;
  &lt;li&gt;loombook&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;h2, mysql&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;@EnableBatchProcessing // 스프링 배치를 사용하기 위한 애노테이션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-스프링-배치의-과정&quot;&gt;3. 스프링 배치의 과정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스프링배치는 job타입의 빈이 생성되면 잡런처 객체에 의해서 잡을 실행합니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;잡은 스탭을 실행하게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;잡리파지터리는 DB,memory에 스프링배치가 실행될수있도록 배치의 메타 데이터를 관리하는 클래스입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;잡리파지터리를 스프링배치의 전반적인 데이터를 관리하는 클래스입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;job은 jobLauncher에 의해 실행&lt;/li&gt;
  &lt;li&gt;Job은 배치의 실행 단위를 의미&lt;/li&gt;
  &lt;li&gt;Job은 N개의 step을 실행할 수 있으며, 흐름을 관리할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;예를 들면, A Step 실행 후 조건에 따라 B Step 또는 C Step을 실행 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Step은 Job의 세부 실행 단위이며, N개가 등록되 실행된다.&lt;/li&gt;
  &lt;li&gt;Step의 실행 단위는 크게 2가지로 나눌 수 있다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;chunk 기반 : 하나의 큰 덩어리를 n개씩 나눠서 실행&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Task기반 : 하나의 작업 기반으로 실행&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;chunk기반 step은 itemReader, ItemProcessor, ItemWriter가 있다.
    &lt;ul&gt;
      &lt;li&gt;여기서 item은 배치 처리 대상 객체를 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ItemReader는 배치처리 대상 객체를 읽어 itemProcessor또는 ItemWriter에게 전달한다.
    &lt;ul&gt;
      &lt;li&gt;예를들면, 파일 또는 DB에서 데이터를 읽는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ItemProcessor는 input객체를 output객체로 filtering 또는 processing 해 ItemWriter에게 전달한다.
    &lt;ul&gt;
      &lt;li&gt;예를들면, iterReader에서 읽은 데이터를 수정 또는 ItemWirter 대상인지 filtering한다.&lt;/li&gt;
      &lt;li&gt;ItemProcessor는 optional 하다.&lt;/li&gt;
      &lt;li&gt;ItemProcessor가 하는일을 itemreader또는 itemWriter가 대신할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ItemWriter는 배치 처리 대상 객체를 처리한다.
    &lt;ul&gt;
      &lt;li&gt;예를들면, DB update를 하거나, 처리 대상 사용자에게 알림을 보낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Job은 하나의 이름과 파라미터로 실행된다.
    &lt;ul&gt;
      &lt;li&gt;job instance의 생성기준은 이름과 파라미터를 가지고 생성, 재실행,실패를 판단한다.&lt;/li&gt;
      &lt;li&gt;하나의 job은 같은 파라미터로 여러개 생성하거나 실행 할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ExcutionContext는 job,step을 모두 포함하는 최상위 클래스이며 이를 통해서 데이터가 공유될수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;중요&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;JobExcution은 해당 Job내에서 데이터 공유가 가능하다 (key를 불러올수있음)&lt;/li&gt;
    &lt;li&gt;하지만 각각의 Step은 본 Step에서만 데이터 입력등이 가능하고 저장, 삽입 가능합니다.&lt;/li&gt;
    &lt;li&gt;Job 내부에 2~n 개의 step존재시 step 끼리 데이터 공유는 불가합니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 19 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/19/spring-batch-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/19/spring-batch-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 8</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;상속리팩터링
====&lt;/p&gt;

&lt;h2 id=&quot;1-메서드-올리기&quot;&gt;1. 메서드 올리기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;부모 클래스에 특정메소드가 존재하는데 자식 클래스에도 같은 메서드가 존재할때 이땐 부모클래스에만 메서드를 정의하고 사용하면 된다.&lt;/li&gt;
  &lt;li&gt;복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 이런 경우라면 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-필드-올리기&quot;&gt;2. 필드 올리기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서브 클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 필드 중복의 경우가 많이 발생한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네이밍 뿐만 아니라 의도 까지 말이다. 그렇기 때문에 비슷한 방식으로 생각되면 슈퍼클래스로 끌어올리자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;필드 올리기 장점
    &lt;ol&gt;
      &lt;li&gt;데이터 중복 선언을 없앨 수 있다.&lt;/li&gt;
      &lt;li&gt;해당 필드를 사용하는 동작을 서브클래스로 옮길 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-생성자-본문-올리기&quot;&gt;3. 생성자 본문 올리기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서브 클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 적용해 슈퍼클래스로 옮기는게 좋다.&lt;/li&gt;
  &lt;li&gt;하지만 생성자라면 복잡하다. 생성자는 할수있는 일과 호출 순서에 제약이 존재하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;절차
    1. 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다.
    2. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다.
    3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다.
    4. 테스트한다.
    5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다.&lt;/p&gt;

&lt;h2 id=&quot;4메서드-내리기&quot;&gt;4.메서드 내리기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;특정 서브클래스 하나 와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스에 추가하는 편이 깔끔하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5필드-내리기&quot;&gt;5.필드 내리기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서브클래스 하나에서만 사용하는 필드는 해당 서브클래스로 옮긴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-타입코드를-서브클래스로-바꾸기&quot;&gt;6. 타입코드를 서브클래스로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;타입코드는 프로그래밍 언어에 따라 열거형이나 심볼,문자열,숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할때 딸려오는 일이 흔하다.&lt;/li&gt;
  &lt;li&gt;서브클래스는 두 가지 면에서 특히 매력적이다.
    &lt;ol&gt;
      &lt;li&gt;조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다. 서브클래스를 이용하면 이런 함수들에 조건부 로직을 다형성으로 바꾸기를 적용할 수 있다.&lt;/li&gt;
      &lt;li&gt;특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-서브클래스-제거하기&quot;&gt;7. 서브클래스 제거하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서브클래싱은 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-슈퍼클래스-추출하기&quot;&gt;8. 슈퍼클래스 추출하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다.
    &lt;ul&gt;
      &lt;li&gt;메서드 올리기를 사용하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속 관계를 만드는이유?
    &lt;ul&gt;
      &lt;li&gt;정석: ‘현실 세계에서 활용하는 어떤 분류 체계에 기초하여 구현에 …’&lt;/li&gt;
      &lt;li&gt;실천: 글래스 짜다가 공통분모 있으면 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;절차&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;빈클래스 만들기&lt;/li&gt;
  &lt;li&gt;공통된 변수 및 메서드 옮기기&lt;/li&gt;
  &lt;li&gt;테스트하기&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;9-계층-합치기&quot;&gt;9. 계층 합치기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;계층구조도 진화하면서 어떤 클르스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다.&lt;/li&gt;
  &lt;li&gt;이러한 경우에 그 둘을 하나로 합쳐야 할 시점이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;절차&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;두 클래스 중 제거 할 것을 고른다.&lt;/li&gt;
  &lt;li&gt;필드올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮긴다.&lt;/li&gt;
  &lt;li&gt;제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다.&lt;/li&gt;
  &lt;li&gt;빈 클래스를 제거한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;10-서브-클래스를-위임으로-바꾸기&quot;&gt;10. 서브 클래스를 위임으로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;상속의 단점은 한번만 쓸 수 있는 카드라는 것이다.&lt;/li&gt;
  &lt;li&gt;무언가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상속의 다른문제는 부모를 수정하면 자식도 수정되는 연계문제이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;위임은 이러한 문제를 모두 해결해준다.&lt;/li&gt;
  &lt;li&gt;위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의 할 수 있다.&lt;/li&gt;
  &lt;li&gt;즉 상속보다 결합도가 훨씬 약하다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상속 관련 문제에 직면하면 흔히 서브클래스 위임으로 바꾼다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;‘상속보다 컴포지션을 사용하라’ 라는 문구가 있다.&lt;/li&gt;
  &lt;li&gt;컴포지션은 사실상 위임과 동일하다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 17 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/17/refactoring-8/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/17/refactoring-8/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>spring cloud study - 3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;스프링-클라우드-gateway&quot;&gt;스프링 클라우드 gateway&lt;/h1&gt;

&lt;h2 id=&quot;1-gateway&quot;&gt;1. gateway&lt;/h2&gt;

&lt;p&gt;처리과정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;client -&amp;gt; GateWay Handler Mapping -&amp;gt; Gate Way Web Handler -&amp;gt; Filter chain ~~(Filter, Filter) -&amp;gt; Dest&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-api-gw를-이용한-api-proxy실습&quot;&gt;2. API GW를 이용한 API proxy실습&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;API GW를 통해 요청이 전달되도록 설정하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;API GW(localhost:7080) -&amp;gt; photoAPP(localhost:8080)&lt;/p&gt;

&lt;p&gt;GW를 별도로 열고 이를 연동하는 식으로 진행한다.&lt;/p&gt;

&lt;p&gt;요구사항은 다양하게 진행할수있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;시간에 따라 서비스를 열수있도록&lt;/li&gt;
  &lt;li&gt;특정 요청만 받는 서비스 등등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자세한 참고는 spring-gateway 브런치 참고&lt;/p&gt;

&lt;h2 id=&quot;3-eurekaapp&quot;&gt;3. eurekaApp&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;api 를 관리하는 eureka server&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-쓰기-요청-분산&quot;&gt;4. 쓰기 요청 분산&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;rabbitmq / 카프카 두 종류가 나와있다.&lt;/li&gt;
  &lt;li&gt;어떠한 queue서버에 메시지를 보내고 특정 topic이 발견되었을시 리시버를 통해서 받을수있는 시스템이다.&lt;/li&gt;
  &lt;li&gt;rabbimq 예제는 동작과정을 이해를 못했고…. 예제도 못해봤다…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-분산환경에서-client개발&quot;&gt;5. 분산환경에서 client개발&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ribbon
    &lt;ul&gt;
      &lt;li&gt;로드발란스 역할을 수행가능한 client side loadBalance 입니다.&lt;/li&gt;
      &lt;li&gt;대응하기가 어려운 점이 있습니다.&lt;/li&gt;
      &lt;li&gt;REST&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FeignClient(집중)
    &lt;ul&gt;
      &lt;li&gt;Declarative REST Client&lt;/li&gt;
      &lt;li&gt;어떤 클라이언트의 요청을 페인 클라이언트가받고 페인클라이언트가 해당 요청을 수행하게 됩니다.
        &lt;ul&gt;
          &lt;li&gt;일종의 로드밸런서 입니다.&lt;/li&gt;
          &lt;li&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;web service 클라이언트를 보다 쉽게 작성할 수 있도록 도와줍니다.&lt;/li&gt;
      &lt;li&gt;인터페이스를 작성하고 어노테이션을 붙여주면 세부적인 내용없이 사용할 수 있기 때문에 코드 복잡도가 낮아집니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eureka와 feignClient를 연동하면 편리하다
    &lt;ul&gt;
      &lt;li&gt;why? feignClient(내가 요청한 API)를 몰라도 eureka에 등록한 이름 정보만으로 쉽게 해당 API를 불러올수있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 13 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/13/spring-cloud-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/13/spring-cloud-3/</guid>
        
        <category>cloud</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>spring cloud study - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;스프링-클라우드&quot;&gt;스프링 클라우드&lt;/h1&gt;

&lt;h2 id=&quot;1-스프링-클라우드&quot;&gt;1. 스프링 클라우드?&lt;/h2&gt;

&lt;p&gt;클라우드는 분산된 시스템입니다. 복잡성은 애플리케이션 레벨에서 네트워크 레벨로 움직이고 이들끼리 서로 상호작용을 진행합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처 : https://spring.io/cloud&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클라우드를 위한 12 요소&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드베이스 : 버전관리되는 하나의 코드베이스와 여러가지 배포&lt;/li&gt;
  &lt;li&gt;종속성 : 명시적으로 선언되고 분리된 종속성&lt;/li&gt;
  &lt;li&gt;설정 : 환경에 저장된 설정&lt;/li&gt;
  &lt;li&gt;백엔드 서비스 : 백엔드 서비스를 연결된 리소스로 취급&lt;/li&gt;
  &lt;li&gt;빌드,릴리즈,실행 : 철저하게 분리된 빌드와 실행단계&lt;/li&gt;
  &lt;li&gt;프로세스 : 애플리케이션을 하나 혹은 여러개의 무상태 프로세스로 실행&lt;/li&gt;
  &lt;li&gt;포트바인딩 : 포트 바인딩을 사용해서 서비스를 공개함&lt;/li&gt;
  &lt;li&gt;동시성 : 프로세스 모델을 사용한 확장&lt;/li&gt;
  &lt;li&gt;폐기가능 : 빠른시작과 그레이스풀 셧다운을 통한 안정성 극대화&lt;/li&gt;
  &lt;li&gt;개발/프로덕션환경 일치 : 개발, 스테이징, 프로덕션 환경을 최대한 비슷하게 유지&lt;/li&gt;
  &lt;li&gt;로그 : 로그를 이벤트 스트림으로 취급&lt;/li&gt;
  &lt;li&gt;관리자 프로세스 : 관리/유지 작업을 일회성 프로세스로 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처 : www.12factor.net&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;### 스프링 클라우드 아키텍처&lt;/p&gt;

&lt;p&gt;IoT,Mobile,Browse -&amp;gt; APIGateway -&amp;gt; Serviceregistry -&amp;gt; MicroService ;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;APIGateway
    &lt;ul&gt;
      &lt;li&gt;Zuul : 더이상 개발하지 않는 모델&lt;/li&gt;
      &lt;li&gt;Zuul2 : 넷플릭스가 개발한 게이트웨이&lt;/li&gt;
      &lt;li&gt;Spring cloud gateway : 스프링에서 관리하는 클라우드 게이트 웨이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service registry
    &lt;ul&gt;
      &lt;li&gt;DNS &amp;amp; IP vs Navtice Cloud&lt;/li&gt;
      &lt;li&gt;Eureka를 사용할 것임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Config server : 공통적으로 사용하는 리소스 관리 (DB,gateway.. Service registry.. 등)
    &lt;ul&gt;
      &lt;li&gt;Spring cloud Config : 공통적으로 사용하는 리소스 관리 (DB,gateway.. Service registry.. 등)&lt;/li&gt;
      &lt;li&gt;Spring cloud event bus : 업데이트(변경사항 관리 )&lt;/li&gt;
      &lt;li&gt;Spring Vault : 암호화 및 민감정보 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributed Tracing : 분산된 서버의 로깅 방법
    &lt;ul&gt;
      &lt;li&gt;MDC(Mapped Diagnostic Context) : SL4j등에서 로깅할때 사용하는 방법&lt;/li&gt;
      &lt;li&gt;Spring Cloud sleuth / zipkin : 스프링에서 관리하는 로깅 추적 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-스프링-클라우드-프로젝트-셋팅&quot;&gt;2. 스프링 클라우드 프로젝트 셋팅&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;image upload 시스템&lt;/li&gt;
  &lt;li&gt;api만 제공되고 테스트는 swagger를 통해서 진행함&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 13 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/13/spring-cloud-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/13/spring-cloud-2/</guid>
        
        <category>cloud</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>Algostudy 1</title>
        <description>&lt;p&gt;title: javaStudy-1
subtitle: “study, struct”
categories: book
tags: struct 
comments: true
—&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;자바 알고 스터디&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1&quot;&gt;1.&lt;/h2&gt;

</description>
        <pubDate>Tue, 13 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/07/13/algoStudy-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/07/13/algoStudy-1/</guid>
        
        
      </item>
    
      <item>
        <title>spring cloud study - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;스프링-클라우드&quot;&gt;스프링 클라우드&lt;/h1&gt;

&lt;p&gt;실무에서는 하나의 서버로 관리하기 힘들다.&lt;/p&gt;

&lt;p&gt;데이터 처리관점 및 다양한 관점에서 클라우드 또는 네트워크를 구성해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HA : 고 가용성&lt;/li&gt;
  &lt;li&gt;Resilience : 복원력&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-웹서비스-확장-전략&quot;&gt;1. 웹서비스 확장 전략&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;실무 개발 유형
    &lt;ul&gt;
      &lt;li&gt;솔루션 : db 접근제어, 암호화, 사용자(비즈니스 관점) ex) b2b 시스템을 대체적으로 말한다.&lt;/li&gt;
      &lt;li&gt;SI : 회사의 특정 기능을 수정하는 개발이다.&lt;/li&gt;
      &lt;li&gt;서비스 : 내부적으로 기능을 개발하고 사용자에게 전달하는 관점, 항상 서비스 되어야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링이 꼭 필요한것은 아니다. 각 상황에 맞게(기업의) 확장 전략을 선택해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-클라우드가-필요한-서비스&quot;&gt;2. 클라우드가 필요한 서비스?&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;두가지 경우로 나눠 볼수있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스케일업을 통한 서비스 확장
    &lt;ul&gt;
      &lt;li&gt;scale-up : 컴퓨터의 자원을 늘리는 확장&lt;/li&gt;
      &lt;li&gt;무중단을 위해서는 높은 자원보다 끊기지 않는 상황이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스케일 아웃을 통한 서비스 확장
    &lt;ul&gt;
      &lt;li&gt;scale-out : 컴퓨터의 자원은 동일하고 여러대의 컴퓨터를 사용하는 방법&lt;/li&gt;
      &lt;li&gt;장애 대응에 효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-서버-부하-분산-네트워크&quot;&gt;3. 서버 부하 분산 네트워크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서버 : 무언가를 제공하는 대상&lt;/li&gt;
  &lt;li&gt;부하 : Load =&amp;gt; 많은 요청이 들어온(요구된) 상황&lt;/li&gt;
  &lt;li&gt;분산 : 스케일아웃(분산) 나눠서 하는것(흩어짐)
    &lt;ul&gt;
      &lt;li&gt;통계값과 평균값의 차이인 편차를 제곱하여 얻은 값들의 산술 평균&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크 : 통신 설비를 갖춘 컴퓨터를 이용해 서로 연결시켜주는 조직이나 체계&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-dns-서버-실습&quot;&gt;4. DNS 서버 실습&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;spring boot 웹서버 예제를 만들어 간단하게 controller를 만들어봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @GetMapping(&quot;/&quot;)
  public String hello(){
      return &quot; hi~~~~ man &quot;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음과 같은 컨트롤러를 통해서 웹서버의 응답을 받을수있습니다.&lt;/p&gt;

&lt;p&gt;그리고 local은 localhost:8080~~ 를 통해서 응답받을수 있는데, &lt;br /&gt;
  이를 다른 DNS를 지정하고 싶다면&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo vim /etc/hosts 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;파일을 수정하면된다.&lt;/p&gt;

&lt;h2 id=&quot;5-dns-매핑-및-웹서버-연동&quot;&gt;5. DNS 매핑 및 웹서버 연동&lt;/h2&gt;

&lt;p&gt;WellKnown port 가 주어진다.&lt;/p&gt;

&lt;p&gt;하지만 이는 권한과 연결된다.&lt;/p&gt;

&lt;p&gt;클라이언트는 80포트로 웹서버에 들어오면 웹서버는 8080포트로 스프링부트와 연결된다.&lt;/p&gt;

&lt;p&gt;웹서버와 api(스프링부트)의 권한이 다르기 때문에 포트가 다르다.&lt;/p&gt;

&lt;p&gt;우리가 만든 API서버는 루트 권한을 주지 않아도 보안이슈없이 사용할수있게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DNS와 HTTPS
    &lt;ul&gt;
      &lt;li&gt;최근 대형 서비스들은 https를 사용하는데 인증서를 구매해야한다.&lt;/li&gt;
      &lt;li&gt;wild 카드 인증서 *.도메인.com 이라면 dot이 2개일때만 지원가능하다.&lt;/li&gt;
      &lt;li&gt;그래서 test-a.domain.com // dev-a.domain.com등으로 사용하는 팁이있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-virtual-ip-와-dns&quot;&gt;6. virtual IP 와 DNS&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;무중단을 위해서 사용하는것이 virtual IP를 사용한다. (VIP라도 명하기도 함)&lt;/li&gt;
  &lt;li&gt;vip는 로드밸런싱의 역할을 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;외부에서 여러가지 요청이 올수 있습니다.&lt;/li&gt;
  &lt;li&gt;여러가지 요청이 들어왔을시 이를 나눠줄수있는 (분산) 방법은 DNS의 방법이 있습니다.&lt;/li&gt;
  &lt;li&gt;DNS을 기준으로 분산처리를 할수있는데 이또한 엄청난 요청이 온다면?&lt;/li&gt;
  &lt;li&gt;virtual IP 를 설정하고 하여 각 기능을 수행하는 API로 요청을 전달하여 분산할수있습니다.&lt;/li&gt;
  &lt;li&gt;이렇게 되면 요청을 분산하는 서버가 존재하고 논리적으로 이를 다른 포트에 연결해주는(API)에 전송할수있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;7-읽기-요청-부하-분산&quot;&gt;7. 읽기 요청 부하 분산&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;외부의 여러가지 요청 또한 세분화 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;읽기, 쓰기 등등 여러가지 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;같은 요청이 반복적으로 들어온다면 ?
    &lt;ul&gt;
      &lt;li&gt;동일한 요청을 처리하는 방법은 cache입니다.&lt;/li&gt;
      &lt;li&gt;캐시 : 요청을 중복되지 않게 저장하고 만약에 동일한 요청이 오면 DB에 접근하지 않고 저장한 내용을 보여주는것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로드밸런싱을 통한 여러대의 API가 존재한다면 ? 캐시의 내용이 공유되지 않아서 분산이 잘되지 않을수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;데이터의 정합성을 보장하지 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위와같은 경우는 캐시서버를 따로 두는 해법이 존재한다. (레디스, 멤캐쉬 등)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로컬캐시는 정적인 이미지나 특정 api에 대한 요청을 수행하고 다른것은 별도의 캐시서버를 두는게 일반적입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;읽기 요청 부하 분산의 가장 중요한 점은 DB에 어떻게 적은 접근을 할까? 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-클러스터링과-레플리카&quot;&gt;8. 클러스터링과 레플리카&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;7.챕터의 노력에도 불구하고 물리적인 DB에 접근(요청)이 많아 문제가 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇다면 DB를 스케일아웃합니다. 이를 HA라고 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나의 방법인 클러스터링은 마스터노드와 네트워크 노드를 구성하고 하위의DB서버에게 분별된 요청을 수행하게 하는것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 방법인 레플리카는 db의 모든 것을 복제해서 여러개를 놓는것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9-샤딩&quot;&gt;9. 샤딩&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클러스터링이 좋은데 비용을 고려해야한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클러스터링은 모든것을 공유하니 고비용이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;범위를 지정해서 DB를 사용하는것이 샤딩입니다.&lt;/li&gt;
  &lt;li&gt;데이터베이스의 데이터를 기준으로 나누는것
    &lt;ul&gt;
      &lt;li&gt;기준이 있어야하는데 기준은 날짜,DB수,다양한 조건으로 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;10-쓰기-요청-분산&quot;&gt;10. 쓰기 요청 분산&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;업로드가 오래 걸려 조회서비스가 안된다면..?
    &lt;ul&gt;
      &lt;li&gt;upload 서버를 따로 두는 방법이 존재합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다수의 업로드서버가 존재한다면 또 성능이 나오지 않을것입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 무거운 요청을은 폴링과 콜백이벤트를 통해서 처리 해야합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링에서 이벤트를 처리할수있는 eventListener를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처리과정&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;controller 에서 특정 기능 수행후 이벤트를 날릴수잇다.&lt;/li&gt;
  &lt;li&gt;service에서 기능처리를 하며 이때 EvnetPublisher의 메소드에 넘긴다.&lt;/li&gt;
  &lt;li&gt;ApplicationEventPublisher가 이벤트를 등록한다.&lt;/li&gt;
  &lt;li&gt;@EventListenser 를 사용한 onCustomFileEventHandler()을 통해서 여러가지 이벤트 후 처리를 진행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;11-분산환경에서의-메시지-큐-활용&quot;&gt;11. 분산환경에서의 메시지 큐 활용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;파일이벤트 실습의 문제점( 무거운 요청 ) 분산처리과정이 문제가됨&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이벤트 드리븐 서버가 1대일 때는 실습과정 처럼 하면 되지만&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무거운 요청이 무지막지 하게 많이 오면 이를 처리하는데만 시간이 소요&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 따라 서버를 두어 메시지 큐를 활용함(카프카.. rabbitMQ)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;분산환경에서 효율적인 처리를 위해서 분산과정을 한다.&lt;/p&gt;

&lt;p&gt;앤프로 2는 미니배열을 잘보면 보통 키보드에는 꼭있는 깔끔한 미니배열방향키때문에 방향시 사용에대해서 컨트롤 쉬프트 등을 통해서 방향키를 사용할수있습니다. 캡스락을 이용해서 앤프로투는 방향키를 사용할수있게 했습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/12/spring-cloud-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/12/spring-cloud-1/</guid>
        
        <category>cloud</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 7</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;API 리팩터링
====&lt;/p&gt;

&lt;p&gt;모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, api는 이 블록들을 끼워 맞추는 연결부이다.&lt;/p&gt;

&lt;h2 id=&quot;1-질의-함수와-변경-함수-분리하기&quot;&gt;1. 질의 함수와 변경 함수 분리하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문장슬라이스 하기에서 나온 부분이긴 하다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;질의 함수(get)은 질의만 해야한다. 질의함수 내에서는 어떤 값의 변경이 없어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;외부에서 관찰할 수 있는 겉보기 부수효과가 전혀 업이 값을 반환해주는 함수를 추구해야한다.&lt;/li&gt;
  &lt;li&gt;이를 실행하기 위해서는 질의함수(읽기함수)는 모두 부수효과가 없어야한다는 규칙을 따르는것이다.&lt;/li&gt;
  &lt;li&gt;이를 CQS(command query separate) 라고 부르고 절대적으로 따르는 사람도 많다.&lt;/li&gt;
  &lt;li&gt;값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하여 시도해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;함수를 복제하고 질의 목적에 맞는 이름 짓기&lt;/li&gt;
  &lt;li&gt;새 질의 함수에서 부수효과를 낳는 부분을 제거하기&lt;/li&gt;
  &lt;li&gt;이제 원래 함수를 호출하는 곳을 모두 찾아서 새로운 질의 함수를 호출하고록 바꾸고, 이어서 원래의 변경 함수를 호출하는 코드를 바로 아래에 삽입한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-함수-매개변수화-하기&quot;&gt;2. 함수 매개변수화 하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;두함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리 하는 함수 하나로 합쳐서 중복을 없앨수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;비슷한 함수중 하나를 선택한다.
    &lt;ul&gt;
      &lt;li&gt;비슷한 함수들을 매개변수화 하여 통합할때는 먼저 대상 함수중 하나를 골라 매개변수를 추가한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 선언 바꾸기를 리터럴들을 매개변수로 추가한다.&lt;/li&gt;
  &lt;li&gt;이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다.&lt;/li&gt;
  &lt;li&gt;테스트&lt;/li&gt;
  &lt;li&gt;매개변수로 받은 값을 사용하도록 함수 본문을 수정한다.&lt;/li&gt;
  &lt;li&gt;비슷한 다른함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-플래그-인수-제거하기&quot;&gt;3. 플래그 인수 제거하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결국은 가독성의 문제이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;저자는 플래그 인수를 2개이상 사용하는것과 플래그인수 그자체를 좋은 시선으로 보고 있지않다
    &lt;ul&gt;
      &lt;li&gt;왜? 함수사용시에 있어 고려해야하는 부분으로 사용자가 고려해야하는 부분으로 받아들이기 때문이다. 그렇기 때문에 명확적인 함수를 제공하는게 더 좋다고 생각한다.
        &lt;h2 id=&quot;4-객체-통째로넘기기&quot;&gt;4. 객체 통째로넘기기&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수(파라미터) 여러개를 넘긴다면 함수이해하기가 매우 어려워진다.&lt;/li&gt;
  &lt;li&gt;또한 중복된 코드가 발생할수있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이를 방지하고자 객체를 통재로 넘기는게 좋다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;함수가 레코드 자체에 의존하기를 원치 않을 때는 하지 말자
    &lt;ul&gt;
      &lt;li&gt;레코드와 함수가 서로 다른 모듈이라면 특히 하지말자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 함수에 객체에서 가져온 값 몇 개만으로 무언가를 한다면?
    &lt;ul&gt;
      &lt;li&gt;그 객체로 옮겨줘야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체 전반에서 똑같은 값 몇개만 사용하는 함수가 많다면?
    &lt;ul&gt;
      &lt;li&gt;그 부분 클래스 추출 해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;new접두사를 붙인 빈함수를 만든다.&lt;/li&gt;
  &lt;li&gt;새함수의 본문에서 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다.&lt;/li&gt;
  &lt;li&gt;정적검사&lt;/li&gt;
  &lt;li&gt;모든 호출자가 새함수를 사용하게 수정한다.&lt;/li&gt;
  &lt;li&gt;호출자를 모두 수정했다면 원래 함수를 인라인한다.&lt;/li&gt;
  &lt;li&gt;새함수의 이름을 적절히 수정하고 모든 호출자에 반영한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-매개변수를-질의-함수로-바꾸기&quot;&gt;5. 매개변수를 질의 함수로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;매개변수를 제거하면 값을 결정하는 책임 주체가 달라진다.&lt;/li&gt;
  &lt;li&gt;매개변수가 있다면 결정 주체가 호출자가 된다.&lt;/li&gt;
  &lt;li&gt;매개변수가 없다면 피호출함수가 된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출하는 쪽을 간소하게 즉 책임소재를 피호출함수로 올기는 것이 좋다. 물론 피호출 함수가 그역할을 수행하기에 적합할때만 하는게 좋다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다.
    &lt;ul&gt;
      &lt;li&gt;매개변수를 제거하였을때, 피호출 함수에 원치 않는 의존성이 생길 때다.&lt;/li&gt;
      &lt;li&gt;즉. 해당함수가 알지 못했으면 하는 프로그램요소에 접근해야 하는 상황을 만들 때다.&lt;/li&gt;
      &lt;li&gt;새로운 의존성이 생기거나 제거하고 싶은 기존 의존성을 강화하는 경우라 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-질의함수를-매개변수로-바꾸기&quot;&gt;6. 질의함수를 매개변수로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;전역변수를 참조하거나, 제거하길 원하는 원소를 참조하는 경우&lt;/li&gt;
  &lt;li&gt;해당 참조를 매개변수로 바꿔 해결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-세터-제거하기&quot;&gt;7. 세터 제거하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;세터 제거하기는 두가지 상황으로 나뉜다.&lt;/li&gt;
  &lt;li&gt;첫째 : 무조건 접근자 메서드를 통해서만 필드를 다루려 할때다. 생성자 안에서도 세터로 값변경하는것이다.&lt;/li&gt;
  &lt;li&gt;둘째 : 클라이언트에서 생선 스크립트를 사용해 객체를 생성할 때다.
    &lt;ul&gt;
      &lt;li&gt;생성스크립트 : 생성자를 호출한 후 일련의 세터를 호출하여 객체를 완성하는 형태의 코드를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-생성자를-팩터리-함수로-바꾸기&quot;&gt;8. 생성자를 팩터리 함수로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;팩터리 함수를 사용하면 서브클래스의 인스턴스나 프락시도 반환가능하다.
    &lt;ul&gt;
      &lt;li&gt;자바는 생성자의 정의한 클래스의 인스턴스를 반환해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;팩터리 함수에는 이러한 제약이 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;팩터리 함수를 만든다. (생성자에 위임하는 방식으로 구현한다.)&lt;/li&gt;
  &lt;li&gt;생성자를 호출하는곳을 수정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;9-함수를-명령으로-바꾸기&quot;&gt;9. 함수를 명령으로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;함수를 그함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다.&lt;/li&gt;
  &lt;li&gt;이런객체를 가리켜 ‘명령객체’ 또는 단순히 명령이라 한다.&lt;/li&gt;
  &lt;li&gt;명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체는 지원하지만 일급함수를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능을 대부분 흉내낼수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;명령은 되돌리기 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는데 필요한 매개변수를 만들어주는 메서드도 제공 할 수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   class Score{
       constructor(a,b,c){
           this.a = a;
           this.b = b;
           this.c = c;
       }

       execute(){
           this.result = 0;
           ~
            ~ // 수많은 코드들
       }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와같이 명령을 함수내부에 둘수있고 이는 수명주기, 보조연산에서 매우 유용하게 사용된다.  &lt;br /&gt;
  예를들면 안드로이드를 생각하면 run등..의 여러가지 실행함수가 존재함을 알수있다.&lt;/p&gt;

&lt;h2 id=&quot;10-명령을-함수로-바꾸기&quot;&gt;10. 명령을 함수로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다.&lt;/li&gt;
  &lt;li&gt;명령 객체가 단순하면 괜히 복잡하게 기능을 구현하게 된것이다. » 관점에 따라 이는 악취가 될수있다.&lt;/li&gt;
  &lt;li&gt;그러므로 명령이 단순하다면 함수로 바꿔주는게 났다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-수전된-값-반환하기&quot;&gt;11. 수전된 값 반환하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;데이터가ㅈ수정된다면 그사실을 명확하게 알려주어 함수혹은 변수의 목적을 설명하는것이 좋다.&lt;/li&gt;
  &lt;li&gt;함수옮기기 의 준비작업인 셈이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12-오류-코드를-예외로-바꾸기&quot;&gt;12. 오류 코드를 예외로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;예외처리가 가능한 프로그래밍에서 예외를 날리면 좋다 .&lt;/li&gt;
  &lt;li&gt;이는 콜스택 어느곳에서든지 에러를 처리할수있기 때문이다.&lt;/li&gt;
  &lt;li&gt;하지만 c언어를 생각해보면 반환형이 int등으로 되어있었고 현재는 포인터를 넘겨서 에러를 확인해야한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 c언어의 방식에서 에러처리는 함수호출전의 라인에서 에러를 컨트롤 할수있게된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그렇다면 예외처리 클래스가 좋은데 예외가 예상이 가면 이를 조건문으로 처리하는것이 좋다.&lt;/li&gt;
  &lt;li&gt;알수있는 에러는 미리 방지하는것이다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 06 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/07/06/refactoring-7/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/07/06/refactoring-7/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 6</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;데이터 조직화
====&lt;/p&gt;

&lt;h2 id=&quot;1-변수쪼개기&quot;&gt;1. 변수쪼개기&lt;/h2&gt;

&lt;p&gt;역할 하나당 변수하나이다.&lt;/p&gt;

&lt;p&gt;역할 둘 이상인 변수가 있다면 쪼개야한다. 여러용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.&lt;/li&gt;
  &lt;li&gt;가능하면 이때 불변으로 선언한다.&lt;/li&gt;
  &lt;li&gt;이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름을 바꾼다.&lt;/li&gt;
  &lt;li&gt;두번째 대입시 변수를 원래 이름으로 다시 선언한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;같은 역할에 여러 번의 할당은 필요할 때도 있다.
    &lt;ul&gt;
      &lt;li&gt;루프변수&lt;/li&gt;
      &lt;li&gt;수집변수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-필드-이름-바꾸기&quot;&gt;2. 필드 이름 바꾸기&lt;/h2&gt;

&lt;p&gt;어떤 개발자는 이런말을 했다고한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;데이터 테이블 없이 흐름도만 보여주면 혼란스럽다. 하지만 데이터 테이블을 보여주면 흐름도는 필요없을 것이다. &lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요없다.&lt;/li&gt;
  &lt;li&gt;레코드가 캡슐화됮 않았다면 우선 레코드를 캡슐화 한다.&lt;/li&gt;
  &lt;li&gt;캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;생성자의 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언바꾸기로 변경한다.&lt;/li&gt;
  &lt;li&gt;접근자들의 이름도 바꿔준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;데이터구조를 불변으로 만들수있는 프로그래밍은 데이터구조의 값을 복제해 새로운 이름으로 선언한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-파생-변수를-질의-함수로-바꾸기&quot;&gt;3. 파생 변수를 질의 함수로 바꾸기&lt;/h2&gt;

&lt;p&gt;가변데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속한다.&lt;/p&gt;

&lt;p&gt;그래서 가변데이터의 유효 범위를 가능한 좁혀야 한다고 힘주어 주장한다.&lt;/p&gt;

&lt;p&gt;해결방법으로는 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거 하는 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.&lt;/li&gt;
  &lt;li&gt;해당 변수의 값을 계산해주는 함수를 만든다.&lt;/li&gt;
  &lt;li&gt;해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;변수를 읽는 코드를 모두 함수 호출로 대체한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-참조를-값으로-바꾸기&quot;&gt;4. 참조를 값으로 바꾸기&lt;/h2&gt;

&lt;p&gt;객체 내부를 수정하던 것을, “값 객체” 통째 하나로 바꾸끼&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참조로 다루는 경우 : 내부 객체는 그대로 둔채 그 객체의 속성만 변경&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;갑으로 다루는 경우 : 새로운 속성을 담으 ㄴ객체로 기존 내부 객체를 통째로 대체&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;값객체(불변) : setter 없이 constructor만으로&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-값을-참조로-바꾸기&quot;&gt;5. 값을 참조로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;왜 반대되는 방향으로 가는것일까?
    &lt;ul&gt;
      &lt;li&gt;데이터를 갱신해야 할 때, 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 일관성이 깨진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저장소
    &lt;ul&gt;
      &lt;li&gt;‘값 객체’들은 담아둘(예를 들면) hashmap&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-매직-리터럴-사용하기&quot;&gt;6. 매직 리터럴 사용하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;상수값을 사용해서 명료하게 만들어라&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;조건부 로직 간소화
====&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조건부 로직은 프로그램의 크게 기여한다.&lt;/li&gt;
  &lt;li&gt;조건부 분해하기, 중복 조건식 통합하기, 중첩 조건문을 보호구문으로 바꾸기, 조건부로직 다형성으로 바꾸기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-조건문-분해하기&quot;&gt;1. 조건문 분해하기&lt;/h2&gt;

&lt;p&gt;조건부로직은 프로그램에 많은 영향을 끼치지만 이해하기 어려운 부분에 속한다.&lt;/p&gt;

&lt;p&gt;이러한 조건부 로직을 코드블럭 단위로 의도를 살린 이름의 함수 호출로 바꿔주는 리팩터링이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;더 나은 이름 : “조건문 함수화하기”
    &lt;ul&gt;
      &lt;li&gt;조건,분기 모두 함수로 추출해버려 가독성 높이기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“무슨일이 일어나는지는 이야기해주지만 ‘왜’ 일어나느지는 제대로 말해주지 않을때가 많은 것이 문제다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;조건문이 특이(특수한 상황)이면 -재사용성이 없을때- 이는 주관적인 판단으로 진행한다. (명확하다면 함수화 하지 않아도 된다. )&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-조건식-통합하기&quot;&gt;2. 조건식 통합하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 여러 조건문을 하나의 복잡한 조건문으로 통합하기&lt;/li&gt;
  &lt;li&gt;‘조건문 분해하기’의 반대가 아님. 오히려 ‘사전단계’에 가까울 있음&lt;/li&gt;
  &lt;li&gt;“부수효과”에 유의 (부수효과 : 코드를 수정하면서 발생하는 에러)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-중첩-조건문을-보호-구문으로-바꾸기&quot;&gt;3. 중첩 조건문을 보호 구문으로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;보호 구문 : 한쪽만 정상이라면 비정산 조건을 if에서 감사한 다음, 조건이 참이면 함수에서 빠져나온다.&lt;/li&gt;
  &lt;li&gt;보호구문을 진행하는 의도는 의미의 부각이다. (if-else)보다 if의 한줄이 가독성이 명확하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-조건부-로직을-다형성으로-바꾸기&quot;&gt;4. 조건부 로직을 다형성으로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;switch 대신 오버라이드 된 subclass에 각자 다른 동작 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-특이-케이스-추가하기&quot;&gt;5. 특이 케이스 추가하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문제
    &lt;ul&gt;
      &lt;li&gt;‘미확인 고객’의 경우 특수처리가 되어야 한다.
        &lt;ul&gt;
          &lt;li&gt;이름, 요금, 납부이력 등이 ‘기본값’ 처리 되어야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;문제는 이 ‘미확인 고객’의 정보를 참조하는 곳이 여러 곳에 분산 되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해결책
    &lt;ul&gt;
      &lt;li&gt;UnknownCustomer라는 특이 클래스로 처리해서 해결(일종의 다형성)&lt;/li&gt;
      &lt;li&gt;(이후 수정이 필요없을 경우) ‘기본값’을 갖는 literal object로 처리&lt;/li&gt;
      &lt;li&gt;변환함수에 통과시켜, 예외(unknown)가 ‘기본값’을 갖도록 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결과
    &lt;ul&gt;
      &lt;li&gt;조건문이 없어지고 ‘하나의 동작’으로 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-어서션-추가하기&quot;&gt;6. 어서션 추가하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;가정이 코드에 항상 명시적으로 기술되어 있지 않아 알고리즘을 보고 연역해서 알아내야 할 때&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어서션의 장점 : 에러 검출이 용이하다 &amp;amp;&amp;amp; 또한 다른 개발자에게 코드의 수정없이 알려줄수있어 소통측면에서 뛰어나다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어서션을 남발하는것도 위험&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-제어-플래그를-탈출문으로-바꾸기&quot;&gt;7. 제어 플래그를 탈출문으로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;제어 플래그 : 코드의 동작을 변경하는데 사용되는 변수&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 30 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/30/refactoring-6/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/30/refactoring-6/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 5</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;기능 이동
====&lt;/p&gt;

&lt;h2 id=&quot;1함수-옮기기&quot;&gt;1.함수 옮기기&lt;/h2&gt;

&lt;p&gt;좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘되어 있느냐를 뜻하는 모듈성이다.&lt;/p&gt;

&lt;p&gt;모듈성을 높이려면 서로 연관된 요소들은 함께묶고 요소사이의 연결관계를 쉽게 찾고 이해할 수 있도록 해야한다.&lt;/p&gt;

&lt;p&gt;어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈B의 요소들을 더 많이 참조한다면 모듈B로 옮겨줘야 마땅하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다. 이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.&lt;/li&gt;
  &lt;li&gt;선택한 함수가 다형 메서드인지 확인한다.&lt;/li&gt;
  &lt;li&gt;선택한 함수를 타깃 컨텍스트로 복사한다.(원래 함수를 source function,새로운 함수를 target function이라한다.)&lt;/li&gt;
  &lt;li&gt;정적 분석을 수행한다.&lt;/li&gt;
  &lt;li&gt;소스 컨텍스트에서 타킷 함수를 참조할 방법을 찾아 반영한다.&lt;/li&gt;
  &lt;li&gt;소스함수를 타깃 함수의 위임함수가 되도록 수정한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;소스함수를 인라인 할지 고민해본다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-필드-옮기기&quot;&gt;2. 필드 옮기기&lt;/h2&gt;

&lt;p&gt;프로그래밍의 힘은 적합한 데이터 구조를 활용하는것이다.&lt;/p&gt;

&lt;p&gt;주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다.&lt;/p&gt;

&lt;p&gt;프로젝트를 진행할수록 우리는 문제 도메인과 데이터 구조에 대해 더 많은것을 배우게 된다.&lt;/p&gt;

&lt;p&gt;함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소스 필드가 캡슐화되어 있지 않다면 캡슐화한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;타깃 객체에 필드를 생성한다.&lt;/li&gt;
  &lt;li&gt;정적 검사를 수행한다.&lt;/li&gt;
  &lt;li&gt;소스 객체에서 타킷 객체를 참조할수 있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;접근자들이 타깃필드를 사용하도록 수정한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;소스필드를 제거한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-문장을-함수로-옮기기&quot;&gt;3. 문장을 함수로 옮기기&lt;/h2&gt;

&lt;p&gt;중복제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나다. 예컨대 특정 함수를 호출하는 코드가 나올때마다 그 앞이나 뒤에서 똑같은 코드가 추가로 실행되는 모습을 보면 그 반복되는 부분을 피호출 함수로 합치는 방법을 궁리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다.&lt;/li&gt;
  &lt;li&gt;타킷 함수를 호출하는 곳이 한 곳이면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다. 이경우라면 나머지 단계는 무시한다.&lt;/li&gt;
  &lt;li&gt;호출자가 둘 이상이면 호출자 중 하나에서 ‘타킷 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께 다른 함수로 추출한다. 추출한 함수에 기억하기 쉬운 임시 이름을 지어준다.&lt;/li&gt;
  &lt;li&gt;다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다. 하나씩 수정할때마다 테스트한다.&lt;/li&gt;
  &lt;li&gt;모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인 한 후 원래 함수를 제거한다.&lt;/li&gt;
  &lt;li&gt;새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-문장을-호출한-곳으로-옮기기&quot;&gt;4. 문장을 호출한 곳으로 옮기기&lt;/h2&gt;

&lt;p&gt;초기에는 응집도 높고 한 가지 일만 수행하던 함수가 어느새 둘이상의 다른 일을 수행하게 바뀔 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;이런상황에 맞닥뜨리면 우선 문장 슬리이드 하기를 적용해 달리는 동작을 함수의 시작 혹은 끝으로 옮긴 다음, 바로 이어서 문장을 호출한 곳으로 옮기기 리팩터링을 적용하면된다.테&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;호출자가 한,두개 뿐이고 피호출 함수도 간단한 단순한 상항이면, 피호출 함수의 처름 을 잘라내어 호출자로 복사해 넣는다. 스트만 통과하면 이번 리팩터링을 여기서 끝이다.&lt;/li&gt;
  &lt;li&gt;더 복잡한  상황에서는, 이동하지 ‘않길’ 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 임시 이름을 지어준다.&lt;/li&gt;
  &lt;li&gt;원래 함수를 인라인한다.&lt;/li&gt;
  &lt;li&gt;추출된 함수의 이름을 원래 함수의 이름으로 변경한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-인라인-코드를-함수-호출로-바꾸기&quot;&gt;5. 인라인 코드를 함수 호출로 바꾸기&lt;/h2&gt;

&lt;p&gt;함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 떄문에 함수를 활용하면 코드를 이해하기가 쉬워진다.&lt;/p&gt;

&lt;h2 id=&quot;6-문장-슬라이드-하기&quot;&gt;6. 문장 슬라이드 하기&lt;/h2&gt;

&lt;p&gt;관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다.&lt;/p&gt;

&lt;p&gt;이를 위해서 문장 슬라이드하기 리팩터링을 사용하면 좋다.&lt;/p&gt;

&lt;p&gt;가장 흔한 사례는 변수를 선언하고 관련된 내용의 바로 위에 자리에서 사용하는것이다.&lt;/p&gt;

&lt;p&gt;함수 추출하기의 준비 단계로 자주 행해진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드 조각을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치 사이의 코드들을 훑어보면서, 조각을 모으고 나면 동작이 달리지는 코드가 있는지 살핀다. 다음과 같은 간섭이 있다면 이 리팩터링을 포기한다.&lt;/li&gt;
  &lt;li&gt;코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;무엇을 슬라이드할지와 슬라이드할 수 있는지 여부가 중요한다. 무엇을 슬라이드는 맥락과 관련이 깊다.&lt;/p&gt;

&lt;h2 id=&quot;7-반복문-쪼개기&quot;&gt;7. 반복문 쪼개기&lt;/h2&gt;

&lt;p&gt;반복문 하나에서 두가지 일을 수행하는 모습을 보게 된다. 하지만 이런 방법은 추후 수정하기 어려워진다.&lt;/p&gt;

&lt;p&gt;하나의 반복문에서 여러가지 업무를 수행하기 때문이다.&lt;/p&gt;

&lt;p&gt;반복문 분리하면 사용하기도 쉬워진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;반복문을 복제해 두개로 만든다.&lt;/li&gt;
  &lt;li&gt;반복문이 중복되어 생기는 부수효과를 파악해서 제거한다.&lt;/li&gt;
  &lt;li&gt;테스트한다.&lt;/li&gt;
  &lt;li&gt;완료됐어면,각 반복문을 함수로 추출할지 고민해본다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;8-반복문을-파이프라인으로-바꾸기&quot;&gt;8. 반복문을 파이프라인으로 바꾸기&lt;/h2&gt;

&lt;p&gt;컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;map은 함수를 사용해 입력 컬렉션의 각 원소를 변환하고, filter는 또 다른 함수를 사용해 입력 컬렉션을 필터링해 부분집합을 만든다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다.&lt;/li&gt;
  &lt;li&gt;반복문의 첫줄부터 시작해서, 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이때 컬렉션 파이프라인 연산은 1에서 만든 반복문을 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행된다. 하나를 대체할 때마다 테스트한다.&lt;/li&gt;
  &lt;li&gt;반복문의 모든 동작을 대체했다면 반복문 자체를 지운다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;9-죽은-코드-제거하기&quot;&gt;9. 죽은 코드 제거하기&lt;/h2&gt;

&lt;p&gt;최근 컴파일러는 스스로 사용하지 않는 코드에는(불필요한 코드)는 알아서 작동하지 않는 매커니즘으로 동작한다.&lt;/p&gt;

&lt;p&gt;이는 사용하지 않는 코드를 메모리에 올리지 않는것이다.&lt;/p&gt;

&lt;p&gt;그렇다고 하더라도 사용하지 않는 코드는 제거하는것이 좋다고 말한다.&lt;/p&gt;

&lt;p&gt;우리는 버전관리 시스템을 사용하므로 추후에 이 코드가 다시 필요해진다면 버전을 불러오면 되기에 사용치 않는 코드는 제거하는것이 옳다.&lt;/p&gt;

</description>
        <pubDate>Thu, 24 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/24/refactoring-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/24/refactoring-5/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;캡슐화
====&lt;/p&gt;

&lt;h2 id=&quot;1레코드-캡슐화하기&quot;&gt;1.레코드 캡슐화하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;레코드는 명확한 값과 명확하지 않은값을 구분해서 저장해야하는 점이 번거롭다.&lt;/li&gt;
  &lt;li&gt;객체를 사용하면 어떻게 저장했는지 숨긴 채 세 가지값을 각각의 메소드로 제공할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하려함이다.&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한곳에 모아두는 일이 굉장히 중요하다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;캡슐화는 모든쓰기 를 함수 안에서 처리한다는 원칙이 존재한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;getter, setter 를 이용해서 OOP의 클래스를 만드는 경우&lt;/li&gt;
  &lt;li&gt;중첩된 레코드 (JSON)- 레코드 아래 또 다른 레코드가 있을때
    &lt;ul&gt;
      &lt;li&gt;하위 레코드에 대한 읽기 쓰기도 메소드로 생성(상위 레코드에)&lt;/li&gt;
      &lt;li&gt;최상단 클래스화 - 그다음도 클래스화 하면 중첩구조도 클래스를 중첩된 경우도 재귀적으로 사용할수있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-컬렉션-캡슐화하기&quot;&gt;2. 컬렉션 캡슐화하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이 바뀌어 버릴 수 있다.&lt;/li&gt;
  &lt;li&gt;컬렉션을 소유한 클래스를 통해서만 원소를 변경하도록 프로그램을 개선하면서 컬렉션 변경 방식도 원하는 대로 수정할수있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션에 접근하려면 컬렉션이 소속된 클래스의 적절한 메서드를 반드시 거치게 하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;add/remove를 통한 컬렉션 접근&lt;/li&gt;
  &lt;li&gt;게터는 생성하되 세터는 만들지 않는걸로&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-기본형을-객체로-바꾸기&quot;&gt;3. 기본형을 객체로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;단순 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다.&lt;/li&gt;
  &lt;li&gt;기본형 집착 악취&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-임시-변수를-질의-함수로-바꾸기&quot;&gt;4. 임시 변수를 질의 함수로 바꾸기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;임시 변수를 사용하면 값을 계산하는 코드가 반복되는걸 줄이고 값의 의미를 설명할 수도 있어서 유용하다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-클래스-추출하기&quot;&gt;5. 클래스 추출하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래스는 반드시 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다는 가이드라인이 존재한다.&lt;/li&gt;
  &lt;li&gt;메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-클래스-인라인하기&quot;&gt;6. 클래스 인라인하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리팩터링을 하고 난 후 특정 클래스에 남은 역할이 거의 없을때 이런 현상이 생긴다.&lt;/li&gt;
  &lt;li&gt;두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스르 인라인 한다.
    &lt;ul&gt;
      &lt;li&gt;:&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우려사항 : 하는일이 별로없는데 여러클래스에서 사용한다면 인라인 하기 어렵다고 생각한다.
    &lt;ul&gt;
      &lt;li&gt;추출과 인라인 사이는 직관에 따라 가야한다. 책은 단순 기법만 설명하는것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-위임-숨기기&quot;&gt;7. 위임 숨기기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;위임객체 : 중첩구조에서 중간 객체
    &lt;ul&gt;
      &lt;li&gt;하위 객체의 정보를 입출력하기 위해 위임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;중첩구조를 알 필요가 없어짐&lt;/li&gt;
  &lt;li&gt;위임 객체의 인터페이스가 바뀌면 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-중개자-제거하기&quot;&gt;8. 중개자 제거하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;위임 숨기기의 배경에서 반대되는 개념이다.&lt;/li&gt;
  &lt;li&gt;위임 메서드를 통해서 추가적인 단순 전달만 하는기능만 수행하다 보면 메서드들이 점점 성가셔 진다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러면 위임 메서드는 중개자 역할을 수행하게 되고 차라리 직접 클라잉언트가 위임 객체를 직접 호출하는게 나을수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;중개자 제가하기는 판단하기 힘들다. 왜냐하면 개발자의 직관으로 판단해야함이다. 혹은 팀내(회사) 코딩 컨벤션등을 따라야한다&lt;/li&gt;
  &lt;li&gt;위임객체 혹은 중개자 설정은 트레이프 관계 임으로 상당한 고려(회의) 통해서 진행되어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9-알고리즘-변경하기&quot;&gt;9. 알고리즘 변경하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;복잡한 알고리즘(지저분) 존재할때 간편하게 할수있다면 알고리즘 교체도 좋은 방법이고 이를 캡슐화 한다면 좋다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 17 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/17/refactoring-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/17/refactoring-4/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>javaStudy-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;자바 스터디&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;목표&quot;&gt;목표&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;자바 소스파일(.java)을 JVM으로 실행하는 과정이해하기&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;학습할-것&quot;&gt;학습할 것&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;JVM 이란 무엇인가&lt;/li&gt;
  &lt;li&gt;컴파일 하는 방법&lt;/li&gt;
  &lt;li&gt;실행하는 방법&lt;/li&gt;
  &lt;li&gt;바이트코드란 무엇인가.&lt;/li&gt;
  &lt;li&gt;JIT 컴파일이란 무엇이며 어떻게 동작하는지&lt;/li&gt;
  &lt;li&gt;JVM 구성요소&lt;/li&gt;
  &lt;li&gt;JDK와 JRE의 차이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;JVM이란 무엇인가.
====&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바 컴파일러는 .java 파일을 .class파일로 변환한다. 하지만 바이트코드는 기계어가 아니기 때문에 OS에서 실행되지 못한다. &lt;br /&gt;
 바이트코드가 os에서 실행되도록 도움을 주는 녀석이 JVM이다.&lt;/p&gt;

&lt;p&gt;JVM은 바이트코드를 해석해 os에서 실행할수있도록 도와주는 가상머신이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;바이트코드
====&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바 파일을 컴파일하여 생성되는 .class 파일을 바이트 코드라고 한다.&lt;/p&gt;

&lt;p&gt;바이트코드는 JVM이 이해하고 OS에 관계없이 실행될수있는 장점이 존재한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;컴파일 하는 방법
====&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고수준의 소스코드를 저수준의 코드로 변환하는 작업&lt;/li&gt;
  &lt;li&gt;어떠한 소스코드를 기계어로 변환하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;방법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;javac 를 통해서 컴파일 할수있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자바파일을 생성한다.&lt;/li&gt;
  &lt;li&gt;CLI 환경에서 자바를 설치한다.&lt;/li&gt;
  &lt;li&gt;javac HelloWorld.java : 명령어를 수행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;-d : class을 생성할 root 디렉터리를 지정&lt;/li&gt;
  &lt;li&gt;-sourcepath : compile하기 위해 필요로 하는 참조할 source file 위치를 지정&lt;/li&gt;
  &lt;li&gt;-g : 디버깅 정보를 생성&lt;/li&gt;
  &lt;li&gt;-verbose : 컴파일와 링커가 현재 어느 소스파일이 컴파일 되고 있고, 어느 파일에 링크되고 있는지 정보 출력&lt;/li&gt;
  &lt;li&gt;-target : 지정된 java 버전의 JVM에서 작동되도록 .class 파일을 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;JIT컴파일러란 무엇이며 어떻게 동작하는가?
====&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램을 실제 실행하는 시점에 기계어로 번역하는 compile기법&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동작 과정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JIT compiler는 실행 시점에서 인터프리터 방식으로 기계어 코드를 생성하면서 그 코드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;캐싱&lt;/code&gt;하여, 같은 함수가 여러번 불릴때 매번 기계어 코드 생성을 방지한다.&lt;/p&gt;

&lt;p&gt;즉, java compiler가 java 프로그램 코드를 -&amp;gt; 바이트코드로 변환한 다음 -&amp;gt; 실제 바이트코드를 실행하는 시점에서 JVM이 JIT 컴파일을 통해 바이트코드를 기계어로 번역한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Interpreter와 JIT Compiler 비교&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Interpreter
자바 바이트코드를 한줄씩 실행, 여러번 실행하는 환경에선 다소 느림&lt;/li&gt;
  &lt;li&gt;JIT Compiler
인터프리터의 단점을 보완, 전제 바이트코드를 컴파일, 캐시사용으로 한번 컴파일 하면 다음에는 빠르게 수행너무 불편한데 안그러냐 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sourceCode.java -&amp;gt; Compiler -&amp;gt; ByteCode -&amp;gt; JIT Compiler -&amp;gt; Native machineCode&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;JVM 구성요소
====&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;1-class-loader&quot;&gt;1. class Loader&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;runTime시점에 .class에서 바이트코드를 읽고 메모리에 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;클래스로더&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;was에 웹앱이 올라간 경우 상위 클래스 class loader로 class를 -&amp;gt; 메모리에 올려 놓으면 설사 class가 잘못됐다 하더라도 프로그램을 종료하지 않고선 정보를 지우는 방법이 따로 없다.&lt;/p&gt;

    &lt;p&gt;만약, 번경된 클래스가 적용되게 하려면?&lt;/p&gt;

    &lt;p&gt;user Define class Loader (ex. TomCat ClassLoader 구조) 가 필요하다.&lt;/p&gt;

    &lt;p&gt;상위 class loader에서 읽어들인 클래스일수록, 나중에 클래스를 변경하기가 어렵다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;class Loader가 bytecode를 읽는 두가지 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;new bytecode가 실행될때&lt;/li&gt;
  &lt;li&gt;바이트코드가 클래스를 정적으로 참조 할때&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;자바 코드를 컴파일 하고 실행시키기 위해 항상 메인 메서드를 생성하는데, 이때 메인 메서드는 스태틱 메서드로 클래스 로더가 가장먼저 로드한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;클래스 로더가 클래스를 읽는 절차&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클래스가 이미 로드되어있는지 확인&lt;/li&gt;
  &lt;li&gt;로드되지 않는 경우 부모 클래스 로더에 클래스를 로드하도록 요청&lt;/li&gt;
  &lt;li&gt;부모 클래스 로더가 클래스를 로드할 수 없는 경우 자식? 클래스 로드에 로드&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;클래스로더는 계층적, 끝까지 도달 했을때 class를 찾지 못한다면 classNotFoundException으로 RunTimeException이 발생됨
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;클래스 로더 구성&lt;/strong&gt;
    - loading : class를 읽어오는 과정
    - link : reference를 연결하는 과정
    - initialization : static 값들을 초기화 및 변수에 할당&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;h2 id=&quot;2-runtime-data-area-jvm-memory&quot;&gt;2. Runtime Data Area (JVM Memory)&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JVM이 프로그램을 수행하기 위해 운영체제로부터 필요한 만큼 할당 받는 메모리 공간&lt;/li&gt;
  &lt;li&gt;자바가 실행될때 사용되는 Data를 적재하는 영역&lt;/li&gt;
  &lt;li&gt;Runtime Data Area라고 불림&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Data 적재영역 구성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static Area
    &lt;ul&gt;
      &lt;li&gt;하나의 .java파일은 field, constructor, method로 구성된다. 필드에 부분에서 선언된변수와 정적 멤버 변수의 데이터를 저장&lt;/li&gt;
      &lt;li&gt;static 영역의 데이터는 프로그램 시작부터 종료될때 까지 메모이레 남아있음, 즉 전역변수가 프로그램이 종료될때 까지 어디서든 사요ㅗㅇ이 가능한 이유이다.&lt;/li&gt;
      &lt;li&gt;모든 쓰레드가 공유하는 메모리 영역&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;하나의 JVM당 하나의 Method Area가 존재하며 자원을 공유한다.&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;stack Area
    &lt;ul&gt;
      &lt;li&gt;모든 지역변수 데이터 값 저장&lt;/li&gt;
      &lt;li&gt;메소드 호출 후 메모리에 할당되고 종료되면 메모리에서 해제 됨&lt;/li&gt;
      &lt;li&gt;thread 당 영역이 존재하기 때문에 thread-safe하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap Area
    &lt;ul&gt;
      &lt;li&gt;모든 객체를 저장하는곳&lt;/li&gt;
      &lt;li&gt;힙에 생성된 객체는 주소를 가지고 있으며 유지하고 있음, 객체가 해제되는 경우는 GC에 의해서 해제됨&lt;/li&gt;
      &lt;li&gt;쓰레드 세잎 하지 않기 때문에 주의를 요함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PC Registers
    &lt;ul&gt;
      &lt;li&gt;쓰레드가 생성될때마다 생기는 공간&lt;/li&gt;
      &lt;li&gt;함수의 주소를 가지고 있다가 다시 되돌아올때 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Native Methd Stack
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h2 id=&quot;자바외-언어로-작성된-코드를-위한-메모리-영역&quot;&gt;자바외 언어로 작성된 코드를 위한 메모리 영역&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;3execution-engin&quot;&gt;3.Execution Engin&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;load된 class의 바이크코드를 실행하는 런타임 모듈&lt;/li&gt;
  &lt;li&gt;클래스로더를 통해 JVM내에 런타임 데이터 영역에 배치된 바이트코드를 execution engine에의해 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;구성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;interpreter
    &lt;ul&gt;
      &lt;li&gt;바이트코드를 더 빨리 해석하지만 느리게 실행한다.&lt;/li&gt;
      &lt;li&gt;단점은 하나의 메서드가 여러번 호출 될 떄마다 새로운 해석이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JIT compiler
    &lt;ul&gt;
      &lt;li&gt;interpreter의 단점을 보완&lt;/li&gt;
      &lt;li&gt;반복된 코드를 찾으면 전체 바이트코드를 컴파일 하고 네이트브 코드로 변경하는 JIT compiler를 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GC(Garbage Collector)
    &lt;ul&gt;
      &lt;li&gt;참조되지 않는 객체를 모아서 제거한다.&lt;/li&gt;
      &lt;li&gt;GC를 호출하여 수동으로 할 수 있지만 실행이 보장되지는 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;jdk-jre의-차이&quot;&gt;JDK JRE의 차이&lt;/h1&gt;

&lt;p&gt;JDK 는 JRE에 추가로 자바프로그램을 개발하는데 필요한 컴파일러, 디버거와 같은 명령어 개발 도구를 추가한 것이다.&lt;/p&gt;

&lt;p&gt;JRE는 자바 프로그램을 실행하기  위한 라이브러리, 자바 가상 기계, 기타 컴포넌트들을 제공한다.&lt;/p&gt;

</description>
        <pubDate>Sat, 12 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/2021/06/12/javaStudy-1/</link>
        <guid isPermaLink="true">http://localhost:4000/book/2021/06/12/javaStudy-1/</guid>
        
        <category>java</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본적인-리팩터링&quot;&gt;기본적인 리팩터링&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;함수 추출하기 
    - 목적과 구현을 분리하는 방법이 가장 합리적인 기준으로 보인다. 
    - 1 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다. (어떻게가 아닌 무엇을 하는지가 드러나야한다.)
    - 2 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여 넣는다.
    - 3 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다. 
    - 4 변수를 다 처리했다면 컴파일한다.
    - 5 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
    - 6 테스트를 한다.
    - 7 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방근 추출한 새 함수를 호출하도록 바꿀지 검토한다.(인라인코드를 함수 호출로 바꾸기)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 위의 과정을 통해서 진행하고 세부적인 내용(지역변수, 함수추출, 지역변수 매개변수화)등을 수행한다. 
  - 반환값이 여러개일땐? 
    - 저자는 하나의 값만 반환하는것을 선호하여 반환하는 함수를 여러개 만든다고 한다.
    - 레코드로 묵어서 반환해도 된다.
    - 임시수를 질의 함수로 바꾸거나 변수를 쪼개는 식으로 처리하면 좋다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;함수 인라인 하기 
    - 목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권한다. 
    - 간접 호출을 너무 과하게 쓰는 코드도 인라인 대상이다. 
    - 1 다형 메서드인지 확인한다.
    - 2 인라인할 함수를 호출하는 곳을 모두 찾는다.
    - 3 각 호출문의 함수 본문으로 교체한다. 
    - 4 하나씩 교체할 때마다 테스트한다. 
    - 5 함수 정의를 삭제한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 인라인시에 주의할점을 소개한다. 
  - 하나의 코드를 인라인 하면 편리하다. 
  - 하지만 로그를 여려개 찍는 코드를 인라인하면 복잡해지거나 더러워질수있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;변수 추출하기
    - 표현식이 너무 복잡해서 이해하기 어려울 때가 있다. 이럴 때 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다. (인라인시..!)
    - 문맥을 넓히는 것이다. 이때 주의할점은 할일이 늘어난다는것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 1 추출하려는 표현식에 부작용은 없는지 확인한다.
- 2 불변 변수를 하나 선언하고 이름을 붙일 표현식의 본제본을 대입한다.
- 3 원본 표현식을 새로 만든 변수로 교체한다.
- 4 테스트한다.
- 5 표현식을 여러곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 떄마다 테스트한다. 
- 클래스내부에서도 동일하게 작동되고 이때 더 효율적이다. 왜?? 클래스를 한눈에 볼수있으므로 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;변수 인라인 하기 
    - 변수는 함수안에서 표현식을 가리키는 이름으로 쓰이며, 대체로 긍정적인 효과를 준다. 
    - 1 대입문의 우변에서 부작용이 생기지는 않는지 확인한다.
    - 2 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.
    - 3 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다.
    - 4 테스트한다. 
    - 5 변수를 사용하는 부분을 모두 교체할 때까지 이과정을 반복한다. 
    - 6 변수 선언문과 대입문을 지운다.
    - 7 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수 선언 바꾸기
    - 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
    - 1 이어지는 추출단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
    - 2 함수본문을 새로운 함수로 추출한다. 
    - 3 추출한 삼수에 매개변수를 추가해야한다면 ‘간단한 절차’를 따라 추가한다.
    - 4 테스트한다.
    - 5 기존함수를 인라인한다.
    - 6 이름을 임시로 붙여뒀다면 함수선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
    - 7 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수 캡슐화화기
    - 데이터는 함수보다 다루기 까다로운데, 그 이유는 이런 식으로 처리할 수 없기 때문이다. 데이터는 참조하는 모든 부분을 한번에 바꿔야 코드가 제대로 작동한다. 짧은 함수 안의 임시 변수처럼 유효범위가 아주 좁은 데이터는 어려울게 없지만, 유효범위가 넓어질수록 다루기 어려워진다. 전역 데이터가 골칫거리인 이유도 바로 여기에 있다.
    - 1 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
    - 2 정적 검사를 수행한다.
    - 3 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
    - 4 변수의 접근 범위를 제한한다.
    - 5 테스트한다.
    - 6 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 변수 캡슐화하기에서 중요한점은 기존의 데이터의 변경뿐만 행위까지 변경하고 싶은 경우가 발생할수도 있다. 
- 이러한 경우는 기존데이터를 복사하는 방법으로 진행한다. 
- 생성자를 통해서 또는 리스트의 값을 반환하게 하는것이다. 
- 본제본 만들기와 클래스로 감싸는 방식은 레코드 구조에서 깊이가 1인 속성들 까지만 효과가 있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;변수 이름 바꾸기
    - 이름의 중요성은 그 사용 범위에 영향을 많이 받는다. 한 줄 짜리 람다식에서 사용하는 변수는 대체로 쉽게 파악할 수 있다. 
    - 1 폭널게 쓰이는 변수라면 캡슐화하기를 고려한다.
    - 2 이름을 바꿀 변수를 참조하는곳을 모두 찾아서, 하나씩 변경한다.
    - 3 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;매개변수 객체 만들기 
    - 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.
    - 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다.
    - 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을 다시 그릴 수도 있다. 
    - 1 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
    - 2 테스트한다.
    - 3 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
    - 4 테스트한다.
    - 5 함수 호출시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
    - 6 기존 매개변수를 사용하더 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
    - 7 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;여기서 부터 어려움&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;여러함수를 클래스로 묶기
    - 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. 
    - 1 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
    - 2 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
    - 3 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러 함수를 변환 함수로 묶기
    - 정보가 사용되는 곳마다 같은 도출 로직이 반복되기도 한다. 나는 이런 도출 작업들을 한데로 모아두길 좋아한다. 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
    - 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 났다. 변환 함수로 묵으면 가공한 데이터를 새로운 레코드에 저장하므로 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.
    - 1 변환할 레코드를 입력 받아서 값을 그래도 반환하는 변환 함수를 만든다.
    - 2 묶을 함수 중 함수 하나를 콜라서 본문 코드를 변환 함수로 옮기고 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
    - 3 테스트한다.
    - 4 나머지 관련 함수도 위 과정에 따라 처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단계 쪼개기
    - 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다. 
    - 1 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
    - 2 테스트한다.
    - 3 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
    - 4 테스트한다.
    - 5 추출한 두 번째 단계 함수의 매개변수를 하나씩 컴토한다.그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
    - 6 첫 번째 단계 코드를 함수로 추출 하면서 중간 데이터 구조를 반환하도록 만든다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/10/refactoring-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/10/refactoring-3/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>면접 질문 &amp; 나의 프로젝트 간단 요약</title>
        <description>&lt;h2 id=&quot;예상-질문&quot;&gt;예상 질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;1분 자기소개&lt;/dt&gt;
      &lt;dd&gt;안녕하세요 클린코드를 지향하는 지원자 떙떙떙입니다.  &lt;br /&gt;
학부시절 7개의 프로젝트 경험이 있습니다. 프로젝트를 통해 CS를 학습하였다고 생각합니다. 그때 작성한 코드는 스파게티 코드였다고 생각이 됩니다. 왜냐하면 코드의 가독성이 없었기 때문입니다. 하지만 지금은 리팩터링에 관심 많고 이해하기 쉬운코드, 효율적인 코드 작성을 노력중입니다.  &lt;br /&gt;
이런 노력을 통해 앞으로는 백엔드 개발자로 전문성을 키우고 싶습니다.  &lt;br /&gt;
전문성을 키우고자 spring,docker,git,DB 등을 학습하고 블로그에 기록하고 있습니다. &lt;br /&gt;
싸피를 통해 효율적인 코드, 협업, 전문성을 키우고 싶은 0년차 백엔드 주니어입니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;가장 자신있어 하는 것은 무엇인가요?&lt;/dt&gt;
      &lt;dd&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;관심 있는 IT 동향은 무엇인가요?&lt;/dt&gt;
      &lt;dd&gt;대용량 처리를 위해서 클러스터링, 레플리카는 어떻게 구성하는지 그리고  k8s는 어떻게 구성하고 , 카프카, 이벤트소싱, CQRS는 어떻게 구성하고 사용하는지 관심이 많습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;본인의 장점과 단점&lt;/dt&gt;
      &lt;dd&gt;쉽게 포기 하지 않는 장점이 있다고 생각합니다. 프로젝트를 진행하면 항상 밤을 새는 경우가 많았습니다. 하고싶은게 많은데 잘 안 되었기 때문에 밤새 몰두하는 경우가 많았습니다. 사소한 기능이라도 끝끝내 구현에 이르면 개발에 재미를 느끼곤 했습니다. 이런 경험의해서 저는 끈기가 있다고 생각합니다.&lt;/dd&gt;
      &lt;dd&gt;단점은 하나에 깊게 파고들다 보면 주변을 보지 못하는 단점이 있습니다. 밤새도록 코드작성 및 레퍼런스 검색을 하다보면 다른것에 집중하지 못 할때가 많았습니다.&lt;/dd&gt;
    &lt;/dl&gt;

    &lt;p&gt;쉽게 아는척하기 하는게 저의 단점이었습니다. 작은것이라도 알고있으니 잘안다고 생각했습니다. 하지만 컴퓨터를 학습하면서 내가 아는것이 정말 정확한가?? 알지도 못하면서 아는척하면 나에게나 남에게 엄청난 피해라는 것을 알게 되었고 
저는 이 단점을 작은것 하나라도 논리적으로 알며 명확하게 아는것만 말하고자 의식하고 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;지원동기&lt;/dt&gt;
      &lt;dd&gt;문제해결을 위한 알고리즘 , 진정한 협업을 경험하고자 지원하게 되었습니다.  &lt;br /&gt;
저는 학부시절 7개의 프로젝트를 진행하였는데 그중 5개를 같은 팀원과 진행하였습니다. sns로 버전관리, 주먹구구식 소통 등의 협업을 경험하였습니다. 그당시의 협업은 현재 제가 하고싶은 협업은 아니였다 라는 생각이 듭니다.  &lt;br /&gt;
저는 싸피에서 코드리뷰, git flow,pull request, CICD, 등 다양한 방법을 통해서 제대로 된 협업을 경험하고 싶습니다.  &lt;br /&gt;
이런 과정 중에 효율적 알고리즘에 의한 더빠른 , 더 이해하기 쉬운 코드를 작성방법을 배우고 싶습니다.  &lt;br /&gt;
알고리즘과 협업을 학습하고 경험하고 싶어 지원하게 되었습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;마지막으로 하고싶은말&lt;/dt&gt;
      &lt;dd&gt;싸피 설명회 통해서 코드리뷰가 진행됨을 알고있습니다. 이외에도 싸피 동기간 개발서적 스터디, 짝프로래밍등 다양한 IT문화를 경험할 수 있는 시스템이 있는지 궁금합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;어려움을 해결한 경험&lt;/dt&gt;
      &lt;dd&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;동료와의 갈등 , 해결 경험&lt;/dt&gt;
      &lt;dd&gt;c로 keyvalueStore 구현해야했습니다. 4학년과 팀이 되었고 제가 너무 프로그래밍 능력이 부족하다고 핀잔을 주었습니다. 맞는말이지만 기분은 좋지 않았습니다. 
그렇다고 여기서 제가 아무것도 안할수는 없기에 오히려 더 열심히 자료구조를 공부하고 i/o는 어떻게 받을지 준비를 많이 해갔습니다. 
팀원이 저의 정성을 보았나 제가 부족한 부분을 많이 알려주었고 둘 사이의 갈등 또한 사라졌습니다. 
플젝이 끝난뒤에 저는 내가 이런상황에서 팀원처럼 해야겠다는 다짐을 하였습니다. 정말 거의 모든걸 알려주었는데 저또한 열심히 배우려고 하였습니다. 
비트리와 해쉬를 사용하여 키밸류스토어를 구현할수있었고 좋은 프로젝트 결과를 얻을수있었습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;전공자인 내가 싸피를 교육이수의 메리트는 ? (나는 협업, 알고리즘)&lt;/dt&gt;
      &lt;dd&gt;저는 알고리즘, 협업능력이 부족하다고 생각됩니다. 또한 이것들은 제가 잘하고 싶은 영역입니다. &lt;br /&gt;
싸피를 통해 알고리즘,협업능력을 키울수있다고 알려져있습니다. 물론 혼자서도 할수있지만 싸피에서의 피드백을 받고 싶습니다. 멘토의 피드백, 동기의 피드백 이러한 IT문화를 경험하고 싶습니다. 또한 제가 아는것은 다 알려주고 싶습니다. 
이런 과정을 통해서 제가 성장 할 수 있다고 생각하기 떄문에 전공자인 제가 싸피를 이수하고 싶은 이유입니다.&lt;/dd&gt;
      &lt;dd&gt;
        &lt;p&gt;저는 학부시절 협업의 기회를 날렸습니다. sns를 통한 주먹구구식의 개발을 진행 하였습니다. 
저는 싸피를 통해서 협업의 기회, 동료를 얻고 싶습니다. 
피드백을 주고 받는 동료!! 이러한 IT문화를 경험함으로서 저의 개발ㅁ역량을 늘리고 싶습니다. 
이러한 이유로 싸피는 전공자인 제가 놓쳤던 기회를 다시 잡는 시간이라고 생각하며 싸피 지원한 이유입니다.&lt;/p&gt;
      &lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;취업해서 배우는게 더 나은거 아니야 ?
협업을 경험하고 싶습니다. 커뮤니트를 통해서도 구하였지만, 결속력이 많이 부족하였습니다. 그래서 싸피를 통해 동료를 얻고 싶습니다. &lt;br /&gt;
알고리즘,협업의 중요성이 강조되고 있습니다. 저는 이러한 부분이 약하고 더욱 학습하고 싶습니다. 그렇기에 싸피를 통해서 더 배우고 싶습니다. 실무수준의 협업을 배우고 싶습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;자신만의 경쟁력&lt;/dt&gt;
      &lt;dd&gt;도전의식이 저의 경쟁력이라고 생각합니다. 안될걸 아는데 도전합니다. 한번에 안되겠지만 여러번 도전하다보면 언젠간 될거라는 믿음이 있습니다. 이러한 마인드가 저의 경쟁력이라고 생각합니다. 
이는 꾸준함이 될수도 있겠고, 논리적인 사고능력이 될수도 있으리라 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;인상깊게 들은 과목&lt;/dt&gt;
      &lt;dd&gt;운영체제가 인상 깊었습니다. 컴퓨터가 동작하는 과정을 학습하기 때문이고 cli를 직접적으로 사용하기 때문에 당시에 인상깊었습니다. 
현재 인상깊은 과목을 선택하여도 역시 운영체제입니다. 운영체제에서 학습한 스케줄링, 운영체제 구성 내용등이 결국 응용소프트웨어에서도 사용되기 때문입니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;좋아하는 일과 잘하는 일중 선택해야한다면 무엇을?&lt;/dt&gt;
      &lt;dd&gt;잘하는일 선택해야합니다. 회사의 이익이든 본인의 이익이든 일을 통해 생산적인 결과물을 나타내야 하기 때문입니다. 좋아하는 일이라는 것은 저의 이익으로 대변되는 부분이고 이것은 개인시간을 이용해서 활용해야 한다고 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;대인관계에 관한 질문&lt;/dt&gt;
      &lt;dd&gt;저의 좋은게 좋은거다 라는 마인드로 대인관계를 유지합니다. 그리고 경청의 중요성을 알고있습니다. 하지만 프로젝트등의 목적이 분명한 경우 명확한 요구를 요하는 스타일 입니다. &lt;br /&gt;
질문을 할때에 상대의 시간을 위해 스스로 최대한 알아보고 이러한 시도를 했다고 알린 뒤 질문을 하곤 합니다. 
대인관계가 나빠지면 이는 상대와 본인 둘 다 문제가 존재한다고 생각합니다. 본인의 잘못을 인지하는 과정이 필요하며 이를 상대방과 공유할수 있어야 할 것으로 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;창의력을 발휘한 경험은 ?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;지원자는 리더형인가 팔로워형인가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;구독경제가 빅데이터에 미치는 영향&lt;/dt&gt;
      &lt;dd&gt;구독경제 즉 달마다 새로운 데이터가 생겨나고 이를 기반으로 미래 정책을 측정합니다. 그렇기 때문에 구독경제는 빅데이터의 시작점이라고 볼수있습니다. 또한 기업들이 구독경제를 모두 따라가는 경항은 이러한 구독 시스템, 무엇을 클릭했는지에 대한 시스템등 인터넷에서 수행하는 모든정보가 빅데이터를 구성하기 때문입니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;어떠한 개발자가 되고 싶나요&lt;/li&gt;
  &lt;li&gt;자소서 기반으로 어떻게 진행되었는지&lt;/li&gt;
  &lt;li&gt;알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;피티 면접 &lt;br /&gt;
AI, 빅데이터(4차산업혁명) 를 적용해서 어떻게 응용을 할수있겠는가?&lt;/p&gt;

&lt;p&gt;같은 프로세스 다른 디비
상품목록을 레디스와같은 저장소에 캐싱하고  쿼리 모델을 레디스를 사용하는 방식이죠
명령이 데이터를 변경하면 변경내역을 쿼리쪽 디비에 전달하게 됩니다.&lt;/p&gt;

&lt;p&gt;다른 다른
명령이 데이터에 변경하면 이 내역을 쿼리쪽에 전달해야합니다. 
MSA에서 사용하는 방식입니다.&lt;/p&gt;

&lt;p&gt;전달방법
1 명령이 직접 쿼리디비를 수정하는 방식이에요.
  카프카 같은 메시징을 이용해서 전달하는 방법도 있습니다. 
  이방법은 데이터 유실 가능성이 존재합니다. 
  문제가 발생하게되면 쿼리디비에 반영해야할 데이터가 유실될수있다.
  쿼리디비나 메세징의 문제때문에 명령을 수행하는것 자체가 에러가 날수있다.&lt;/p&gt;

&lt;p&gt;2 두번째는 명령디비에 기록하고 별도의 전파기를 통해서 쿼리디비에 전달하는 방식이에요
  일단 명령을 상태를 변경한 다음에 뭘 바꿨는지 별도의 테이블에 기록을 합니다. 이과정은 한 트랜잭션으로 처리되기 떄문에 데이터가 유실되지 않는 장점이 있다. 
  이때 전파기를 따로 구현해야하는 단점이 존재하다.&lt;/p&gt;

&lt;p&gt;3 디비가 제공하는 CDC를 사용하는 방법입니다. 
  예를 들면 디비의 바이너리 로그를 읽어서 변경데이터를 확인하고 이를 쿼리쪽에 전달하는 방식이다. 
  명령쪽 코드에서 변경내역을 따로 저장하지 않아도 되니깐 명령코드가 단순해지는 장점이 존재합니다.&lt;/p&gt;

&lt;p&gt;주의할점
  데이터 유실 : 유실 허용여부에 따라 DB트랜잭션 범위가 중요
  허용가능 지연 시간 : 명령의 반영내역을 얼마나 빨리 반영해야하는가 등의 허용가능한 지연시간이 존재하고 이를 고려해야한다.
  중복전달 : 유실을 고려해서 다시전달 할 수 있는 방법을 만들게 되면 쿼리쪽에 이미 반영된 데이터를 중복으로 전달한 경우도 발생하게 될것이다. 이때 쿼리쪽 데이터가 망가지지 않도록 별도의 처리를 해야합니다.&lt;/p&gt;

&lt;p&gt;이외에도 다른 주의사항도 존재합니다.&lt;/p&gt;

&lt;p&gt;정리 cqrs는 명령 역할을 수행하는 구성요소와 쿼리 역할을 수행하는 구성요소를 나누는것을 cqrs라고 함
왜하냐?
     1 명령과 쿼리는 다루는 데이터가 다름 
     2 명령과 쿼리는 코드 변경 빈도/사용자가 다름
     3 기능 마다 성능 요구가 다름&lt;/p&gt;

&lt;h2 id=&quot;카프카-분산-이벤트-스트리밍-플랫폼---하이포퍼먼스&quot;&gt;카프카 (분산 이벤트 스트리밍 플랫폼 - 하이포퍼먼스)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;카프카 클러스터 : 메시지를 저장하는 저장소이다. 하나의 카프카 클러스터는 여러개의 브로커로 구성된다.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;브로커는 각각의 서버라고 생각하면 된다.&lt;/li&gt;
      &lt;li&gt;브로커들이 메세지를 나눠서 처리하고 이중화도 하고, 장애 대체의 역할을 수행한다.
      - 주키퍼클러스터 (앙상블) : 카프카 클러스터를 관리한다. 주키퍼속에 카프카 클러스터의 정보과 관리된다. 
      - 프로듀서 : 카프카에 메세지를 넣는 역할을 한다. 
      - 컨슈머 : 메시지를 카프카에서 읽음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;토픽과 파티션
    &lt;ul&gt;
      &lt;li&gt;토픽 : 메시지를 구반하는 단위 ex) 뉴스용 토픽, 메일토픽 … 즉 파일시스템의 폴더와 유사&lt;/li&gt;
      &lt;li&gt;한 개의 토픽은 한개 이상의 파티션으로 구성&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;파티션은 메시지를 저장하는 물리적인 파일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;파티션 : 추가만 가능한 파일(append-only)
    &lt;ul&gt;
      &lt;li&gt;각 메시지 저장 위치를 오프셋 이라고 함&lt;/li&gt;
      &lt;li&gt;프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가&lt;/li&gt;
      &lt;li&gt;컨슈머는 오프셋 기준으로 메시지를 순서대로 읽음&lt;/li&gt;
      &lt;li&gt;메시지는 삭제되지 않음(설정에 따라 일정 시간이 지난뒤 삭제)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 파티션과 프로듀서&lt;/li&gt;
  &lt;li&gt;프로듀서는 라운드로빈 또는 키로 파티션 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;같은키를 갖는 메시지는 같은 파티션에 저장 -&amp;gt; 같은 키는 순서 유지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 파티션과 컨슈머
    &lt;ul&gt;
      &lt;li&gt;컨슈머는 컨슈머그룹에 속함&lt;/li&gt;
      &lt;li&gt;한개 파티션은 컨슈머그룹의 한 개 컨슈머만 연결가능
        &lt;ul&gt;
          &lt;li&gt;즉 컨슈머그훕에 속한 컨슈머들은 한 파티션을 공유할 수 없음&lt;/li&gt;
          &lt;li&gt;한 컨슈머그룹 기준으로 파티션의 메시지는 순서대로 처리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;파티션 파일은 os 페이지 캐시 사용&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;파티션에 대한 파일 IO를 메모리에서 처리&lt;/li&gt;
      &lt;li&gt;서버에서 페이지캐시를 카프카만 사용해야 성능에 유리
      - Zero Copy&lt;/li&gt;
      &lt;li&gt;디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
      - 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순&lt;/li&gt;
      &lt;li&gt;메시지 필터, 메시지 재전송과 같은 일은 브로커가 하지 않음
        &lt;ul&gt;
          &lt;li&gt;프로듀서,컨슈머가 직접 해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;브로커는 컨슈머와 파티션 간 매핑 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;묶어서 보내기, 묶어서 받기 (batch)
    &lt;ul&gt;
      &lt;li&gt;프로듀서 : 일정 크기만큼 메시지를 모아서 전송가능&lt;/li&gt;
      &lt;li&gt;컨슈머: 최소 크기만큼 메시지를 모아서 조회 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;낱개 처리보다 처리량 증가&lt;/li&gt;
  &lt;li&gt;처리량 증대(확장)가 쉬움
    &lt;ul&gt;
      &lt;li&gt;1개 장비의 용량 한계 -&amp;gt; 브로커 추카, 파티션 추카&lt;/li&gt;
      &lt;li&gt;컨슈머가 느림 -&amp;gt;컨슈머 추가(+파티션 추가)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리플리카 : 파티션의 복제본
    &lt;ul&gt;
      &lt;li&gt;복제수(replication factor) 만큼 파티션의 복제본이 각 브로커에 생김&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리더와 팔로워 구성
    &lt;ul&gt;
      &lt;li&gt;프로듀서와 컨슈머는 리더를 통해서만 메시지 처리&lt;/li&gt;
      &lt;li&gt;팔로워는 리더로부터 복제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장애 대응
    &lt;ul&gt;
      &lt;li&gt;리더가 속한 브로커 장애시 다른 팔로워가 리더가 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프로듀서
    &lt;ul&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;프로그래밍-초식&quot;&gt;프로그래밍 초식&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;변수아끼끼 : 의미를 더해주는 변수 위주로 사용하기 (식이 복잡하거나 길어지 ㄹ경우 변수 이름으로 설명)
    &lt;ul&gt;
      &lt;li&gt;가능한 선언과 값 할당을 한번에 하자&lt;/li&gt;
      &lt;li&gt;최대한(절대로) 변수의 용도/의미 변경 X : 의미나 용도가 다르면 다른 변수 사용할것 (이러면 개발자들이 코드를 이해가 어려워진다. )&lt;/li&gt;
      &lt;li&gt;변수가 사용되는 코드 범위를 최소화하기 ex) forloop만을 위한 코드를 작성하라
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; for(Some some : somes){
     String msg = some.getName() + ~~
 }

 =====================

 .... (코드 10줄)
 String msg = ...;
 return Result.message(msg);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - 변수를 아끼는 연습하기 
 - 중요한 코드의 복잡도를 낮추고 가독성을 높이는 쉬우 방법 -&amp;gt; 변수 아끼고 변경 줄이고 범위 좁히고 
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나누기
    &lt;ul&gt;
      &lt;li&gt;구현기술을 여러 기본기 하나이다.&lt;/li&gt;
      &lt;li&gt;초짜 특징 중 하나 : 점점 커지는 함수/메서드/클래스&lt;/li&gt;
      &lt;li&gt;너무 커지면 프로그램 분석이 어려워짐(수정이 어려워짐)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;흔한 예:
        &lt;ul&gt;
          &lt;li&gt;if-else, if 중첩이 복잡해짐&lt;/li&gt;
          &lt;li&gt;변수의 의미가 중간에 바뀜&lt;/li&gt;
          &lt;li&gt;코드 안에서 중복이 발생함
            &lt;ul&gt;
              &lt;li&gt;의미가 있는 단위로 코드/구성 요소를 나누는 기술 : 나누기&lt;/li&gt;
              &lt;li&gt;패턴은 전형적인 예&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;웹개발 : 컨트롤러 - 서비스 - DAO&lt;/li&gt;
      &lt;li&gt;DDD : 엔티티, 밸류, 리포지토리&lt;/li&gt;
      &lt;li&gt;디자인 패턴: 빌더, 어댑터, 컴포지트 등
      - 나누기는 곧 기능 분해/분리 : 기능은 여러 작은 기능/로직(하위 기능)으로 구성
      - 나눈 하위 기능을 메서드나 클래스로 분리 : 나누기의 결과
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; OrderRepository : DB에서 주문 데이터 읽기, DB에서 변경데이터 쓰기
 Order : 주문 취소 가능여부 확인, 주문데이터 변경
 OrderCancelService : 취소 처리 흐름제어 
 Notifier : 취소 결과 통지 
 PayCancelService : 결제 취소
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - 나누기는 역할/책임 도출 인것이다. 
  - 어떤 기준으로 나누나? : 정답은 없음 하지만 보통은 기능에서 의미가 있는 하위 기능 단위로 나누는 시도를 추천
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;주문취소 기능 : 취소의 입장에서 의미있는 단위
        &lt;ul&gt;
          &lt;li&gt;취소 사싱 통지 vs push 테이블에 insert&lt;/li&gt;
          &lt;li&gt;결제 승인 취소 vs pg사가 제공하는 API 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대칭성 활용의 측면
        &lt;ul&gt;
          &lt;li&gt;취소는 취소끼리 비슷한 기능끼리 나눈다. (코드간의 수준을 맞춘다.)
    - 나눈결과&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;나누기를 안하면
        &lt;ul&gt;
          &lt;li&gt;코드 순서대로 구현을 이해하는 것이 가능&lt;/li&gt;
          &lt;li&gt;근데 코드가 커질수록 코드가 복잡해져서 점점 이해하기 어려워짐&lt;/li&gt;
          &lt;li&gt;코드가 커질수록 변경도 어려워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;나누기를 잘하면
        &lt;ul&gt;
          &lt;li&gt;구조의 복잡도가 증가하지만 상위 수준에서 실행 흐름 이해하기 좋음&lt;/li&gt;
          &lt;li&gt;코드 변경이 (나누기 전보다 ) 쉬워질 가능성이 높아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;너무 잘게 나누면
        &lt;ul&gt;
          &lt;li&gt;너무 복잡해져서 실행 흐름을 이해하기 어려워짐&lt;/li&gt;
          &lt;li&gt;변경할 떄 수정 대상이 많아져 변경이 어려워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WHAT,HOW
    &lt;ul&gt;
      &lt;li&gt;하려는것/의미/의도(WHAT) - 그것의 실제 구현(HOW)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;what&lt;/th&gt;
          &lt;th&gt;how&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;가입한지 1년 미만&lt;/td&gt;
          &lt;td&gt;user 테이블에서 reg칼럼 값 기준으로 count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;추가 지급 내역 남김&lt;/td&gt;
          &lt;td&gt;log 테이블에 insert&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;의미가 들어나게 생각해보고 이를 코드로 만드는 연습을 해라 !&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int addPointRate = 0;
 if(userRegistedLessThanOneYear(userId)){
     addPointRate = 1;
 }
 ...
 if(addPointRate &amp;gt; 0){
     recordAddPointHistory(userId,addPointRate);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;what 최대한 드러나게 생각을 하자(슈도코드 등등) -&amp;gt; 그리고 실제로 코드상에서 어떻게 이를 적용할지 생각한다(의도가 드러나게 !)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;WHAT,HOW 분리 결과
    &lt;ul&gt;
      &lt;li&gt;구현을 잠시 잊고 실제 하려는 것이 무엇인지 생각하게 됨
        &lt;ul&gt;
          &lt;li&gt;실제 하려는 것이 코드에 표현될 가능성이 높아짐&lt;/li&gt;
          &lt;li&gt;코드의 가독성이 향상&lt;/li&gt;
          &lt;li&gt;유지보수성이 좋아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;물론 구현 제약등의 이유로 표현력이 떨어질 경우도 존재함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평소에 의식의 흐름대로 막 구현만 하면 안됨
    &lt;ul&gt;
      &lt;li&gt;의미/의도가 드러나는 코드를 작성하도록 노력해야함&lt;/li&gt;
      &lt;li&gt;연차가 쌓인다고 절로 늘지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분 우리나라에서 잘안쓰는 경우를 덜 유용하다고 느낄수있스니다. 지도나 애플페이를 쓸수있다고 한다라더 한국매출이 그렇게 작은 편이 아니에요 사파리 디자인이 많이 바꼈어요 왜 쓸만하지 잠깐만 나쁘지않아 이렇게 인터페이스가 바꼈어요 이걸 쑉하면 탭 그룹이 생겨서 묶어서 관리할수 아이플러스라는게 생겼어요 비공게&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;데이터웨어하우스 
====
&lt;strong&gt;정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비즈니스 범위를 넘은 데이터들의 집합으로 표현한다.&lt;/li&gt;
  &lt;li&gt;다수의 핵심적인 거래처리 시스템들로부터 현재 및 과거 데이터들을 저장함&lt;/li&gt;
  &lt;li&gt;전사적인 사용ㅇ을 위해 정보를 통합하고 표준화하지만 변경은 할수없음&lt;/li&gt;
  &lt;li&gt;분석 및 리포팅을 목적으로 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주제지향성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DB : 업무기능 중심&lt;/li&gt;
  &lt;li&gt;DW : 특정주제에 따른 분류&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터의 통합성 : 여러DB의 다양한 포맷을 공통된 처리화를 진행하여 DW에 저장한다.&lt;/li&gt;
  &lt;li&gt;데이터의 시계열성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터의 비휘발성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ETT(추출,변형,전송) : 데이터웨어하우스를 구축하고 활용해나가는 일련의과정을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;데이터 마트&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;편리한 데이터웨어하우스 구성을 위해 데이터마트 구성&lt;/li&gt;
  &lt;li&gt;데이터웨어하우스의 일부분&lt;/li&gt;
  &lt;li&gt;특정 사용자 집단이 사용할 수 있도록 특정 초점을 가지고 요약된 조직 데이터의 일부분&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초점은 일잔적으로 단일주제 영역이나 업무 영역에 맞춤&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터마트와 데이터웨어하우스 차이
    &lt;ul&gt;
      &lt;li&gt;데이터의 용령과 사용자 규모에서 차이가 있을 뿐 ETT도구, 운영 데이터베이스 및 DBMS, 분석도구등의 기본 구성요소는 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CRM&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DB,DW를 기반으로 분석하는 시스템을 CRM이라고 한다.&lt;/li&gt;
  &lt;li&gt;운영, 분석이 진행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;디비와 웹&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 어플리케이션 목적 : 인터넷을 이용해서 외부접근하는것이다.&lt;/li&gt;
  &lt;li&gt;예전에는 C/S프로그램이었다. 직접설치하고 내부 네트웍을 구성하는 방법이었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;빅데이터 처리 프로세스
====&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;빅데이터 소스&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부 데이터 소스
    &lt;ul&gt;
      &lt;li&gt;데이터베이스&lt;/li&gt;
      &lt;li&gt;데이터웨어하우스&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;입력형식이 정해져 있는 정형화된 데이터&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;고정된 필등 의해 저장되는 데이터&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;외부데이터 소스
    &lt;ul&gt;
      &lt;li&gt;(open,여러) API&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 형식
    &lt;ul&gt;
      &lt;li&gt;비정형 데이터(텍스트 마이닝 사용)
        &lt;ul&gt;
          &lt;li&gt;웹페이지&lt;/li&gt;
          &lt;li&gt;SNS&lt;/li&gt;
          &lt;li&gt;로그 데이터&lt;/li&gt;
          &lt;li&gt;센서 데이터&lt;/li&gt;
          &lt;li&gt;음성 데이터&lt;/li&gt;
          &lt;li&gt;이미지 데이터 (CNN)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;빅데이터 수집&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스쿱
    &lt;ul&gt;
      &lt;li&gt;기존의 데이터베이스의 내용을 가져와 이를 하둡같은 분산디비에 데이터 수집함&lt;/li&gt;
      &lt;li&gt;아파치 하둡 기반 프로젝트인 Hive,Pig,Hbase 등과도 호환이 잘되어 RDBMS, NoSQL간의 데이터 연동에 많이 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플럼 (flume)
    &lt;ul&gt;
      &lt;li&gt;이벤트 로그 데이터를 효율적으로 수집 할 수 있는 로그 수집기&lt;/li&gt;
      &lt;li&gt;여러 서버네서 생산된 대용량 로그 데이터를 효과적으로 수집하여, HDFS과 같은 원격 목적지에 데이터를 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아파치 스톰
    &lt;ul&gt;
      &lt;li&gt;실시간 데이터 처리를 위한 시스템&lt;/li&gt;
      &lt;li&gt;시간이 지나감에 따라서 끊임 없이 데이터들을 생성&lt;/li&gt;
      &lt;li&gt;트위터 스트림을 이용한 소셜 마케팅 반응 분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;크롤링&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;빅데이터 처리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;배치 &amp;amp; 일괄배치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;맵리듀스&lt;/li&gt;
  &lt;li&gt;빅쿼리(BigQuery)&lt;/li&gt;
  &lt;li&gt;presto&lt;/li&gt;
  &lt;li&gt;pig&lt;/li&gt;
  &lt;li&gt;hive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;빅데이터 분석&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;BA
    &lt;ul&gt;
      &lt;li&gt;데이터를 분석하는 도구들과 기법&lt;/li&gt;
      &lt;li&gt;수리적 모델, 통계기법, 데이터마이닝, 기계학습, 딥러닝&lt;/li&gt;
      &lt;li&gt;의사결정에 필요한 정량적인 데이터를 산출하는 업무, 기술&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BI
    &lt;ul&gt;
      &lt;li&gt;비즈니스에서 발생한 데이터를 수집하고, 저장하고, 분석하는 인프라&lt;/li&gt;
      &lt;li&gt;데이터베이스, 데이터 웨어하우스, 데이터 마트, 하둡, 분석 플랫폼&lt;/li&gt;
      &lt;li&gt;온라인분석처리(OLAP), 과거 상황과 현재상황을 이해하기 위한 데이터 시각화 및 리포팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;ba---bi로-현재-진행중이다&quot;&gt;BA -&amp;gt; BI로 현재 진행중이다.&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;빅데이터 저장과 처리 
====&lt;/p&gt;

&lt;p&gt;대용량 데이터를 분산 처리할 수 있는 자바 기반의 오픈소스 프레임 워크&lt;/p&gt;

&lt;p&gt;하둡 : 맵리듀스,yarn을 가지고 있는 분산된 파일시스템에다 여러가지 기능을 붙인 오픈소스이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DBMS가 아님 -&amp;gt; 프레임 워크&lt;/li&gt;
  &lt;li&gt;하둡은 분산시스템인 HDFS에 데이터를 저장하고, 맵리듀스를 이용해 데이터를 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;분산저장(HDFS - Hadoop Distributed File System) : 빅데이터 파일을 여러 대의 서버에 분산 저장하기 위한 파일 시스템&lt;/p&gt;

&lt;p&gt;분산처리(MapReduce) : 각 서버에서 데이터를 분산처리하는 분산 병렬처리를 위한 분석 시스템&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;배경&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;웹 크롤러 색인 처리 과정에세 생성되는 큰 파일 처리 한계&lt;/li&gt;
  &lt;li&gt;DBMS의 한계를 보여줌&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;크롤러와 검색 엔진 시스템 성능 향상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구글에서 먼저 GFS가 출시됨 (구글 분산 파일 시스템의 논문). 기를 기반으로 하둡이 오픈소스로 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;분산&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스케일 업 : 컴퓨터의 자원을 업그레이드 하는 방법 ( 수직적 확장)&lt;/li&gt;
  &lt;li&gt;스케일 아웃 : 컴퓨터의 수평적인 확장이 일어남 같은 성능의 여러대의 컴퓨터를 구성 ( 클러스터링 된 컴퓨터 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구글 파일 시스템은 클러스터링이 존재라고 마스터와 여러개의 슬레이브가 존재합니다.&lt;/p&gt;

&lt;p&gt;마스터(job tracker) 슬레이브 구조에서 TaskTracker를 수행하는 구조가 맵리듀스기 존재하고&lt;br /&gt;
  마스터(name Node) 슬레이브 구조에서 DataNode 를 수행하는  HDFS가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;데이터를 64mb 블록 단위로 데이터 관리하고 이를 slave(node)에 나눠서 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;마스터 nameNode : 데이터의 메타데이터(전체구조) 관리
    &lt;ul&gt;
      &lt;li&gt;데이터 노드 모니터링 : 3초마다 하트비트를(생존하고 있음을) 전송&lt;/li&gt;
      &lt;li&gt;블록관리 : 장애가 발생한 데이터노드의 블록을 새로운 데이터노드에 복제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 노드
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 HDFS에 저장하는 파일을 로컬 디스크에 유지&lt;/li&gt;
      &lt;li&gt;실제 저장되는 데이터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대용량 데이터 처리를 위한 분산 프로그래밍 모델&lt;/li&gt;
  &lt;li&gt;분산 처리 기술과 관련 프레임워크를 의미&lt;/li&gt;
  &lt;li&gt;Data : 분산DB에 저장됨&lt;/li&gt;
  &lt;li&gt;처리 : 통합처리 vs 분산처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;나눠서 저장하고 한군데에서 처리하면 분산의 의미가 없다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 나눠진 저장소에서 처리까지 하는게 맵리듀스이다.&lt;/p&gt;

&lt;p&gt;분석한 결과를 취합하여 처리하는 방법이다.&lt;/p&gt;

&lt;p&gt;MapReduce : map + reduce&lt;/p&gt;

&lt;p&gt;Map : 각각에 분산된 컴퓨터에서 처리해주는 것
      흩어져 있는 데이터를 key,value의 형태로 연관성 있는 데이터 분류로 묶는 작업&lt;/p&gt;

&lt;p&gt;reduce : map에서 나온 output을 통합해주는 과정 reduce라고 합니다. 
      통합해주는 과정이 줄이는 과정이라고 보는것이다. ! &lt;br /&gt;
      filtering과 sorting을 거쳐 데이터를 추출, map화 한 작업 중 중복 데이터를 제거 하고 원하는 데이터를 추출하는 작업&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하둡 에코 시스템&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빅데이터 수집
    &lt;ul&gt;
      &lt;li&gt;플럼 : 비정형 데이터 수집&lt;/li&gt;
      &lt;li&gt;스쿱 : 관계형 DB로부터 데이터 가져오기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빅데이터 저장, 활용
    &lt;ul&gt;
      &lt;li&gt;hbase : 컬럼 기반 NoSQL 데이터베이스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빅데이터 처리
    &lt;ul&gt;
      &lt;li&gt;하이브 : 유사 SQL 기반 빅데이터 처리&lt;/li&gt;
      &lt;li&gt;피그 : 스크립트 언어 기반 빅데이터 처리&lt;/li&gt;
      &lt;li&gt;마후트 : 기계학습 알고리즘 기반 빅데이터 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빅데이터 관리
    &lt;ul&gt;
      &lt;li&gt;우지 : 빅데이터 처리 과정 관리&lt;/li&gt;
      &lt;li&gt;h카탈로그 : 빅데이터 메타 정보 관리&lt;/li&gt;
      &lt;li&gt;주키퍼 : 빅데이터 서버 시스템 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하둡기반으로 데이터 저장이 되고 이를 빅데이터처리 과정을 거친다. 하이브,피그,마후트 등등으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NoSQL&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비 관계형 데이터 베이스&lt;/li&gt;
  &lt;li&gt;schema-free : 보다 유연한 데이터 모델 &amp;lt;-&amp;gt; 정형화된 틀(schma) ex)주민번호,학번,성별 등 형식&lt;/li&gt;
  &lt;li&gt;분산 다수의 하드웨어 걸쳐 저장된 데이터&lt;/li&gt;
  &lt;li&gt;용이한 데이터 규모 확장성&lt;/li&gt;
  &lt;li&gt;대용량의 구조적, 반구조적 데이터들을 다룸 (웹, 소셜 미디어, 그래픽)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NoSQL의 분류&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;키밸류&lt;/li&gt;
  &lt;li&gt;컬럼 베이스&lt;/li&gt;
  &lt;li&gt;도큐먼스 베이스&lt;/li&gt;
  &lt;li&gt;그래프 베이스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;아파치 스파크&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;하둡시스템을 인메모리로 사용한다는 것&lt;/li&gt;
  &lt;li&gt;in-memory 기반 분산 고성능 클러스터 플랫폼&lt;/li&gt;
  &lt;li&gt;기존 하둡의 mapreduce 작업을 디스크 기반이 아닌 메모리 기반으로 옮겨 고속화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;인공지능 간단 설명
====&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인공지능 : 인간 대신 계산,인지,예측해주는 방법론&lt;/li&gt;
  &lt;li&gt;머신러닝 : 인공지능의 한 분야로 인지,예측을 위한 다양한 알고리즘으로 연구됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;머신러닝에는 인지,진단,패턴등을 분석하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;inverse problom&lt;/code&gt; 이 존재하고 제어,정책 학습 , 예측 등의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Optimal control problem&lt;/code&gt;이 존재합니다.&lt;/p&gt;

&lt;p&gt;그리고 미래의 개념인 뇌기반 인공지능(진짜 지능 - 분위기, 상황을 인지하고 스스로 판단하는) 미래 기술이다.&lt;/p&gt;

&lt;h2 id=&quot;inverse-problem&quot;&gt;Inverse problem&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;지도학습 : 인버전의 문제이다.&lt;/li&gt;
  &lt;li&gt;비지도학습 : 비 지도 학습은 A의 값이 존재하지 않고 X의 값을 군집화하는 솔류션이다.
    &lt;ul&gt;
      &lt;li&gt;이를 통해서 y={X}에 의해서 값들의 분류를 설정할수있다. 라벨링 ~~&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터는 원인이 있어서 결과가 나온다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관측가능한 데이터로 부터 원래 무엇이었는지 알아내는게 inverseProblem이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;간단하게 말하면 블랙박스(함수) 이다. y = ax&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문제를 풀기위해 수학적인 기법이 사용되었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;즉 계산이다. 계산과정이 복잡하면 문제는 계산이 오래걸렸고 계산하기 힘들었다.&lt;/li&gt;
  &lt;li&gt;그래서 이를 근사화 하기 시작하였고 신경망 같은 기법이 사용되었다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;신경망 이론은 함수 근사화 기법이다. 이는 원래 계산신경과학 분야에서 먼저 발전 하였습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;관측 가능한 데이터에서 불확실성이 존재할수있고 확률모델로 신경망을 구성하기도 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CNN은 입력에 특정 패턴을 알아내는 출력이고 신경망이 사용되었다고 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;텍스트 사이의 상관관계를 잘 추려 압축을 하고 추출된 키워드에서 토픽을 꺼냅니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 압축 방법은 이미지에서도 압축하여 노이지를 제거 할수있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이를 이용해서 멀티 모달로 인풋 포맷을 여러개로 가져갈수있습니다. specific하게 말이죠&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CNN&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일반적인 신경망은 백터내적을 통해서 비선형 함수를 통과시키는게 대표적이다.&lt;/li&gt;
  &lt;li&gt;하지만 씨엔엔는 필터링을 통한 컨볼류션한 오퍼레이션이 들어가고 비선형 함수를 통과한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 풀링이 존재한다. 풀링(max)은 특정 패턴의 존재여부를 체크한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;정밀하게 물체는 잡아내는것은 convolutions이 하고 있다고 말할수있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;노이즈에 흔들리지 않게 인식할 수 있도록 도움을 주는 부분은 풀링이라고 말할수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이를 하나의 블럭으로 쌓고 조합을 하면 복잡한 패턴을 발견할수있고 이를 통해서 이미지 인식이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AI의 이해&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;딥러닝 또는 학습과정을 사람이 이해하고 싶다.&lt;/li&gt;
  &lt;li&gt;어떻게 인지하는지 이를 시각화 하는 과정이 최근 화두였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;GAN&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최근 딥러닝 영역의 화두이다.&lt;/li&gt;
  &lt;li&gt;오버핏팅의 문제가 발생할때 &amp;lt;- (약간의 노이즈, 다른문제(다른데이터) 등을 추가하면 인식을 못하는 경우가 발생) 이를 해결하기 위한 방법으로 GAN이란 아이디어가 나옴&lt;/li&gt;
  &lt;li&gt;GAN은 딥러닝 알고리즘끼리 서로 경쟁을 하여 서로 성능을 이끌어내는 학습방법을 말함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;optimal-control-problem&quot;&gt;Optimal Control problem&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;알파고를 상상하면 됩니다.&lt;/li&gt;
  &lt;li&gt;무엇가를 읽어내는것이 아니라 내가 원하는 반응을 이끌어내는 경우를 말한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내 상대방의 환경이나 시스템( 타겟을) 원하는 상태로 이끌어내는 정책을 찾는것을 의미합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;내가 과거에 했던 어떤 행동조합(원하는 상태로 이끄는것)으로 잘했는지 시간을 거슬러 올라가며 정보를 업데이트를 해야합니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러가지 제어기법중 하나로 강화학습으로 수렴이 되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 베드는 게임이다. 어떤 행동조합을 해야 승리를 할수있는지 결정하는 것이다. (시간을 거꾸러 전파하면서)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모델프리-컨트롤-모델-베이스-컨트롤&quot;&gt;모델프리 컨트롤 &amp;amp;모델 베이스 컨트롤&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;모델프리 컨트롤
    &lt;ul&gt;
      &lt;li&gt;주어진 상황에서 그다음에 무엇을 할지 결정하는 정책&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델베이스 컨트롤
    &lt;ul&gt;
      &lt;li&gt;주어진 상황에서 상대방이 어떻게 할것인지 예측하고 배워나가는 정책&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델베이스 컨트롤을 계층화하는 연구도 진행되고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;차세대-ai&quot;&gt;차세대 ai&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;학습한 분야(특정분야)는 사람보다 더 잘하지만 사람이 더잘하는 게임(정책)이 많다.
    &lt;ul&gt;
      &lt;li&gt;이러한 이유는 사람은 이전의 지식(학습한지식)을 활용하여 현재 사용하기 때문으로 볼수있다.&lt;/li&gt;
      &lt;li&gt;이러한 ai의 문제점을 해결하기위한 연구가 진행중이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사람, 사물에 대한 (융통성있는) 플렉서블한 목표를 설정할수없다.
    &lt;ul&gt;
      &lt;li&gt;목적이 조금만 벗어나면 해결할수없는 문제가 되어버린다.&lt;/li&gt;
      &lt;li&gt;하지만 사람은 그렇지 않다.&lt;/li&gt;
      &lt;li&gt;이를 해결해려면 목적을 다시설정하고 다시 학습시키고 처음부터 다시해야한다.&lt;/li&gt;
      &lt;li&gt;이러한 지능은 아직 할수없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재 기업및 국가는 DT(digitalTransfomation)을 추구하고 있습니다. 이는 무엇일까요?&lt;/p&gt;

&lt;p&gt;인간의 사용자경험 즉 UX를 고려한 온오프라인의 디지털화 라고 말하고 싶습니다.&lt;/p&gt;

&lt;p&gt;온라인에서는 비대면, 가상 플랫폼을 생성하고 이를 UI 기반 UX로 소통의 장을 만드려고 디지털화 하는중입니다.&lt;/p&gt;

&lt;p&gt;오프라인에서는 우리가 손으로 집적하는 모든행위를 기계가 스스로 하게끔 디지털전환중입니다.&lt;/p&gt;

&lt;p&gt;온오프라인에서 디지털화가 진행중이고 이는 인터넷 급의 변화를 또는 그보다 더 파격적인 변화를 예상 하고 있습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 DT을 위해서 개발자인 내가 준비할 해야할 영역은 무엇일까요&lt;/p&gt;

&lt;p&gt;DNA라고 불리는 영역입니다.&lt;/p&gt;

&lt;p&gt;DT가 진행된 intelligent society에서 초연결이 진행될것입니다.&lt;/p&gt;

&lt;p&gt;이는 빅데이터 처리, 빅데이터 분석 필요할것이고 빠른변화 수용을 위한 협업능력이 필요할것입니다.&lt;/p&gt;

&lt;p&gt;클라우드로 전환하는 이유&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;온프레미스에서 클라우드 전환시 운영 비용감소&lt;/li&gt;
  &lt;li&gt;확장을 위한 비즈니스 어질리티 (대응략)
    &lt;ul&gt;
      &lt;li&gt;서버 구매에 대한 빠른 대응&lt;/li&gt;
      &lt;li&gt;트래픽증가에 대한 빠른 대응&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;빅데이터의 문제점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 정리가 너무 오래걸립니다.&lt;/li&gt;
  &lt;li&gt;지속적인 품질이 유지되지 않습니다.&lt;/li&gt;
  &lt;li&gt;누구나 빅데이터 분석을 할수있었으면 좋겠다.&lt;/li&gt;
  &lt;li&gt;보안문제 ? 프라이빗 클라우드&lt;/li&gt;
  &lt;li&gt;데이터 마이그레이션 문제 ? 어떻게 진행될것인가. ?&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 07 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/06/07/interview-question/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/06/07/interview-question/</guid>
        
        <category>interview</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>mysql on Docker with centos - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;mySQL on Docker&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;proxylayer&quot;&gt;proxyLayer&lt;/h2&gt;

&lt;p&gt;구성한 master/slave 구조에서 마스터에 문제 발생시 오케스트라를 이용해서 slave1을 마스터로 올리고 하위 slave를 새로운 마스터에 붙일수있다.&lt;/p&gt;

&lt;p&gt;오케스트라를 통해서 자동으로 failOver가 발생하고 이를 처리한다.&lt;/p&gt;

&lt;p&gt;하지만 오케스트라에서 failover가 진행되지만 클라이언트의 request를 자동으로 처리하지는 않는다.&lt;/p&gt;

&lt;p&gt;그렇다면 문제 발생시에 오케스트라에서 failover를 처리해주지만 클라이언트 단의 request를 새로운 마스터로 자동으로 처리해주는 것은 무엇이 있을까??&lt;/p&gt;

&lt;p&gt;이는 바로 proxyLayer 구성하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/proxysql/data /db/proxysql/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/proxysql /db/proxysql/data /db/proxysql/conf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;권한설정 및 필요한 디렉터리를 만든다. &lt;br /&gt;
  proxysql/conf로 이동하여서 proxysql.conf를 생성한다.&lt;/p&gt;

&lt;p&gt;proxysql.cnf 파일 설정&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    datadir=&quot;/var/lib/proxysql&quot;
    admin_variables=
    {
    admin_credentials=&quot;admin:admin;radmin:radmin&quot;
    mysql_ifaces=&quot;0.0.0.0:6032&quot;
    }
    mysql_variables=
    {
    threads=4
    max_connections=2048
    default_query_delay=0
    default_query_timeout=36000000
    have_compress=true
    poll_timeout=2000
    interfaces=&quot;0.0.0.0:6033&quot;
    default_schema=&quot;information_schema&quot;
    stacksize=1048576
    server_version=&quot;5.5.30&quot;
    connect_timeout_server=3000

    ^G Get He^O WriteO^R Read F^Y Prev P^K Cut Te^C Cur Pos
    GNU nano 2.0.6     File: proxysql.cnf

    connect_timeout_server=3000
    monitor_username=&quot;monitor&quot;
    monitor_password=&quot;monitor&quot;
    monitor_history=600000
    monitor_connect_interval=60000
    monitor_ping_interval=10000
    monitor_read_only_interval=1500
    monitor_read_only_timeout=500
    ping_interval_server_msec=120000
    ping_timeout_server=500
    commands_stats=true
    sessions_sort=true
    connect_retries_on_failure=10
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;docker container생성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name proxysql -h proxysql –net mybridge –net-alias=proxysql -p 16032:6032 -p 16033:6033 -v /db/proxysql/data:/var/lib/proxysql -v /db/proxysql/conf/proxysql.cnf:/etc/proxysql.cnf -d proxysql/proxysql&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql -h127.0.0.1 -P16032 -uradmin -pradmin –prompt “ProxySQL admin” : 로그인 하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proxysql-test&quot;&gt;proxysql test&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;db0001에 테스트용 디비를 생성한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create database testdb default character set utf8;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;어플리케이션에서 사용할 유저를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create user appuser@’%’ identified by ‘apppass’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;testdb에 읽고 쓸 수 있도록 권한을 준다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grant select, insert, update, delete on testdb.* to appuser@’%’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;프록시 시퀄에서 사용할 유저를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create user  ‘monitor’@’%’ identified by ‘monitor’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;프록시 시퀄에서 사용할 권한을 준다.&lt;/li&gt;
  &lt;li&gt;grant REplication client on &lt;em&gt;.&lt;/em&gt; to ‘monitor’@’%’;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flush privileges;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;proxysql서버에 로그인하여 각각의 replication을 등록해준다.&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(10,’db001’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db001’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db002’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db003’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_replication_hostgroups values(10,20,’read_only’,’’);&lt;/li&gt;
  &lt;li&gt;load mysql servers to runtime;&lt;/li&gt;
  &lt;li&gt;save mysql servers to disk;&lt;/li&gt;
  &lt;li&gt;insert into mysql_users(username,password,default_hostgroup,transaction_persistent) values (‘appuser’,’apppass’,10,0);&lt;/li&gt;
  &lt;li&gt;LOAD MYSQL USERS TO RUNTIME;&lt;/li&gt;
  &lt;li&gt;SAVE MYSQL USERS TO DISK;&lt;/li&gt;
  &lt;li&gt;insert into mysql_query_rules(rule_id,active,match_pattern,destination_hostgroup) values (1,1,’^SELECT.*FOR UPDATE$’,10);&lt;/li&gt;
  &lt;li&gt;insert into mysql_query_rules(rule_id,active,match_pattern,destination_hostgroup) values (2,1,’^SELECT’,20);&lt;/li&gt;
  &lt;li&gt;load mysql QUERY RULES to runtime;&lt;/li&gt;
  &lt;li&gt;save mysql QUERY RULES to disk;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;insert test&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker exec -it -uroot db001 /bin/bash&lt;/li&gt;
  &lt;li&gt;use testdb;&lt;/li&gt;
  &lt;li&gt;create table insert_test(hostname varchar(5) not null, insert_time datetime not null);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;insert test shall&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;do

    &lt;/span&gt;mysql -uappuser -papppass -h172.31.10.19 -P16033 -N -e &lt;span class=&quot;s2&quot;&gt;&quot;insert into testdb.insert_test select @@hostname,now()&quot;&lt;/span&gt; 2&amp;gt;&amp;amp;1| grep -v &lt;span class=&quot;s2&quot;&gt;&quot;Warning&quot;&lt;/span&gt;

    sleep 1

    &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;truncate table testdb.insert_test;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모니터링-mysql&quot;&gt;모니터링 (mysql)&lt;/h2&gt;

&lt;p&gt;prometheus통해서 모니터링을 진행하고  grafana를 통해서 대시보드로 시각화 한다.&lt;/p&gt;

&lt;p&gt;prometheus로 모니터링 항목 수집을 위해 exporter가 존재해야한다.&lt;/p&gt;

&lt;p&gt;prometheus가 풀형태로 진행한다.&lt;/p&gt;

&lt;p&gt;exporter를 어떻게 만들어야할까요? 도커이미지를 직접 만들거나 또는 만들어진 도커 파일을 찾아야한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;도커 이미지를 직접 만들것입니다. &lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Dokerfile
    Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm
    mysqld_exporter-0.12.1.linux-amd64.tar.gz
    node_exporter-1.0.1.linux-amd64.tar.gz
    ps-entry.sh
    start_mysqld_exporter.sh
    start_node_exporter.sh
    ```   
    파일이 하나의 폴더에 필요하다.   
    docker build -t mysql57:0.0 ./ : 명령어를 통해서 도커이미지를 만들수있다. 



    ```
    FROM centos:7
    COPY [&quot;Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm&quot;,\
        &quot;Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;node_exporter-1.0.1.linux-amd64.tar.gz&quot;, \
        &quot;mysqld_exporter-0.12.1.linux-amd64.tar.gz&quot;, \
        &quot;start_node_exporter.sh&quot;, \
        &quot;start_mysqld_exporter.sh&quot;, \
        &quot;.my.cnf&quot;,&quot;/tmp/&quot;]
    USER root
    RUN groupadd -g 1001 mysql
    RUN useradd -u 1001 -r -g 1001 mysql
    RUN yum install -y perl.x86_64 \
        libaio.x86_64 \
        numactl-libs.x86_64 \
        net-tools.x86_64 \
        sudo.x86_64 \
        openssl.x86_64
    WORKDIR /tmp/
    RUN rpm -ivh Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm
    RUN mkdir -p /opt/exporters/ &amp;amp;&amp;amp; \
        tar -xzvf ./node_exporter-1.0.1.linux-amd64.tar.gz -C /opt/exporters &amp;amp;&amp;amp; \
        tar -xzvf ./mysqld_exporter-0.12.1.linux-amd64.tar.gz -C /opt/exporters
    WORKDIR /opt/exporters/
    RUN mv node_exporter-1.0.1.linux-amd64 node_exporter &amp;amp;&amp;amp; \
        mv mysqld_exporter-0.12.1.linux-amd64 mysqld_exporter &amp;amp;&amp;amp; \
        mv /tmp/start_node_exporter.sh /opt/exporters/node_exporter/ &amp;amp;&amp;amp; \
        mv /tmp/start_mysqld_exporter.sh /opt/exporters/mysqld_exporter/ &amp;amp;&amp;amp; \
        mv /tmp/.my.cnf /opt/exporters/mysqld_exporter/ &amp;amp;&amp;amp; \
        chmod o+x /opt/exporters/node_exporter/start_node_exporter.sh &amp;amp;&amp;amp; \
        chmod o+x /opt/exporters/mysqld_exporter/start_mysqld_exporter.sh &amp;amp;&amp;amp; \
        rm -rf /tmp/*.rpm &amp;amp;&amp;amp; \
        /usr/bin/install -m 0775 -o mysql -g mysql -d /var/lib/mysql \
        /var/run/mysqld /docker-entrypoint-initdb.d
    VOLUME [&quot;/var/lib/mysql&quot;, &quot;/var/log/mysql&quot;,&quot;/etc/percona-server.conf.d&quot;]
    COPY ps-entry.sh /tmp/docker-entrypoint.sh
    RUN chmod +x /tmp/docker-entrypoint.sh
    ENTRYPOINT [&quot;/tmp/docker-entrypoint.sh&quot;]
    USER mysql
    EXPOSE 3306
    CMD [&quot;mysqld&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;도커파일은 다음과 같이 구성되어있다. &lt;br /&gt;
  상세한 분석은 다음시간에 알아보자&lt;/p&gt;

&lt;p&gt;생성한 도커 이미지를 컨테이너로 만들어보자&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name mydb -e MYSQL_ROOT_PASSWORD=”root” -d mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec -it -uroot mydb /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;도커파일-기반-mysql-masterslave-prometheus-구성&quot;&gt;도커파일 기반 mysql (master,slave prometheus 구성)&lt;/h2&gt;

&lt;p&gt;우선 기존의 도커 컨테이너를 모두 삭제한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker stop mydb db001 db002 db003&lt;/li&gt;
  &lt;li&gt;docker rm mydb db001 db002 db003&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mysql 그룹과 유저를 각각 생성 해준다. 그리고 chown을 통해서 오너를 변경한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;groupadd -g 1001 mysql&lt;/li&gt;
  &lt;li&gt;useradd -u 1001 -r -g 1001 mysql&lt;/li&gt;
  &lt;li&gt;chown -R mysql:mysql /db/db001 /db/db002 /db/db003&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;새로운 도커 컨테이너 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name db003 -h db003 -p 3308:3306 –net mybridge –net-alias=db003 -v /db/db003/data:/var/lib/mysql -v /db/db003/log:/var/log/mysql -v /db/db003/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;같은 방법으로 002,003 도 실행&lt;/p&gt;

&lt;p&gt;프로메테우스 설정을 위한 디렉터리 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/prom001 /db/prom001/data /db/prom001/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/prom001 /db/prom001/data /db/prom001/conf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/db/prom001/conf에 promethus.yml 설정파일 만들었다.&lt;/p&gt;

&lt;p&gt;promethus 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name prom001 -h prom001 –net mybridge –net-alias=prom001 -p 9090:9090 -v /db/prom001/data:/data -v /db/prom001/conf:/etc/prometheus -d prom/prometheus-linux-amd64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;promethus를 이용할 유저 생성 (db001)에서 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create user ‘exporter’@’localhost’ identified by ‘exporter123’ WITH MAX_USER_CONNECTIONS 3;&lt;/li&gt;
  &lt;li&gt;grant PROCESS, REPLICATION CLIENT, select on &lt;em&gt;.&lt;/em&gt; to ‘exporter’@’localhost’;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exporters 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec db001 sh /opt/exporters/node_exporter/start_node_exporter.sh&lt;/li&gt;
  &lt;li&gt;docker exec db001 sh /opt/exporters/mysqld_exporter/start_mysqld_exporter.sh&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;db001,db002,db003 모두 exporter를 실행한다. &lt;br /&gt;
  그러면 모니터링을 위한 exporter가 준비 완료 되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://{도커.ip}/graph 에서 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그라파나-설정&quot;&gt;그라파나 설정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name grafana -h grafana -p 13000:3000 –net mybridge –net-alias=grafana -d grafana/grafana&lt;/li&gt;
  &lt;li&gt;http://{도커.ip}/13000 에 들어가서 직접 대시보드를 볼수있다.
    &lt;ul&gt;
      &lt;li&gt;id : admin , pwd : admin&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;grafana의 설정에서 prometheus를 설정할수있으며 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/percona/grafana-dashboards/blob/master/dashboards/MySQL_Overview.json&lt;/code&gt; 에서 json파일을 복사하여 웹상에서 import하면 유용하게 대시보드를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;doker-compose&quot;&gt;doker compose&lt;/h2&gt;

&lt;p&gt;여러 컨테이너를 한방에 배포하기&lt;/p&gt;

&lt;p&gt;도커 컴포즈 설치&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;curl -L “https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;권한 설정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;chmod +x /usr/local/bin/docker-compose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker-compose -v&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기존의 컨테이너 및 host의 data 공유 폴더 삭제&lt;/p&gt;

&lt;p&gt;도커 컴포즈를 이용한 여러 컨테이너 다움&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker-compose up -d&lt;/li&gt;
  &lt;li&gt;그후 shallscript를 이용해서 각각의 설정을 해줘야함 (유저생성, 권한 생성 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scalability&quot;&gt;Scalability&lt;/h2&gt;

&lt;p&gt;도커 호스트에 리소스가 부족해지면 어떻게 해야할까??&lt;/p&gt;

&lt;p&gt;가장 쉽게 생각 할 수 있는것은 바로 scale up이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scale up  : 컴퓨터의 리소스를 업그레이드 시키는 방법 (cpu,ram)등을 더 높은 사양으로 교체한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스를 늘릴수 없다면 ??  scale out이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scale out : 비슷한 컴퓨터 리소스를 구성하여 확장하는 시스템이다. 물론 자동으로 확장되는것은 아니고 다양한 설정이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;도커에서는 도커Swarm을 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker Swarm : 여러대의 도커 호스트를 하나의 도커호스트처럼 사용 할 수 있게 해준다.&lt;/li&gt;
  &lt;li&gt;Swarm mode : 매니저,워커 노드로 구성된 docker culster이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker-hub에-custom-image-등록&quot;&gt;docker hub에 custom image 등록&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker login&lt;/li&gt;
  &lt;li&gt;docker tag mysql57:0.0 elyo9381/mysql57:0.0&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker push elyo9381/mysql57:0.0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;docker service create –name db001 -hostname db001 -p 3306:3306 -mount type=bind,source=/db/db001/data,target=/var/lib/mysql -mount type=bind,source=/db/db001/log,target=/var/log/mysql -mount type=bind,source=/db/db001/conf,target=/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” –with-registry-auth elyo9381/mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 docker service는 swarm mode시에 사용될 custom image를 허브에 올린 image를 사용하여 도커 런 한다.&lt;/p&gt;

&lt;p&gt;–with-registry-auth 는&lt;/p&gt;

&lt;h2 id=&quot;백업과-복구&quot;&gt;백업과 복구&lt;/h2&gt;

&lt;p&gt;swarm을 이용해서 복구를 진행할것인데 이는 swarm mode를 테스트 실습 해보고 스크랩 하겠다.&lt;/p&gt;

</description>
        <pubDate>Thu, 03 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/03/mysqlOnDocker-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/03/mysqlOnDocker-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;리팩터링-해야할-시기&quot;&gt;리팩터링 해야할 시기&lt;/h2&gt;

&lt;p&gt;저자는 리팩터링을 시행해야하는 시기를 정확하게 말해주지 않는다. 시작시기 및 종료시기는 숙련된 개발자의 직관이 정확하다고 말해주고 있다.&lt;/p&gt;

&lt;p&gt;나는 리팩터링은 사소한 일이라고 생각한다.&lt;br /&gt;
  설거지,방청소와 같은 개념으로 생각한다.&lt;/p&gt;

&lt;p&gt;리팩터링을 진행하면서 가장 처음 진행될 일은 기이한 이름 바꾸기 이다.&lt;/p&gt;

&lt;p&gt;네이밍 바꾸기, 함수추출하기, 클래스만들기 등 다양한 리팩터링 기법이 존재 할수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;리팩터링을-위한-테스트코드-작성&quot;&gt;리팩터링을 위한 테스트코드 작성&lt;/h2&gt;

</description>
        <pubDate>Tue, 01 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/01/refactoring-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/01/refactoring-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>mysql on Docker with centos - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;mySQL on Docker&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;container&quot;&gt;container&lt;/h2&gt;

&lt;p&gt;도커에서 mysql 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name db001 -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행된 컨테이너 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker ps&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컨테이너 접속(execute)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec -it db001 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mysql 접속&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mysql -uroot -p&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-i -t : container에 shell 로 접속해서 사용하기 위한 옵션 &lt;br /&gt;
  –name : container의 이름 &lt;br /&gt;
  -e:환경변수 세팅 &lt;br /&gt;
  -d: background mode로 container 실행&lt;/p&gt;

&lt;h2 id=&quot;외부에서-mysql-접속하기&quot;&gt;외부에서 mysql 접속하기&lt;/h2&gt;

&lt;p&gt;container 외부에서 Mysql접속하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/p&gt;

    &lt;p&gt;-p 옵셥을 통해서 포트를 설정할수있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mysql 접속하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mysql -uroot -p -h {docker_host_ip}
  &lt;!-- - mysql -uroot -p -h 172.31.2.88 --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 나는 percona-mysql을 사용하였다. 그러므로 이를 들어갈 클라이언트를 등록해야 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stateless VS Stateful&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;container는 언제든지 재 시작 될 수 있다.&lt;/li&gt;
  &lt;li&gt;Docker image만 있으면 언제든지 동일한 구성의 Container를 실행시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;container가 삭제 후 재 생성되면 docker image 초기의 상태로 시작된다.&lt;/li&gt;
  &lt;li&gt;Web server처럼 특정 요청을 받아서 처리해주고 상태값이나 데이터를 갖지 않는 형태의 서비스에 적합 : Stateless&lt;/li&gt;
  &lt;li&gt;하지만, DB는 데이터를 저장.&lt;/li&gt;
  &lt;li&gt;MYSQL Container가 삭제되고 재생성되면 어떻게 될까 ? -&amp;gt; data loss발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;volume-설정&quot;&gt;Volume 설정&lt;/h2&gt;

&lt;p&gt;### &lt;strong&gt;&lt;em&gt;host와 볼륨 공유하기&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우리는 하나의 서버를 만들었고 이를 마스터로 사용할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/db001/data&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db001/log /db/db001/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db /db/db001 /db/db001/data&lt;/li&gt;
  &lt;li&gt;chmod -p /db/db001/log /db/db001/conf&lt;/li&gt;
  &lt;li&gt;docker run -i -t –name db003 -p 3308:3306 -v /db/db003/data:/var/lib/mysql -v /db/db003/log:/var/log/mysql -v /db/db003/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  create database testdb default character set=utf8;

  create table t1(id int not null);

  insert into t1 values(1),(2),(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;db-replication&quot;&gt;DB replication&lt;/h2&gt;

&lt;p&gt;슬레이브를 생성한다&lt;/p&gt;

&lt;p&gt;외부에서 접근가능하며 호스트에서 데이터공유가능하며 마스터와 데이터 복제를 진행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/db002/data /db/db003/data&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db002 /db/db002/data&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db003 /db/db003/data&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db002/log /db/db002/conf&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db003/log /db/db003/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db002/log /db/db002/conf&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chmod 777 /db/db003/log /db/db003/conf&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -h db001 -p 3306:3306 -v /db/db001/data:/var/lib/mysql -v /db/db001/log:/var/log/mysql -v /db/db001/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30 : mysql 만들기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;docker ps –format “table \t\t” : 내가 원하는 항목만 볼수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE USER 'rep1'@'%' IDENTIFIED BY 'rep1';

  GRANT REPLICATION SLAVE ON *.* TO 'rep1'@'%';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;마스터 컨테이너의 rep1유저 생성(MySQL)&lt;/p&gt;

&lt;p&gt;master container의 ip : 172.17.0.3&lt;/p&gt;

&lt;p&gt;그후에 db002 컨테이너의 mysql로 들어간다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CHANGE MASTER TO MASTER_HOST='172.17.0.3', MASTER_USER='rep1', MASTER_PASSWORD='rep1', MASTER_AUTO_POSITION=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;그후 start slave 명령어를 통해서 slave를 시작하고 show slave status\G 명령어를 통해서 잘 연결되었는지 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;브릿지-네트워크-구성&quot;&gt;브릿지 네트워크 구성&lt;/h2&gt;
&lt;p&gt;컨테이너는 언제든지 재 시작 될 수 있고 컨테이너가 재시작 되면 해당 컨테이너의 IP가 변경될수있습니다.&lt;/p&gt;

&lt;p&gt;MYSQL 의 Replication 설정이나 HA 설정에 IP를 사용하게 되면 컨테이너가 재 시작 될 경우 변경된 ip 때문에 replication이 깨질 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 방지하기 위해 Brige Network를 구성하고 net alias를 사용하여 ip변경에도 문제가 발생하지 않도록 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker network ls : 도커의 네트워크 list를 볼수있는 명령어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker network create –driver bridge mybridge : 브릿지 네트워크생성 명령어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -h db001 -p 3306:3306 –net mybridge –net-alias=db001 -v /db/db001/data:/var/lib/mysql -v /db/db001/log:/var/log/mysql -v /db/db001/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;orchestrator&quot;&gt;orchestrator&lt;/h2&gt;

&lt;p&gt;failOver가 발생했을때 처리하는 방법&lt;/p&gt;

&lt;p&gt;slave를 master로 올릴수 있다.&lt;/p&gt;

&lt;p&gt;오케스트레이터 컨테이너 실행하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name orchestrator -h orchestrator –net mybridge –net-alias=orchestrator -p 3000:3000 -d openarkcode/orchestrator:latest&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker inspect –format ‘’ db001 : db001 컨테이너의 ip주소 확인&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;orchestrator를 사용할 유저생성 (in db001)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reate user orc_client_user@’172.%’ identified by’orc_client_password’;&lt;/li&gt;
  &lt;li&gt;grant super,process, replication slave, reload on &lt;em&gt;.&lt;/em&gt; to orc_client_user@’172.%’;&lt;/li&gt;
  &lt;li&gt;grant select on mysql.slave_master_info TO orc_client_user@’172.%’;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;publicIP:3000/web/cluster 로 들어가면 orchestrator의 웹이 나온다.&lt;/p&gt;

&lt;h2 id=&quot;hahigh-availability-test&quot;&gt;HA(High Availability test)&lt;/h2&gt;

&lt;p&gt;시나리오 1&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db001이 정지되어 db002를 마스터로 올립니다.&lt;/li&gt;
  &lt;li&gt;db001은 개별 마스터가 되어 독립적으로 존재합니다.&lt;/li&gt;
  &lt;li&gt;db001을 db002의 slave로 등록시킵니다.
    &lt;ul&gt;
      &lt;li&gt;방법은 set global read_only = 1;&lt;/li&gt;
      &lt;li&gt;CHANGE MASTER TO MASTER_HOST=’db002’, MASTER_USER=’rep1’, MASTER_PASSWORD=’rep1’, MASTER_AUTO_POSITION=1;&lt;/li&gt;
      &lt;li&gt;start slave;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 01 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/db/2021/06/01/mysqlOnDocker-1/</link>
        <guid isPermaLink="true">http://localhost:4000/db/2021/06/01/mysqlOnDocker-1/</guid>
        
        <category>mysql</category>
        
        
        <category>db</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 5</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;권한의-이해&quot;&gt;권한의 이해&lt;/h2&gt;

&lt;p&gt;Authorization은 filter를 거친후에 url단에서 권한을 검사할수있으며 , Global Method 권한 위원회에 의해서 컨드롤러,서비스, 레포지터리단을 애노테이션기반으로 검사할수있다.&lt;/p&gt;

&lt;p&gt;SecurityFilterChain 당 한개의 filterSecurityIntercetor를 둘 수 있고, 각 SecurityInterceptor당 한개의 AccessDecisionManager를 둘 수 있습니다. 반면 Method 권한 판정을 global 한 권한 위원회를 둡니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SecurityInterceptor -&amp;gt; AccessDecisionManager -&amp;gt; AccessDecisionVoter -&amp;gt; pass / AccessDeny
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;과정으로 진행된다.&lt;/p&gt;

&lt;h2 id=&quot;voter&quot;&gt;voter&lt;/h2&gt;
&lt;p&gt;이 과정에서 기존의 방법으로는 voter의 방법이 사용되고 더 나은 방법으로는 expression 방법이 존재한다.&lt;/p&gt;

&lt;p&gt;voter는 MethodSecurityConfiguration에 GlobalMethodSecurityConfiguration을 구현체로 사용해서 accesDecisionManager()를 구현해야한다. &lt;br /&gt;
  accesDecisionManager()에서 decision을 결정할수있다. &lt;br /&gt;
  PreInvocationAuthorizationAdviceVoter, RoleVoter, AuthenticatedVoter 에서 voter가 작동하고 커스텀한 voter또한 등록하여 사용할수있다.&lt;/p&gt;

&lt;p&gt;MethodSecurityExpressionHandler를 통해서 permissionEvaluator를 핸들러에 추가할수있고 
  핸들러의 타입은 DefaultMethodSecurityExpressionHandler을 가지며 이를 생성하기 위해서는 new CustomMethodSecurityExpressionRoot(authentication, invocation);을 이용해야 가능하다.&lt;/p&gt;

&lt;p&gt;그리고 난후 handler.setPermissionEvaluator(permissionEvaluator); 클래스에 다양한 검사를 넣을수있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler(){
            @Override
            protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
                CustomMethodSecurityExpressionRoot root = new CustomMethodSecurityExpressionRoot(authentication, invocation);
                root.setPermissionEvaluator(getPermissionEvaluator());
                return root;
            }
        };
        handler.setPermissionEvaluator(permissionEvaluator);
        return handler;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;expressionvoter와-piiavoter&quot;&gt;ExpressionVoter와 PIIAVoter&lt;/h2&gt;
&lt;p&gt;WebExpressionVoter, PreInvocationAuthoriztionAdviceVoter는 SpEL 방식으로 동작한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @PostAuthorize(&quot;hasPermission(#paperId, 'paper', 'read')&quot;)
  @PostAuthorize(&quot;returnObject.studentIds.contains(principal.username)&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hasPermission&lt;/code&gt;메서드를 통해서 검사가 가능하며 SpEL을 사용해야한다. #,@등으로 SpEL을 진행할수있다. 
  returnObject을 통해서 Expression을 통해서 검사가 진행된다. Expression은 MethodSecurityExpressionOperations에서 메서드를 재정의를 통해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;AccessDecisionManager에서 AbstractAccessDecisionManager에서 AccessDecisionVoter를 통해서 voter가 진행되고 이를 통해서 Attribute가 진행되고 post,webExpress,preInvocation 등에서 postAuthorize,PostFilter등을 사용할 수 있다.&lt;/p&gt;

</description>
        <pubDate>Mon, 31 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/31/spring-security-concept-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/31/spring-security-concept-5/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;baseauthenticationfilter&quot;&gt;baseAuthenticationFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 로그인 페이지를 사용할 수 없는 상황에서 사용합니다.
    &lt;ul&gt;
      &lt;li&gt;SPA 페이지&lt;/li&gt;
      &lt;li&gt;브라우저 기반의 모바일 앱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용방법
  ```
  public class SecurityConfig extends WebSecurityConfigurerAdapter {&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Override
  protected void configure(HttpSecurity http) throws Exception {
      http
              .httpBasic()
              ;
  }
  }&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  http에서 header에 username:password 값이 묻어가기 때문에 보안에 매우 취약합니다. 반드시 https 프로토콜에서 사용할 것을 권장하고 있습니다.

  최조 로그인시에만 인증을 처리하고, 이후에는 session에 의존합니다. 또 RememberMe를 설정한 경우, 쿠기가 브러우저에 저장되기 때문에 세션이 만료된 이후라도 브라우저 기반의 앱에서는 장시간 서비스를 로그인 페이지를 거치지 않고 이용할 수 있습니다. 
  

  테스트 방법
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class BasicTokenTest {

    @LocalServerPort
    int port;

    private RestTemplate restTemplate = new RestTemplate();

    @DisplayName(&quot;1. Basic Token Test&quot;)
    @Test
    void test_1(){

        String url = format(&quot;http://localhost:%d%s&quot;, port, &quot;/greeting&quot;);
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.AUTHORIZATION, &quot;basic &quot;+ Base64.getEncoder().encodeToString(&quot;user1:1111&quot;.getBytes()));
        HttpEntity entity = new HttpEntity(&quot;&quot;, headers);

        ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.exchange(url,
                HttpMethod.GET, entity, String.class);

        assertEquals(&quot;Hello jongwon&quot;, response.getBody());
    }

}   ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;session-with-basic-authentication&quot;&gt;Session with Basic Authentication&lt;/h2&gt;

&lt;p&gt;Basic Authentication을 이용해서 세선과 클라이언트 로그인을 진행 할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 인증 처리는 세션과는 별도로 동작하도록 설계되어 있습니다. 그래서 session을 사용하건 사용하지 않건 같은 authentication과 authenticationProvider를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버의 세션정책과 스프링의 인정 체계가 서로 맞물려 작동하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;SecurityContextPersistenceFilter&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;RememberMeAuthenticationFilter&lt;/code&gt;등과 여러 인증을 보조해주는 다른 필터들의 도움을 받아야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;securitycontextpersistencefilter&quot;&gt;&lt;strong&gt;SecurityContextPersistenceFilter&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;SecurityContextRepository에 저장된 SecurityContext를 request의 localThread에 넣어주었다가 뺐는 역할을 한다. doFilter 메소드를 따라가보면 알수 있다. 세션에 SecurityContext를 보관했다가 다음 request에서 넣어줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SecurityContextPersistenceFilter -&amp;gt; SecurityContextRepository
SecurityContextPersistenceFilter -&amp;gt; SecurityContextHolder

HttpSessionSecurityContextRepository -&amp;gt; SecurityContextRepository
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;remembermeauthenticationfilter&quot;&gt;RememberMeAuthenticationFilter&lt;/h2&gt;

&lt;p&gt;인증 정보를 세션관리하는 경우 , 세션 timeout이 발생하게 되면, remember-me 쿠키를 이용해 로그인을 기억했다 자동으로 재로그인 시켜주는 기능입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RememberMeAuthenticationFilter -&amp;gt; RememberMeServices
  
  AbstrackRememberMeService -&amp;gt; RememberMeService

  TokenBasedRememberMeService -&amp;gt; AbstrackRememberMeService
  PersistenceTokenBasedRememberMeService -&amp;gt; AbstrackRememberMeService

  PersistenceTokenBasedRememberMeService -&amp;gt; PersistenceTokenRepository
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PersistenceTokenRepository에 username, series, token,last_used 정보가 들어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;토큰기반의 TokenBasedRememberMeService은 다음과 같은 특징이 존재합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포맷 : 아이디 : 만료시간 : Md5Hex(아이디:만료시간:비밀번호:인증키)&lt;/li&gt;
  &lt;li&gt;만약 User가 password를 바꾼다면 토큰을 쓸 수 없게 됩니다.&lt;/li&gt;
  &lt;li&gt;기본 유효기간은 14일 이고 설정에서 바꿀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;약점 : 탈취된 토큰은 비밀번호를 바꾸지 않는한 유효기간동안 만능키가 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇기 때문에 토큰기반의 탈취시 문제의 소지가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PersistenceTokenBasedRememberMeServices&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포멧 : series:token&lt;/li&gt;
  &lt;li&gt;토큰에 username이 노출되지 않고, 만료시간도 노출되지 않습니다. 만료시간은 서버에서 정하고 노출하지 않고 서버는 로그인 시간만 저장합니다.&lt;/li&gt;
  &lt;li&gt;series 값이 키가 된다. 일종의 채널이라고 보면 편리하다.&lt;/li&gt;
  &lt;li&gt;대신 재로그인이 될 때마다 token 값을 갱신해 줍니다. 그래서 토큰이 탈취되어 다른 사용자가 다른 장소에서 로그인을 했다면 정상 사용자가 다시 로그인 할 때, CookieTheftException 이 발생하게 되고, 서버는 해당 사용자로 발급된 모든 remember-me 쿠키값들을 삭제하고 재로그인을 요청하게 됩니다.&lt;/li&gt;
  &lt;li&gt;InmemoryTokenRepository 는 서버가 재시작하면 등록된 토큰들이 사라집니다. 따라서 자동로그인을 설정했더라도 다시 로그인을 해야 합니다. 재시작 후에도 토큰을 남기고 싶다면 JdbcTokenRepository를 사용하거나 이와 유사한 방법으로 토큰을 관리해야 합니다.&lt;/li&gt;
  &lt;li&gt;로그아웃하게 다른 곳에 묻혀놓은 remember-me 쿠키값도 쓸모가 없게 됩니다. 만약 다른 곳에서 remember-me로 로그인한 쿠키를 살려놓고 싶다면, series 로 삭제하도록 logout 을 수정해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-4/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;authentication&quot;&gt;Authentication&lt;/h2&gt;

&lt;p&gt;인증은 다음과 같이 구성되어있다. &lt;br /&gt;
  그리고 인증을 구성하기 위해서 사용되는 토큰이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication
    &lt;ul&gt;
      &lt;li&gt;Credentiails&lt;/li&gt;
      &lt;li&gt;Principal&lt;/li&gt;
      &lt;li&gt;Details&lt;/li&gt;
      &lt;li&gt;Authorities&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러개의 토큰을 사용해서 인증을 구성한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UsernamePasswordAuthentication Token&lt;/li&gt;
  &lt;li&gt;RunAsUser Token&lt;/li&gt;
  &lt;li&gt;TestingAuthentication Token&lt;/li&gt;
  &lt;li&gt;AnonymouseAuthenication Token&lt;/li&gt;
  &lt;li&gt;RememberMeAuthentication Token&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;authenticationprovider&quot;&gt;AuthenticationProvider&lt;/h2&gt;
&lt;p&gt;Authentication을 검증하여 Principal을 제공합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class StudentManager implements AuthenticationProvider, InitializingBean {

    private HashMap&amp;lt;String, Student&amp;gt; studentDB = new HashMap&amp;lt;&amp;gt;();

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        StudentAuthenticationToken token = (StudentAuthenticationToken) authentication;
        if(studentDB.containsKey(token.getCredentials())){
            Student student = studentDB.get(token.getCredentials());
            return StudentAuthenticationToken.builder()
                    .principal(student)
                    .details(student.getUsername())
                    .authenticated(true)
                    .authorities(student.getRole())
                    .build();
        }
        return null;
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; authentication) {
        return authentication == StudentAuthenticationToken.class;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        Set.of(
                new Student(&quot;hong&quot;, &quot;홍길동&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;))),
                new Student(&quot;kang&quot;, &quot;강아지&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;))),
                new Student(&quot;rang&quot;, &quot;호랑이&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;)))
        ).forEach(s-&amp;gt;
            studentDB.put(s.getId(), s)
        );
    }   
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;authenticationProvider를 커스텀해서 사용할수있다. 이를 만들기 위해서 student, StudentAuthenticationToken이 필요하다.&lt;/p&gt;

&lt;p&gt;student는 사용자의 데이터를 받을 클래스,StudentAuthenticationToken 정보를 담을 클래스이다. &lt;br /&gt;
  StudentAuthenticationToken은 즉 userDetails가 되는것이다.&lt;/p&gt;

&lt;p&gt;이를 구현하고 securityConfig에서 사용하면된다. 그리고&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   public class CustomLoginFilter extends UsernamePasswordAuthenticationFilter {

    public CustomLoginFilter(AuthenticationManager authenticationManager){
        super(authenticationManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        String username = obtainUsername(request);
        username = (username != null) ? username : &quot;&quot;;
        username = username.trim();
        String password = obtainPassword(request);
        password = (password != null) ? password : &quot;&quot;;
        String type = request.getParameter(&quot;type&quot;);
        if(type == null || !type.equals(&quot;teacher&quot;)){
            // student
            StudentAuthenticationToken token = StudentAuthenticationToken.builder()
                    .credentials(username).build();
            return this.getAuthenticationManager().authenticate(token);
        }else{
            // teacher
            TeacherAuthenticationToken token = TeacherAuthenticationToken.builder()
                    .credentials(username).build();
            return this.getAuthenticationManager().authenticate(token);
        }
    }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;아래와 같이 filter 또한 직접 커스텀해서 사용가능하다.&lt;/p&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-3/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;폼-로그인&quot;&gt;폼 로그인&lt;/h1&gt;

&lt;h2 id=&quot;defaultloginpagegeneratingfilter&quot;&gt;DefaultLoginPageGeneratingFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;GET /login 을 처리&lt;/li&gt;
  &lt;li&gt;별도의 로그인 페이지 설정을 하지 않으면 제공되는 필터&lt;/li&gt;
  &lt;li&gt;기본 로그인 폼을 제공&lt;/li&gt;
  &lt;li&gt;OAuth2 / OpenID / Saml2 로그인과도 같이 사용할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;POST /login 을 처리. processingUrl 을 변경하면 주소를 바꿀 수 있음.&lt;/li&gt;
  &lt;li&gt;form 인증을 처리해주는 필터로 스프링 시큐리티에서 가장 일반적으로 쓰임.&lt;/li&gt;
  &lt;li&gt;주요 설정 정보
    &lt;ul&gt;
      &lt;li&gt;filterProcessingUrl : 로그인을 처리해 줄 URL (POST)&lt;/li&gt;
      &lt;li&gt;username parameter : POST에 username에 대한 값을 넘겨줄 인자의 이름&lt;/li&gt;
      &lt;li&gt;password parameter : POST에 password에 대한 값을 넘겨줄 인자의 이름&lt;/li&gt;
      &lt;li&gt;authenticationDetailSource : Authentication 객체의 details 에 들어갈 정보를 직접 만들어 줌.
```
@Override
public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
      throws AuthenticationException {
  if (this.postOnly &amp;amp;&amp;amp; !request.getMethod().equals(“POST”)) {
      throw new AuthenticationServiceException(“Authentication method not supported: “ + request.getMethod());
  }
  String username = obtainUsername(request);
  username = (username != null) ? username : “”;
  username = username.trim();
  String password = obtainPassword(request);
  password = (password != null) ? password : “”;
  UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
  // Allow subclasses to set the “details” property
  setDetails(request, authRequest);
  return this.getAuthenticationManager().authenticate(authRequest);
}&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;defaultlogoutpagegeneratingfilter&quot;&gt;DefaultLogoutPageGeneratingFilter&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;GET /logout 을 처리&lt;/li&gt;
  &lt;li&gt;POST /logout 을 요청할 수 있는 UI 를 제공&lt;/li&gt;
  &lt;li&gt;DefaultLoginPageGeneratingFilter 를 사용하는 경우에 같이 제공됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logoutfilter&quot;&gt;LogoutFilter&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;POST /logout 을 처리. processiongUrl 을 변경하면 바꿀 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실습-예제&quot;&gt;실습 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;HomeController&lt;/li&gt;
  &lt;li&gt;SecurityConfig&lt;/li&gt;
  &lt;li&gt;RequestInfo&lt;/li&gt;
  &lt;li&gt;CustomAuthDetails&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 컨드롤러 및 컨피그를 설정하여 실습을 진행함 
  컨트롤러에는 로그인, 로그아웃, 홈, 엑세스디나인, 유저 , 어드민을 갈수있는 url이 설정되어있다. &lt;br /&gt;
  페이지는 간단하게 string만 출력한다.&lt;/p&gt;

&lt;p&gt;유저는 SecurityContig에서 간단하게 설정하였다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .inMemoryAuthentication()
                .withUser(
                        User.withDefaultPasswordEncoder()
                                .username(&quot;user1&quot;)
                                .password(&quot;1111&quot;)
                                .roles(&quot;USER&quot;)
                ).withUser(
                User.withDefaultPasswordEncoder()
                        .username(&quot;admin&quot;)
                        .password(&quot;2222&quot;)
                        .roles(&quot;ADMIN&quot;)
        );

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;request를 위한 필터 설정은 SecurityConfig의 configure(HttpSecurity http)에서 설정하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests(request-&amp;gt;{
                    request
                            .antMatchers(&quot;/&quot;).permitAll()
                            .anyRequest().authenticated()
                            ;
                })
                .formLogin(
                        login-&amp;gt;login.loginPage(&quot;/login&quot;)
                        .permitAll()
                        .defaultSuccessUrl(&quot;/&quot;,false)
                        .failureUrl(&quot;/login-error&quot;)
                        .authenticationDetailsSource(customAuthDetails)
                )
                .logout(logout-&amp;gt;logout.logoutSuccessUrl(&quot;/&quot;))
                .exceptionHandling(exception-&amp;gt;exception.accessDeniedPage(&quot;/access-denied&quot;))
                ;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드에서 각 유저의 로그인을 설정하였고 커스텀한 Details를 설정하였다. &lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;커스텀 Details&lt;/code&gt;는 아래와 같이 구성되어있고 ip,sessionId,로그인시각을 기록한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Component
    public class CustomAuthDetails implements AuthenticationDetailsSource&amp;lt;HttpServletRequest,RequestInfo&amp;gt; {

        @Override
        public RequestInfo buildDetails(HttpServletRequest request) {
            return RequestInfo.builder()
                    .remoteIp(request.getRemoteAddr())
                    .sessionId(request.getSession().getId())
                    .loginTime(LocalDateTime.now())
                    .build();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;security&quot;&gt;security&lt;/h1&gt;

&lt;p&gt;spring은 웹서버로 많이 사용된다. &lt;br /&gt;
  이때 클라이언트로 부터 request를 받고 서버(spring)은 response를 준다.&lt;/p&gt;

&lt;p&gt;서버가 reqeust를 스프링을 request응 다양한 filter로 확인을 하고 필터에 해당하지 않으면 에러를 발송한다. &lt;br /&gt;
  이때 스프링이서 필터들을 관리하고 다양한 필터가 설정되는곳이 스프링 시큐리티이다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떠한 필터가 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeaderWriterFilter : Http 해더를 검사한다. 써야 할 건 잘 써있는지, 필요한 해더를 더해줘야 할 건 없는가?&lt;/li&gt;
  &lt;li&gt;CorsFilter : 허가된 사이트나 클라이언트의 요청인가?&lt;/li&gt;
  &lt;li&gt;CsrfFilter : 내가 내보낸 리소스에서 올라온 요청인가?&lt;/li&gt;
  &lt;li&gt;LogoutFilter : 지금 로그아웃하겠다고 하는건가?&lt;/li&gt;
  &lt;li&gt;UsernamePasswordAuthenticationFilter : username / password 로 로그인을 하려고 하는가? 만약 로그인이면 여기서 처리하고 가야 할 페이지로 보내 줄께.&lt;/li&gt;
  &lt;li&gt;ConcurrentSessionFilter : 여거저기서 로그인 하는걸 허용할 것인가?&lt;/li&gt;
  &lt;li&gt;BearerTokenAuthenticationFilter : Authorization 해더에 Bearer 토큰이 오면 인증 처리 해줄께.&lt;/li&gt;
  &lt;li&gt;BasicAuthenticationFilter : Authorization 해더에 Basic 토큰을 주면 검사해서 인증처리 해줄께.&lt;/li&gt;
  &lt;li&gt;RequestCacheAwareFilter : 방금 요청한 request 이력이 다음에 필요할 수 있으니 캐시에 담아놓을께.&lt;/li&gt;
  &lt;li&gt;SecurityContextHolderAwareRequestFilter : 보안 관련 Servlet 3 스펙을 지원하기 위한 필터라고 한다.(?)&lt;/li&gt;
  &lt;li&gt;RememberMeAuthenticationFilter : 아직 Authentication 인증이 안된 경우라면 RememberMe 쿠키를 검사해서 인증 처리해줄께&lt;/li&gt;
  &lt;li&gt;AnonymousAuthenticationFilter : 아직도 인증이 안되었으면 너는 Anonymous 사용자야&lt;/li&gt;
  &lt;li&gt;SessionManagementFilter : 서버에서 지정한 세션정책을 검사할께.&lt;/li&gt;
  &lt;li&gt;ExcpetionTranslationFilter : 나 이후에 인증이나 권한 예외가 발생하면 내가 잡아서 처리해 줄께&lt;/li&gt;
  &lt;li&gt;FilterSecurityInterceptor : 여기까지 살아서 왔다면 인증이 있다는 거니, 니가 들어가려고 하는 request 에 들어갈 자격이 있는지 그리고 리턴한 결과를 너에게 보내줘도 되는건지 마지막으로 내가 점검해 줄께&lt;/li&gt;
  &lt;li&gt;그 밖에… OAuth2 나 Saml2, Cas, X509 등에 관한 필터들도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등의 다양한 필터가 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;authentication&quot;&gt;authentication&lt;/h2&gt;

&lt;p&gt;필터와 인증제공자를 통해서 SecurityContextHolder에 인증이 만들어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SecurityContextHolder : 인증보관함 보관소
    &lt;ul&gt;
      &lt;li&gt;Authentication : 인증
        &lt;ul&gt;
          &lt;li&gt;Principal(UserDetails) : 인증대상
            &lt;ul&gt;
              &lt;li&gt;GrantedAuthority : 권한&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AuthenticationManager : 인증관리자
    &lt;ul&gt;
      &lt;li&gt;ProviderManager : 인증 제공 관리자
        &lt;ul&gt;
          &lt;li&gt;AuthenticationProvider : 인증제공자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;security는 위와 같이 구성되어있다고 볼수있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로그인을 위한 토큰을 제공하는 필터는 다음과 같다.
    &lt;ul&gt;
      &lt;li&gt;UsernamePasswordAuthenticationFilter : 폼 로그인 -&amp;gt; UsernamePasswordAuthenticationToken&lt;/li&gt;
      &lt;li&gt;RememberMeAuthenticationFilter : remember-me 쿠키 로그인 -&amp;gt; RememberMeAuthenticationToken&lt;/li&gt;
      &lt;li&gt;AnonymousAuthenticationFilter : 로그인하지 않았다는 것을 인증함 -&amp;gt; AnonymousAuthenticationToken&lt;/li&gt;
      &lt;li&gt;SecurityContextPersistenceFilter : 기존 로그인을 유지함(기본적으로 session 을 이용함)&lt;/li&gt;
      &lt;li&gt;BearerTokenAuthenticationFilter : JWT 로그인&lt;/li&gt;
      &lt;li&gt;BasicAuthenticationFilter : ajax 로그인 -&amp;gt; UsernamePasswordAuthenticationToken&lt;/li&gt;
      &lt;li&gt;OAuth2LoginAuthenticationFilter : 소셜 로그인 -&amp;gt; OAuth2LoginAuthenticationToken, OAuth2AuthenticationToken&lt;/li&gt;
      &lt;li&gt;OpenIDAuthenticationFilter : OpenID 로그인&lt;/li&gt;
      &lt;li&gt;Saml2WebSsoAuthenticationFilter : SAML2 로그인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Authentication을 제공하는 인증제공자는 여러개가 동시에 존재할 수있고, 인증 방식에 따라 providerManager도 복수로 존재할수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Authentication 은 인터페이스로 아래와 같은 정보들을 갖고 있습니다.
    &lt;ul&gt;
      &lt;li&gt;Set&lt;GrantedAuthority&gt; authorities : 인증된 권한 정보&lt;/GrantedAuthority&gt;&lt;/li&gt;
      &lt;li&gt;principal : 인증 대상에 관한 정보. 주로 UserDetails 객체가 옴&lt;/li&gt;
      &lt;li&gt;credentials : 인증 확인을 위한 정보. 주로 비밀번호가 오지만, 인증 후에는 보안을 위해 삭제함.&lt;/li&gt;
      &lt;li&gt;details : 그 밖에 필요한 정보. IP, 세션정보, 기타 인증요청에서 사용했던 정보들.&lt;/li&gt;
      &lt;li&gt;boolean authenticated : 인증이 되었는지를 체크함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;리팩토링&quot;&gt;리팩토링&lt;/h2&gt;

&lt;p&gt;리팩터링 어디에 써먹을까?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리팩터링이 필요한 이유를 윗사람에게 설득할수있다.&lt;/li&gt;
  &lt;li&gt;고민의 일정량을 줄일 수 있다. (성능과 코드의 가독성…)
    &lt;ul&gt;
      &lt;li&gt;나의 주관으로는 코드의 가독성을 유지하되 성능이 필요하면 성능적으로 작성하면 되지 않을까 싶다.&lt;/li&gt;
      &lt;li&gt;디버깅이 어려울수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;나의 리팩토링 이유는 생산성 향상에 목표를 둘것이다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩터링-하는-이유&quot;&gt;리팩터링 하는 이유&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;리팩터링하면 소프트웨어 설계가 좋아진다.
    &lt;ol&gt;
      &lt;li&gt;규칙적인 리팩터링은 코드의 구조를 지탱해줄것이다.&lt;/li&gt;
      &lt;li&gt;중복코드를 제거하면 모든코드가 언제나 고유한 일을 수행함을 보장 할 수있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;리팩터링 하면 소프트웨어를 이해하기 쉬워진다.
    &lt;ol&gt;
      &lt;li&gt;코드의 목적은 타인에게 말하기 쉬워진다.&lt;/li&gt;
      &lt;li&gt;나의 코드는 내가보기에 이해하기 쉽지만 타인의 시선에서는 다르다.&lt;/li&gt;
      &lt;li&gt;이는 내가 나의 코드를 알아보기 쉬워진다는 이야기이다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;리팩터링 하면 버그를 쉽게 찾을 수 있다.&lt;/li&gt;
  &lt;li&gt;리팩터링하면 프로그래밍 속도를 높일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;리팩터링-하지-말아야-할때&quot;&gt;리팩터링 하지 말아야 할때&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;외부 API를 호출해서 사용하는 코드 (지저분해도 그냥 둔다.)&lt;/li&gt;
  &lt;li&gt;리팩터링 하는것 or 새로작성하는것 » 둘중 판단이 서지 않을때는 리팩터링 하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;why? 이를 결정하는것은 뛰어난 판단력과 경험이 있어야 하므로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;리팩터링-시-고려할-문제&quot;&gt;리팩터링 시 고려할 문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;새 기능, 개발속도 저하 ?
    &lt;ul&gt;
      &lt;li&gt;새기능을 구현하기 편해지겠다 싶으면 리팩터링을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 경우에는 리팩터링 하지 않는다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;반면에 내가 직접 건드릴일이없는 분야&lt;/li&gt;
  &lt;li&gt;불편한 정도가 심하지 않는 경우&lt;/li&gt;
  &lt;li&gt;리팩토링으로 개선되지 않을것같은 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리팩터링시 가장 중요한 요소는 경제적 요소이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;리팩토링은 경제적 생산성 향상을 위해서 진행 되어야 한다. !!!&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩터링과-성능&quot;&gt;리팩터링과 성능&lt;/h2&gt;

&lt;p&gt;리팩터링을 하면 성능이 느려질 수 도 있다는것은 사실이다. &lt;br /&gt;
  하지만 빠른 소프트웨어를 만들기에 부족한 점은 아니다. &lt;br /&gt;
  먼저 리팩터링을 통해 튜닝하기 쉽게 만들고 원하는 속도가 나오게끔 튜닝하는것이 베스트라고 생각한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능을 향상시키는 다양한 방법
    &lt;ol&gt;
      &lt;li&gt;최신의 하드웨어를 사용한다.
        &lt;ul&gt;
          &lt;li&gt;리얼타임 SW등 하드웨어에 종속적인 SW는  하드웨어를 바꾸는게 성능을 향상시키는방법이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;끊임없는 관심을 기울인다.
        &lt;ul&gt;
          &lt;li&gt;시간과 공간을 많이 잡아먹는 지점을 알아낸다.(프로파일러 프로그램)&lt;/li&gt;
          &lt;li&gt;성능에 큰 영향을 주는 작은 부분을 찾아낸다.&lt;/li&gt;
          &lt;li&gt;위의 단계를 반복하면서 최적화한다. (리팩토링이 되어있다면 코드를 보기 수월하니 좋은 방법이라 생각한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/refactoring-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/refactoring-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 JWT - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;jwt&quot;&gt;JWT&lt;/h2&gt;
&lt;p&gt;JSON WEB TOKEN : JWT&lt;/p&gt;

&lt;p&gt;정의 : 당사자간에 정보를 JSON 객체로 안전하게 전송하기 위한 컴팩트하고 독립적인 방식을 정의 하는 개방형 표준 입니다. &lt;br /&gt;
  JWP는 비밀(RSA or ECDSA)로 암호화및 복호화를 통해 서명 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;JWT는 다음과 같이 구성되어있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;header
    &lt;ul&gt;
      &lt;li&gt;알고리즘과 타입으로 구성되어있고 Base64UrI로 인코딩 되어있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;payload : 어떤 정보이다.
    &lt;ul&gt;
      &lt;li&gt;클래임을 가진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;signature
    &lt;ul&gt;
      &lt;li&gt;헤더의 정보와 페이로드와 개인키를 암호알고리즘으로 암호화 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  xxxx-yyyy-zzzz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JWT는 header,payload,signature를 각각 base64인코딩하여 JWT를 구성하고 web의 로컬스토리지에 담긴다.&lt;/p&gt;

&lt;p&gt;그리고 이를 서버에 넘긴다.&lt;/p&gt;

&lt;p&gt;JWT를 받은 서버는 신뢰할수있는 토큰인지 검증한다.&lt;/p&gt;

&lt;p&gt;JWT를 암호화할때 RSA또는 hs256으로 암호화 할수있다. (전자서명)&lt;/p&gt;
</description>
        <pubDate>Sun, 23 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/23/spring-security-4-JWT/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/23/spring-security-4-JWT/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 JWT</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;세션&quot;&gt;세션&lt;/h2&gt;

&lt;p&gt;우리가 알아볼내용 jwt에서 가장 중요한 질문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jwt을 왜 사용되는지&lt;/li&gt;
  &lt;li&gt;jwt가 어디에 쓰는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jwt를 공부하기 앞서 session에 대해서 다시 한번 정리 해보겠습니다.&lt;/p&gt;

&lt;p&gt;session은 어떠한 정보가 내포 되어있는 캐시의 개념입니다.  &lt;br /&gt;
  session은 쿠키에 저장됩니다.  &lt;br /&gt;
  쿠키는 http.header에 보관(저장) 됩니다.&lt;/p&gt;

&lt;p&gt;우리는 홈페이지에 여러번 로그인하거나 방문할수있습니다. 
  재접속 하거나 재방문 할때마다 session(쿠키)를 요구한다면 매우 비효율적일것입니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 우리는 쿠키를 보관하고 이를 통해서 재방문,로그인,다양한 정보를 보관합니다.&lt;/p&gt;

&lt;p&gt;세션(쿠키)는 다음과 같은 방식으로 동작합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최초 요청시 서버는 목록에 쿠키를 저장하고 헤더에 쿠키를 담아 클라이언트에 던져줍니다.&lt;/li&gt;
  &lt;li&gt;브라우저 내부에 쿠키를 보관하고 있습니다.
    &lt;ol&gt;
      &lt;li&gt;클라이언트가 재요청시 요청에 쿠키의 정보를 사용하여 재요청을 보냅니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 요청을 받고 쿠키를 확인하고 목록에서 쿠키가 있으면 기존의 사용자임을 확인합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;세션은 서버측에서도 삭제할수있고 클라이언트측에서도 삭제 할수있습니다. 특별한 경우가 없을경우 시간에 따라 삭제됩니다.&lt;/p&gt;

&lt;p&gt;세션의 단점 : 클라이언트가 많은때 &lt;code class=&quot;highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;이 일어난다. 서버가 여러대일때 내가 최초 들어갔던 서버가 아니면 세션은 계속 생성된다.&lt;/p&gt;

&lt;p&gt;세션의 단점을 처리는 방법은 여러 방법이 존재한다. 해결방법은 : 공유되는 메모리 &lt;code class=&quot;highlighter-rouge&quot;&gt;메모리서버&lt;/code&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;이러한 고질점은 해결하기 위해서 JWT를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;

&lt;p&gt;물,데,네,트,세,프,용 !!&lt;/p&gt;

&lt;p&gt;OSI 7계층을 알아야한다. &lt;br /&gt;
  OSI 7계층은 각 계층별로 선정되는 데이터가 존재하고 다음 계층으로 전달한다. &lt;br /&gt;
  대략적인 느낌은 이렇게는 것이다.  &lt;br /&gt;
  정확한 내용은 다른 블로그를 참고 하길 바랍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP
    &lt;ul&gt;
      &lt;li&gt;신뢰를 기반으로 전송하는 방법이다.&lt;/li&gt;
      &lt;li&gt;ack를 기반으로 통신한다. ack가 오지 않는다면 다시 전송을 진행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDP
    &lt;ul&gt;
      &lt;li&gt;ack를 보내지 않고 데이터를 전송한다.&lt;/li&gt;
      &lt;li&gt;신뢰적 전송을 제공하지 않는다.&lt;/li&gt;
      &lt;li&gt;UDP는 하나의 회선을 차지하고 있는다. 그리고 stream, 전화등에서 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ciaconfidential-integrety-authability&quot;&gt;CIA(confidential, Integrety, authability)&lt;/h2&gt;

&lt;p&gt;위에서 TCP에 대해서 간단하게 정립하였다. &lt;br /&gt;
  TCP 전송중에 누군가 데이터를 확인한다면 ? 어떻게 되는가?? : 기밀성이 깨진다.&lt;/p&gt;

&lt;p&gt;그 데이터를 변경하면 ?? : 무결성이 깨진다.&lt;/p&gt;

&lt;p&gt;마지막으로 우리는 원래 받아야할 데이터를 못받았므로 가용성이 깨진다.&lt;/p&gt;

&lt;p&gt;통신에서 CIA를 지키기 위해서 암호화를 한다.&lt;/p&gt;

&lt;p&gt;암호화를 하기위해서 다양한 방법이 필요하다 (대칭키 , 비대칭키)&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;public key : 공개키&lt;/p&gt;

&lt;p&gt;private key : 개인키&lt;/p&gt;

&lt;p&gt;송신자는 수신자의 공개키로 암호화하고 수신자는 본인의 개인키로 복호화 할수있다. &lt;br /&gt;
  우리는 이렇한 방법을 통해서 암호화가 가능하다 &lt;br /&gt;
  이것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;RSA&lt;/code&gt; 암호 방식이다.&lt;/p&gt;

&lt;p&gt;또한 공개키 , 개인키를 기반으로 전자서명이 존재한다.&lt;/p&gt;

&lt;p&gt;A는 본인의 개인키로 암호화하고 누군가에게 송신한다. &lt;br /&gt;
  A의 메세지를 수신받은 B는 A의 공개키로 메세지를 열어볼수있고 이를 통해서 메세지 내용을 확인할수있다. &lt;br /&gt;
  우리는 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;전자서명&lt;/code&gt;이라 한다.&lt;/p&gt;

&lt;p&gt;RSA는 이산대수 문제의 원리를 통해서 암복호화 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;주어진 g, x, p를 이용하여 y = g^x mod p를 구하긴 쉽지만, g, y, p 값을 이용하여 원래의 x는 찾기 어렵다는 것이다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rfc문서&quot;&gt;RFC문서&lt;/h2&gt;
&lt;p&gt;인터넷 통신을 프로토콜로 정의해놓은 문서이다.&lt;/p&gt;

</description>
        <pubDate>Sun, 23 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/23/spring-security-3-JWT/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/23/spring-security-3-JWT/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 OAuth login</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;security&quot;&gt;security&lt;/h1&gt;

&lt;p&gt;oauth2를 위한 버튼, url 등이 필요하며 응답을 받을 url을 각 페이지에서 설정해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  .and()
    .oauth2Login()
    .loginPage(&quot;/login&quot;)
    .userInfoEndpoint()
    .userService(principalOauth2UserService);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;oauth2 사용을 위한 DefaultOAuth2UserService (loadUser메서드)&lt;/p&gt;

&lt;p&gt;Authentication 객체가 가질수있는 2가지 타입&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UserDetails&lt;/li&gt;
  &lt;li&gt;OAuth2User&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/20/spring-security-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/20/spring-security-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
  </channel>
</rss>

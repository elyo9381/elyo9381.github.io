<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elyo</title>
    <description>진심을 다해서 
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 11 Jun 2021 22:57:42 +0900</pubDate>
    <lastBuildDate>Fri, 11 Jun 2021 22:57:42 +0900</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>리팩터링 리뷰 - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본적인-리팩터링&quot;&gt;기본적인 리팩터링&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;함수 추출하기 
    - 목적과 구현을 분리하는 방법이 가장 합리적인 기준으로 보인다. 
    - 1 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다. (어떻게가 아닌 무엇을 하는지가 드러나야한다.)
    - 2 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여 넣는다.
    - 3 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다. 
    - 4 변수를 다 처리했다면 컴파일한다.
    - 5 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
    - 6 테스트를 한다.
    - 7 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방근 추출한 새 함수를 호출하도록 바꿀지 검토한다.(인라인코드를 함수 호출로 바꾸기)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 위의 과정을 통해서 진행하고 세부적인 내용(지역변수, 함수추출, 지역변수 매개변수화)등을 수행한다. 
  - 반환값이 여러개일땐? 
    - 저자는 하나의 값만 반환하는것을 선호하여 반환하는 함수를 여러개 만든다고 한다.
    - 레코드로 묵어서 반환해도 된다.
    - 임시수를 질의 함수로 바꾸거나 변수를 쪼개는 식으로 처리하면 좋다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;함수 인라인 하기 
    - 목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권한다. 
    - 간접 호출을 너무 과하게 쓰는 코드도 인라인 대상이다. 
    - 1 다형 메서드인지 확인한다.
    - 2 인라인할 함수를 호출하는 곳을 모두 찾는다.
    - 3 각 호출문의 함수 본문으로 교체한다. 
    - 4 하나씩 교체할 때마다 테스트한다. 
    - 5 함수 정의를 삭제한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 인라인시에 주의할점을 소개한다. 
  - 하나의 코드를 인라인 하면 편리하다. 
  - 하지만 로그를 여려개 찍는 코드를 인라인하면 복잡해지거나 더러워질수있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;변수 추출하기
    - 표현식이 너무 복잡해서 이해하기 어려울 때가 있다. 이럴 때 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다. (인라인시..!)
    - 문맥을 넓히는 것이다. 이때 주의할점은 할일이 늘어난다는것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 1 추출하려는 표현식에 부작용은 없는지 확인한다.
- 2 불변 변수를 하나 선언하고 이름을 붙일 표현식의 본제본을 대입한다.
- 3 원본 표현식을 새로 만든 변수로 교체한다.
- 4 테스트한다.
- 5 표현식을 여러곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 떄마다 테스트한다. 
- 클래스내부에서도 동일하게 작동되고 이때 더 효율적이다. 왜?? 클래스를 한눈에 볼수있으므로 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;변수 인라인 하기 
    - 변수는 함수안에서 표현식을 가리키는 이름으로 쓰이며, 대체로 긍정적인 효과를 준다. 
    - 1 대입문의 우변에서 부작용이 생기지는 않는지 확인한다.
    - 2 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.
    - 3 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다.
    - 4 테스트한다. 
    - 5 변수를 사용하는 부분을 모두 교체할 때까지 이과정을 반복한다. 
    - 6 변수 선언문과 대입문을 지운다.
    - 7 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수 선언 바꾸기
    - 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
    - 1 이어지는 추출단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
    - 2 함수본문을 새로운 함수로 추출한다. 
    - 3 추출한 삼수에 매개변수를 추가해야한다면 ‘간단한 절차’를 따라 추가한다.
    - 4 테스트한다.
    - 5 기존함수를 인라인한다.
    - 6 이름을 임시로 붙여뒀다면 함수선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
    - 7 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수 캡슐화화기
    - 데이터는 함수보다 다루기 까다로운데, 그 이유는 이런 식으로 처리할 수 없기 때문이다. 데이터는 참조하는 모든 부분을 한번에 바꿔야 코드가 제대로 작동한다. 짧은 함수 안의 임시 변수처럼 유효범위가 아주 좁은 데이터는 어려울게 없지만, 유효범위가 넓어질수록 다루기 어려워진다. 전역 데이터가 골칫거리인 이유도 바로 여기에 있다.
    - 1 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
    - 2 정적 검사를 수행한다.
    - 3 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
    - 4 변수의 접근 범위를 제한한다.
    - 5 테스트한다.
    - 6 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 변수 캡슐화하기에서 중요한점은 기존의 데이터의 변경뿐만 행위까지 변경하고 싶은 경우가 발생할수도 있다. 
- 이러한 경우는 기존데이터를 복사하는 방법으로 진행한다. 
- 생성자를 통해서 또는 리스트의 값을 반환하게 하는것이다. 
- 본제본 만들기와 클래스로 감싸는 방식은 레코드 구조에서 깊이가 1인 속성들 까지만 효과가 있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;변수 이름 바꾸기
    - 이름의 중요성은 그 사용 범위에 영향을 많이 받는다. 한 줄 짜리 람다식에서 사용하는 변수는 대체로 쉽게 파악할 수 있다. 
    - 1 폭널게 쓰이는 변수라면 캡슐화하기를 고려한다.
    - 2 이름을 바꿀 변수를 참조하는곳을 모두 찾아서, 하나씩 변경한다.
    - 3 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;매개변수 객체 만들기 
    - 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.
    - 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다.
    - 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을 다시 그릴 수도 있다. 
    - 1 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
    - 2 테스트한다.
    - 3 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
    - 4 테스트한다.
    - 5 함수 호출시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
    - 6 기존 매개변수를 사용하더 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
    - 7 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;여기서 부터 어려움&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;여러함수를 클래스로 묶기
    - 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. 
    - 1 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
    - 2 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
    - 3 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;여러 함수를 변환 함수로 묶기
    - 정보가 사용되는 곳마다 같은 도출 로직이 반복되기도 한다. 나는 이런 도출 작업들을 한데로 모아두길 좋아한다. 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
    - 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 났다. 변환 함수로 묵으면 가공한 데이터를 새로운 레코드에 저장하므로 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.
    - 1 변환할 레코드를 입력 받아서 값을 그래도 반환하는 변환 함수를 만든다.
    - 2 묶을 함수 중 함수 하나를 콜라서 본문 코드를 변환 함수로 옮기고 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
    - 3 테스트한다.
    - 4 나머지 관련 함수도 위 과정에 따라 처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단계 쪼개기
    - 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다. 
    - 1 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
    - 2 테스트한다.
    - 3 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
    - 4 테스트한다.
    - 5 추출한 두 번째 단계 함수의 매개변수를 하나씩 컴토한다.그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
    - 6 첫 번째 단계 코드를 함수로 추출 하면서 중간 데이터 구조를 반환하도록 만든다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/10/refactoring-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/10/refactoring-3/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>면접 질문 &amp; 나의 프로젝트 간단 요약</title>
        <description>&lt;h2 id=&quot;예상-질문&quot;&gt;예상 질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;1분 자기소개&lt;/dt&gt;
      &lt;dd&gt;안녕하세요 클린코드를 지향하는 지원자 떙떙떙입니다.  &lt;br /&gt;
학부시절 7개의 프로젝트 경험이 있습니다. 프로젝트를 통해 CS를 학습하였다고 생각합니다. 그때 작성한 코드는 스파게티 코드였다고 생각이 됩니다. 왜냐하면 코드의 가독성이 없었기 때문입니다. 하지만 지금은 리팩터링에 관심 많고 이해하기 쉬운코드, 효율적인 코드 작성을 노력중입니다.  &lt;br /&gt;
이런 노력을 통해 앞으로는 백엔드 개발자로 전문성을 키우고 싶습니다.  &lt;br /&gt;
전문성을 키우고자 spring,docker,git,DB 등을 학습하고 블로그에 기록하고 있습니다. &lt;br /&gt;
싸피를 통해 효율적인 코드, 협업, 전문성을 키우고 싶은 0년차 백엔드 주니어입니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;가장 자신있어 하는 것은 무엇인가요?&lt;/dt&gt;
      &lt;dd&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;관심 있는 IT 동향은 무엇인가요?&lt;/dt&gt;
      &lt;dd&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;본인의 장점과 단점&lt;/dt&gt;
      &lt;dd&gt;쉽게 포기 하지 않는 장점이 있다고 생각합니다. 프로젝트를 진행하면 항상 밤을 새는 경우가 많았습니다. 하고싶은게 많은데 잘 안 되었기 때문에 밤새 몰두하는 경우가 많았습니다. 사소한 기능이라도 끝끝내 구현에 이르면 개발에 재미를 느끼곤 했습니다. 이런 경험의해서 저는 끈기가 있다고 생각합니다.&lt;/dd&gt;
      &lt;dd&gt;단점은 하나에 깊게 파고들다 보면 주변을 보지 못하는 단점이 있습니다. 밤새도록 코드작성 및 레퍼런스 검색을 하다보면 다른것에 집중하지 못 할때가 많았습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;지원동기&lt;/dt&gt;
      &lt;dd&gt;문제해결을 위한 알고리즘 , 진정한 협업을 경험하고자 지원하게 되었습니다.  &lt;br /&gt;
저는 학부시절 7개의 프로젝트를 진행하였는데 그중 5개를 같은 팀원과 진행하였습니다. sns로 버전관리, 주먹구구식 소통 등의 협업을 경험하였습니다. 그당시의 협업은 현재 제가 하고싶은 협업은 아니였다 라는 생각이 듭니다.  &lt;br /&gt;
저는 싸피에서 코드리뷰, git flow,pull request, CICD, 등 다양한 방법을 통해서 제대로 된 협업을 경험하고 싶습니다.  &lt;br /&gt;
이런 과정 중에 효율적 알고리즘에 의한 더빠른 , 더 이해하기 쉬운 코드를 작성방법을 배우고 싶습니다.  &lt;br /&gt;
알고리즘과 협업을 학습하고 경험하고 싶어 지원하게 되었습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;마지막으로 하고싶은말&lt;/dt&gt;
      &lt;dd&gt;사피 설명회 통해서 코드리뷰가 진행됨을 알고있습니다. 이외에도 싸피 동기간 개발서적 스터디, 짝프로래밍등 다양한 IT문화를 경험할 수 있는 시스템이 있는지 궁금합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;어려움을 해결한 경험&lt;/dt&gt;
      &lt;dd&gt;&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;동료와의 갈등 , 해결 경험&lt;/dt&gt;
      &lt;dd&gt;c로 keyvalueStore 구현해야했습니다. 4학년과 팀이 되었고 제가 너무 프로그래밍 능력이 부족하다고 핀잔을 주었습니다. 맞는말이지만 기분은 좋지 않았습니다. 
그렇다고 여기서 제가 아무것도 안할수는 없기에 오히려 더 열심히 자료구조를 공부하고 i/o는 어떻게 받을지 준비를 많이 해갔습니다. 
팀원이 저의 정성을 보았나 제가 부족한 부분을 많이 알려주었고 둘 사이의 갈등 또한 사라졌습니다. 
플젝이 끝난뒤에 저는 내가 이런상황에서 팀원처럼 해야겠다는 다짐을 하였습니다. 정말 거의 모든걸 알려주었는데 저또한 열심히 배우려고 하였습니다. 
비트리와 해쉬를 사용하여 키밸류스토어를 구현할수있었고 좋은 프로젝트 결과를 얻을수있었습니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;전공자인 내가 싸피를 교육이수의 메리트는 ? (나는 협업, 알고리즘)&lt;/dt&gt;
      &lt;dd&gt;저는 알고리즘, 협업능력이 부족하다고 생각됩니다. 또한 이것들은 제가 잘하고 싶은 영역입니다. &lt;br /&gt;
싸피를 통해 알고리즘,협업능력을 키울수있다고 알려져있습니다. 물론 혼자서도 할수있지만 싸피에서의 피드백을 받고 싶습니다. 멘토의 피드백, 동기의 피드백 이러한 IT문화를 경험하고 싶습니다. 또한 제가 아는것은 다 알려주고 싶습니다. 
이런 과정을 통해서 제가 성장 할 수 있다고 생각하기 떄문에 전공자인 제가 싸피를 이수하고 싶은 이유입니다.&lt;/dd&gt;
      &lt;dd&gt;
        &lt;p&gt;저는 학부시절 협업의 기회를 날렸습니다. sns를 통한 주먹구구식의 개발을 진행 하였습니다. 
저는 싸피를 통해서 협업의 기회, 동료를 얻고 싶습니다. 
피드백을 주고 받는 동료!! 이러한 IT문화를 경험함으로서 저의 개발ㅁ역량을 늘리고 싶습니다. 
이러한 이유로 싸피는 전공자인 제가 놓쳤던 기회를 다시 잡는 시간이라고 생각하며 싸피 지원한 이유입니다.&lt;/p&gt;
      &lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;취업해서 배우는게 더 나은거 아니야 ?
협업을 경험하고 싶습니다. 커뮤니트를 통해서도 구하였지만, 결속력이 많이 부족하였습니다. 그래서 싸피를 통해 동료를 얻고 싶습니다. &lt;br /&gt;
알고리즘,협업의 중요성이 강조되고 있습니다. 저는 이러한 부분이 약하고 더욱 학습하고 싶습니다. 그렇기에 싸피를 통해서 더 배우고 싶습니다. 실무수준의 협업을 배우고 싶습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;자신만의 경쟁력&lt;/dt&gt;
      &lt;dd&gt;도전의식이 저의 경쟁력이라고 생각합니다. 안될걸 아는데 도전합니다. 한번에 안되겠지만 여러번 도전하다보면 언젠간 될거라는 믿음이 있습니다. 이러한 마인가 저의 경쟁력이라고 생각합니다. 
이는 꾸준함이 될수도 있겠고, 논리적인 사고능력이 될수도 있으리라 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;인상깊게 들은 과목&lt;/dt&gt;
      &lt;dd&gt;운영체제가 인상 깊었습니다. 컴퓨터가 동작하는 과정을 학습하기 때문이고 cli를 직접적으로 사용하기 때문에 당시에 인상깊었습니다. 
현재 인상깊은 과목을 선택하여도 역시 운영체제입니다. 운영체제에서 학습한 스케줄링, 운영체제 구성 내용등이 결국 응용소프트웨어에서도 사용되기 때문입니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;좋아하는 일과 잘하는 일중 선택해야한다면 무엇을?&lt;/dt&gt;
      &lt;dd&gt;잘하는일 선택해야합니다. 회사의 이익이든 본인의 이익이든 일을 통해 생산적인 결과물을 나타내야 하기 때문입니다. 좋아하는 일이라는 것은 저의 이익으로 대변되는 부분이고 이것은 개인시간을 이용해서 활용해야 한다고 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;대인관계에 관한 질문&lt;/dt&gt;
      &lt;dd&gt;저의 좋은게 좋은거다 라는 마인드로 대인관계를 유지합니다. 그리고 경청의 중요성을 알고있습니다. 하지만 프로젝트등의 목적이 분명한 경우 명확한 요구를 요하는 스타일 입니다. &lt;br /&gt;
질문을 할때에 상대의 시간을 위해 스스로 최대한 알아보고 이러한 시도를 했다고 알린 뒤 질문을 하곤 합니다. 
대인관계가 나빠지면 이는 상대와 본인 둘 다 문제가 존재한다고 생각합니다. 본인의 잘못을 인지하는 과정이 필요하며 이를 상대방과 공유할수 있어야 할 것으로 생각합니다.&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;창의력을 발휘한 경험은 ?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;지원자는 리더형인가 팔로워형인가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;어떠한 개발자가 되고 싶나요&lt;/li&gt;
  &lt;li&gt;자소서 기반으로 어떻게 진행되었는지&lt;/li&gt;
  &lt;li&gt;알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;피티 면접 &lt;br /&gt;
AI, 빅데이터(4차산업혁명) 를 적용해서 어떻게 응용을 할수있겠는가?&lt;/p&gt;

&lt;p&gt;같은 프로세스 다른 디비
상품목록을 레디스와같은 저장소에 캐싱하고  쿼리 모델을 레디스를 사용하는 방식이죠
명령이 데이터를 변경하면 변경내역을 쿼리쪽 디비에 전달하게 됩니다.&lt;/p&gt;

&lt;p&gt;다른 다른
명령이 데이터에 변경하면 이 내역을 쿼리쪽에 전달해야합니다. 
MSA에서 사용하는 방식입니다.&lt;/p&gt;

&lt;p&gt;전달방법
1 명령이 직접 쿼리디비를 수정하는 방식이에요.
  카프카 같은 메시징을 이용해서 전달하는 방법도 있습니다. 
  이방법은 데이터 유실 가능성이 존재합니다. 
  문제가 발생하게되면 쿼리디비에 반영해야할 데이터가 유실될수있다.
  쿼리디비나 메세징의 문제때문에 명령을 수행하는것 자체가 에러가 날수있다.&lt;/p&gt;

&lt;p&gt;2 두번째는 명령디비에 기록하고 별도의 전파기를 통해서 쿼리디비에 전달하는 방식이에요
  일단 명령을 상태를 변경한 다음에 뭘 바꿨는지 별도의 테이블에 기록을 합니다. 이과정은 한 트랜잭션으로 처리되기 떄문에 데이터가 유실되지 않는 장점이 있다. 
  이때 전파기를 따로 구현해야하는 단점이 존재하다.&lt;/p&gt;

&lt;p&gt;3 디비가 제공하는 CDC를 사용하는 방법입니다. 
  예를 들면 디비의 바이너리 로그를 읽어서 변경데이터를 확인하고 이를 쿼리쪽에 전달하는 방식이다. 
  명령쪽 코드에서 변경내역을 따로 저장하지 않아도 되니깐 명령코드가 단순해지는 장점이 존재합니다.&lt;/p&gt;

&lt;p&gt;주의할점
  데이터 유실 : 유실 허용여부에 따라 DB트랜잭션 범위가 중요
  허용가능 지연 시간 : 명령의 반영내역을 얼마나 빨리 반영해야하는가 등의 허용가능한 지연시간이 존재하고 이를 고려해야한다.
  중복전달 : 유실을 고려해서 다시전달 할 수 있는 방법을 만들게 되면 쿼리쪽에 이미 반영된 데이터를 중복으로 전달한 경우도 발생하게 될것이다. 이때 쿼리쪽 데이터가 망가지지 않도록 별도의 처리를 해야합니다.&lt;/p&gt;

&lt;p&gt;이외에도 다른 주의사항도 존재합니다.&lt;/p&gt;

&lt;p&gt;정리 cqrs는 명령 역할을 수행하는 구성요소와 쿼리 역할을 수행하는 구성요소를 나누는것을 cqrs라고 함
왜하냐?
     1 명령과 쿼리는 다루는 데이터가 다름 
     2 명령과 쿼리는 코드 변경 빈도/사용자가 다름
     3 기능 마다 성능 요구가 다름&lt;/p&gt;

&lt;h2 id=&quot;카프카-분산-이벤트-스트리밍-플랫폼---하이포퍼먼스&quot;&gt;카프카 (분산 이벤트 스트리밍 플랫폼 - 하이포퍼먼스)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;카프카 클러스터 : 메시지를 저장하는 저장소이다. 하나의 카프카 클러스터는 여러개의 브로커로 구성된다.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;브로커는 각각의 서버라고 생각하면 된다.&lt;/li&gt;
      &lt;li&gt;브로커들이 메세지를 나눠서 처리하고 이중화도 하고, 장애 대체의 역할을 수행한다.
      - 주키퍼클러스터 (앙상블) : 카프카 클러스터를 관리한다. 주키퍼속에 카프카 클러스터의 정보과 관리된다. 
      - 프로듀서 : 카프카에 메세지를 넣는 역할을 한다. 
      - 컨슈머 : 메시지를 카프카에서 읽음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;토픽과 파티션
    &lt;ul&gt;
      &lt;li&gt;토픽 : 메시지를 구반하는 단위 ex) 뉴스용 토픽, 메일토픽 … 즉 파일시스템의 폴더와 유사&lt;/li&gt;
      &lt;li&gt;한 개의 토픽은 한개 이상의 파티션으로 구성&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;파티션은 메시지를 저장하는 물리적인 파일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;파티션 : 추가만 가능한 파일(append-only)
    &lt;ul&gt;
      &lt;li&gt;각 메시지 저장 위치를 오프셋 이라고 함&lt;/li&gt;
      &lt;li&gt;프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가&lt;/li&gt;
      &lt;li&gt;컨슈머는 오프셋 기준으로 메시지를 순서대로 읽음&lt;/li&gt;
      &lt;li&gt;메시지는 삭제되지 않음(설정에 따라 일정 시간이 지난뒤 삭제)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 파티션과 프로듀서&lt;/li&gt;
  &lt;li&gt;프로듀서는 라운드로빈 또는 키로 파티션 선택&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;같은키를 갖는 메시지는 같은 파티션에 저장 -&amp;gt; 같은 키는 순서 유지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 파티션과 컨슈머
    &lt;ul&gt;
      &lt;li&gt;컨슈머는 컨슈머그룹에 속함&lt;/li&gt;
      &lt;li&gt;한개 파티션은 컨슈머그룹의 한 개 컨슈머만 연결가능
        &lt;ul&gt;
          &lt;li&gt;즉 컨슈머그훕에 속한 컨슈머들은 한 파티션을 공유할 수 없음&lt;/li&gt;
          &lt;li&gt;한 컨슈머그룹 기준으로 파티션의 메시지는 순서대로 처리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;파티션 파일은 os 페이지 캐시 사용&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;파티션에 대한 파일 IO를 메모리에서 처리&lt;/li&gt;
      &lt;li&gt;서버에서 페이지캐시를 카프카만 사용해야 성능에 유리
      - Zero Copy&lt;/li&gt;
      &lt;li&gt;디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
      - 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순&lt;/li&gt;
      &lt;li&gt;메시지 필터, 메시지 재전송과 같은 일은 브로커가 하지 않음
        &lt;ul&gt;
          &lt;li&gt;프로듀서,컨슈머가 직접 해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;브로커는 컨슈머와 파티션 간 매핑 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;묶어서 보내기, 묶어서 받기 (batch)
    &lt;ul&gt;
      &lt;li&gt;프로듀서 : 일정 크기만큼 메시지를 모아서 전송가능&lt;/li&gt;
      &lt;li&gt;컨슈머: 최소 크기만큼 메시지를 모아서 조회 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;낱개 처리보다 처리량 증가&lt;/li&gt;
  &lt;li&gt;처리량 증대(확장)가 쉬움
    &lt;ul&gt;
      &lt;li&gt;1개 장비의 용량 한계 -&amp;gt; 브로커 추카, 파티션 추카&lt;/li&gt;
      &lt;li&gt;컨슈머가 느림 -&amp;gt;컨슈머 추가(+파티션 추가)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리플리카 : 파티션의 복제본
    &lt;ul&gt;
      &lt;li&gt;복제수(replication factor) 만큼 파티션의 복제본이 각 브로커에 생김&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리더와 팔로워 구성
    &lt;ul&gt;
      &lt;li&gt;프로듀서와 컨슈머는 리더를 통해서만 메시지 처리&lt;/li&gt;
      &lt;li&gt;팔로워는 리더로부터 복제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장애 대응
    &lt;ul&gt;
      &lt;li&gt;리더가 속한 브로커 장애시 다른 팔로워가 리더가 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프로듀서
    &lt;ul&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;프로그래밍-초식&quot;&gt;프로그래밍 초식&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;변수아끼끼 : 의미를 더해주는 변수 위주로 사용하기 (식이 복잡하거나 길어지 ㄹ경우 변수 이름으로 설명)
    &lt;ul&gt;
      &lt;li&gt;가능한 선언과 값 할당을 한번에 하자&lt;/li&gt;
      &lt;li&gt;최대한(절대로) 변수의 용도/의미 변경 X : 의미나 용도가 다르면 다른 변수 사용할것 (이러면 개발자들이 코드를 이해가 어려워진다. )&lt;/li&gt;
      &lt;li&gt;변수가 사용되는 코드 범위를 최소화하기 ex) forloop만을 위한 코드를 작성하라
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; for(Some some : somes){
     String msg = some.getName() + ~~
 }

 =====================

 .... (코드 10줄)
 String msg = ...;
 return Result.message(msg);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; - 변수를 아끼는 연습하기 
 - 중요한 코드의 복잡도를 낮추고 가독성을 높이는 쉬우 방법 -&amp;gt; 변수 아끼고 변경 줄이고 범위 좁히고 
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나누기
    &lt;ul&gt;
      &lt;li&gt;구현기술을 여러 기본기 하나이다.&lt;/li&gt;
      &lt;li&gt;초짜 특징 중 하나 : 점점 커지는 함수/메서드/클래스&lt;/li&gt;
      &lt;li&gt;너무 커지면 프로그램 분석이 어려워짐(수정이 어려워짐)&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;흔한 예:
        &lt;ul&gt;
          &lt;li&gt;if-else, if 중첩이 복잡해짐&lt;/li&gt;
          &lt;li&gt;변수의 의미가 중간에 바뀜&lt;/li&gt;
          &lt;li&gt;코드 안에서 중복이 발생함
            &lt;ul&gt;
              &lt;li&gt;의미가 있는 단위로 코드/구성 요소를 나누는 기술 : 나누기&lt;/li&gt;
              &lt;li&gt;패턴은 전형적인 예&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;웹개발 : 컨트롤러 - 서비스 - DAO&lt;/li&gt;
      &lt;li&gt;DDD : 엔티티, 밸류, 리포지토리&lt;/li&gt;
      &lt;li&gt;디자인 패턴: 빌더, 어댑터, 컴포지트 등
      - 나누기는 곧 기능 분해/분리 : 기능은 여러 작은 기능/로직(하위 기능)으로 구성
      - 나눈 하위 기능을 메서드나 클래스로 분리 : 나누기의 결과
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; OrderRepository : DB에서 주문 데이터 읽기, DB에서 변경데이터 쓰기
 Order : 주문 취소 가능여부 확인, 주문데이터 변경
 OrderCancelService : 취소 처리 흐름제어 
 Notifier : 취소 결과 통지 
 PayCancelService : 결제 취소
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - 나누기는 역할/책임 도출 인것이다. 
  - 어떤 기준으로 나누나? : 정답은 없음 하지만 보통은 기능에서 의미가 있는 하위 기능 단위로 나누는 시도를 추천
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;주문취소 기능 : 취소의 입장에서 의미있는 단위
        &lt;ul&gt;
          &lt;li&gt;취소 사싱 통지 vs push 테이블에 insert&lt;/li&gt;
          &lt;li&gt;결제 승인 취소 vs pg사가 제공하는 API 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대칭성 활용의 측면
        &lt;ul&gt;
          &lt;li&gt;취소는 취소끼리 비슷한 기능끼리 나눈다. (코드간의 수준을 맞춘다.)
    - 나눈결과&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;나누기를 안하면
        &lt;ul&gt;
          &lt;li&gt;코드 순서대로 구현을 이해하는 것이 가능&lt;/li&gt;
          &lt;li&gt;근데 코드가 커질수록 코드가 복잡해져서 점점 이해하기 어려워짐&lt;/li&gt;
          &lt;li&gt;코드가 커질수록 변경도 어려워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;나누기를 잘하면
        &lt;ul&gt;
          &lt;li&gt;구조의 복잡도가 증가하지만 상위 수준에서 실행 흐름 이해하기 좋음&lt;/li&gt;
          &lt;li&gt;코드 변경이 (나누기 전보다 ) 쉬워질 가능성이 높아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;너무 잘게 나누면
        &lt;ul&gt;
          &lt;li&gt;너무 복잡해져서 실행 흐름을 이해하기 어려워짐&lt;/li&gt;
          &lt;li&gt;변경할 떄 수정 대상이 많아져 변경이 어려워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WHAT,HOW
    &lt;ul&gt;
      &lt;li&gt;하려는것/의미/의도(WHAT) - 그것의 실제 구현(HOW)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;what&lt;/th&gt;
          &lt;th&gt;how&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;가입한지 1년 미만&lt;/td&gt;
          &lt;td&gt;user 테이블에서 reg칼럼 값 기준으로 count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;추가 지급 내역 남김&lt;/td&gt;
          &lt;td&gt;log 테이블에 insert&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;의미가 들어나게 생각해보고 이를 코드로 만드는 연습을 해라 !&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int addPointRate = 0;
 if(userRegistedLessThanOneYear(userId)){
     addPointRate = 1;
 }
 ...
 if(addPointRate &amp;gt; 0){
     recordAddPointHistory(userId,addPointRate);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;what 최대한 드러나게 생각을 하자(슈도코드 등등) -&amp;gt; 그리고 실제로 코드상에서 어떻게 이를 적용할지 생각한다(의도가 드러나게 !)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;WHAT,HOW 분리 결과
    &lt;ul&gt;
      &lt;li&gt;구현을 잠시 잊고 실제 하려는 것이 무엇인지 생각하게 됨
        &lt;ul&gt;
          &lt;li&gt;실제 하려는 것이 코드에 표현될 가능성이 높아짐&lt;/li&gt;
          &lt;li&gt;코드의 가독성이 향상&lt;/li&gt;
          &lt;li&gt;유지보수성이 좋아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;물론 구현 제약등의 이유로 표현력이 떨어질 경우도 존재함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평소에 의식의 흐름대로 막 구현만 하면 안됨
    &lt;ul&gt;
      &lt;li&gt;의미/의도가 드러나는 코드를 작성하도록 노력해야함&lt;/li&gt;
      &lt;li&gt;연차가 쌓인다고 절로 늘지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분 우리나라에서 잘안쓰는 경우를 덜 유용하다고 느낄수있스니다. 지도나 애플페이를 쓸수있다고 한다라더 한국매출이 그렇게 작은 편이 아니에요 사파리 디자인이 많이 바꼈어요 왜 쓸만하지 잠깐만 나쁘지않아 이렇게 인터페이스가 바꼈어요 이걸 쑉하면 탭 그룹이 생겨서 묶어서 관리할수 아이플러스라는게 생겼어요 비공게&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid!&quot;&gt;graph LR
A[Square Rect] -- Link text --&amp;gt; B((Circle))
A --&amp;gt; C(Round Rect)
B --&amp;gt; D{ 마름모 }
C --&amp;gt; D
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 07 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/06/07/interview-question/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/06/07/interview-question/</guid>
        
        <category>interview</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>mysql on Docker with centos - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;mySQL on Docker&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;proxylayer&quot;&gt;proxyLayer&lt;/h2&gt;

&lt;p&gt;구성한 master/slave 구조에서 마스터에 문제 발생시 오케스트라를 이용해서 slave1을 마스터로 올리고 하위 slave를 새로운 마스터에 붙일수있다.&lt;/p&gt;

&lt;p&gt;오케스트라를 통해서 자동으로 failOver가 발생하고 이를 처리한다.&lt;/p&gt;

&lt;p&gt;하지만 오케스트라에서 failover가 진행되지만 클라이언트의 request를 자동으로 처리하지는 않는다.&lt;/p&gt;

&lt;p&gt;그렇다면 문제 발생시에 오케스트라에서 failover를 처리해주지만 클라이언트 단의 request를 새로운 마스터로 자동으로 처리해주는 것은 무엇이 있을까??&lt;/p&gt;

&lt;p&gt;이는 바로 proxyLayer 구성하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/proxysql/data /db/proxysql/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/proxysql /db/proxysql/data /db/proxysql/conf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;권한설정 및 필요한 디렉터리를 만든다. &lt;br /&gt;
  proxysql/conf로 이동하여서 proxysql.conf를 생성한다.&lt;/p&gt;

&lt;p&gt;proxysql.cnf 파일 설정&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    datadir=&quot;/var/lib/proxysql&quot;
    admin_variables=
    {
    admin_credentials=&quot;admin:admin;radmin:radmin&quot;
    mysql_ifaces=&quot;0.0.0.0:6032&quot;
    }
    mysql_variables=
    {
    threads=4
    max_connections=2048
    default_query_delay=0
    default_query_timeout=36000000
    have_compress=true
    poll_timeout=2000
    interfaces=&quot;0.0.0.0:6033&quot;
    default_schema=&quot;information_schema&quot;
    stacksize=1048576
    server_version=&quot;5.5.30&quot;
    connect_timeout_server=3000

    ^G Get He^O WriteO^R Read F^Y Prev P^K Cut Te^C Cur Pos
    GNU nano 2.0.6     File: proxysql.cnf

    connect_timeout_server=3000
    monitor_username=&quot;monitor&quot;
    monitor_password=&quot;monitor&quot;
    monitor_history=600000
    monitor_connect_interval=60000
    monitor_ping_interval=10000
    monitor_read_only_interval=1500
    monitor_read_only_timeout=500
    ping_interval_server_msec=120000
    ping_timeout_server=500
    commands_stats=true
    sessions_sort=true
    connect_retries_on_failure=10
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;docker container생성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name proxysql -h proxysql –net mybridge –net-alias=proxysql -p 16032:6032 -p 16033:6033 -v /db/proxysql/data:/var/lib/proxysql -v /db/proxysql/conf/proxysql.cnf:/etc/proxysql.cnf -d proxysql/proxysql&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql -h127.0.0.1 -P16032 -uradmin -pradmin –prompt “ProxySQL admin” : 로그인 하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proxysql-test&quot;&gt;proxysql test&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;db0001에 테스트용 디비를 생성한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create database testdb default character set utf8;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;어플리케이션에서 사용할 유저를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create user appuser@’%’ identified by ‘apppass’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;testdb에 읽고 쓸 수 있도록 권한을 준다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;grant select, insert, update, delete on testdb.* to appuser@’%’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;프록시 시퀄에서 사용할 유저를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;create user  ‘monitor’@’%’ identified by ‘monitor’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;프록시 시퀄에서 사용할 권한을 준다.&lt;/li&gt;
  &lt;li&gt;grant REplication client on &lt;em&gt;.&lt;/em&gt; to ‘monitor’@’%’;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flush privileges;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;proxysql서버에 로그인하여 각각의 replication을 등록해준다.&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(10,’db001’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db001’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db002’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_servers(hostgroup_id, hostname, port) values(20,’db003’,3306);&lt;/li&gt;
  &lt;li&gt;insert into mysql_replication_hostgroups values(10,20,’read_only’,’’);&lt;/li&gt;
  &lt;li&gt;load mysql servers to runtime;&lt;/li&gt;
  &lt;li&gt;save mysql servers to disk;&lt;/li&gt;
  &lt;li&gt;insert into mysql_users(username,password,default_hostgroup,transaction_persistent) values (‘appuser’,’apppass’,10,0);&lt;/li&gt;
  &lt;li&gt;LOAD MYSQL USERS TO RUNTIME;&lt;/li&gt;
  &lt;li&gt;SAVE MYSQL USERS TO DISK;&lt;/li&gt;
  &lt;li&gt;insert into mysql_query_rules(rule_id,active,match_pattern,destination_hostgroup) values (1,1,’^SELECT.*FOR UPDATE$’,10);&lt;/li&gt;
  &lt;li&gt;insert into mysql_query_rules(rule_id,active,match_pattern,destination_hostgroup) values (2,1,’^SELECT’,20);&lt;/li&gt;
  &lt;li&gt;load mysql QUERY RULES to runtime;&lt;/li&gt;
  &lt;li&gt;save mysql QUERY RULES to disk;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;insert test&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker exec -it -uroot db001 /bin/bash&lt;/li&gt;
  &lt;li&gt;use testdb;&lt;/li&gt;
  &lt;li&gt;create table insert_test(hostname varchar(5) not null, insert_time datetime not null);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;insert test shall&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;k&quot;&gt;do

    &lt;/span&gt;mysql -uappuser -papppass -h172.31.10.19 -P16033 -N -e &lt;span class=&quot;s2&quot;&gt;&quot;insert into testdb.insert_test select @@hostname,now()&quot;&lt;/span&gt; 2&amp;gt;&amp;amp;1| grep -v &lt;span class=&quot;s2&quot;&gt;&quot;Warning&quot;&lt;/span&gt;

    sleep 1

    &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;truncate table testdb.insert_test;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모니터링-mysql&quot;&gt;모니터링 (mysql)&lt;/h2&gt;

&lt;p&gt;prometheus통해서 모니터링을 진행하고  grafana를 통해서 대시보드로 시각화 한다.&lt;/p&gt;

&lt;p&gt;prometheus로 모니터링 항목 수집을 위해 exporter가 존재해야한다.&lt;/p&gt;

&lt;p&gt;prometheus가 풀형태로 진행한다.&lt;/p&gt;

&lt;p&gt;exporter를 어떻게 만들어야할까요? 도커이미지를 직접 만들거나 또는 만들어진 도커 파일을 찾아야한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;도커 이미지를 직접 만들것입니다. &lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Dokerfile
    Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm
    Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm
    mysqld_exporter-0.12.1.linux-amd64.tar.gz
    node_exporter-1.0.1.linux-amd64.tar.gz
    ps-entry.sh
    start_mysqld_exporter.sh
    start_node_exporter.sh
    ```   
    파일이 하나의 폴더에 필요하다.   
    docker build -t mysql57:0.0 ./ : 명령어를 통해서 도커이미지를 만들수있다. 



    ```
    FROM centos:7
    COPY [&quot;Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm&quot;,\
        &quot;Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm&quot;, \
        &quot;node_exporter-1.0.1.linux-amd64.tar.gz&quot;, \
        &quot;mysqld_exporter-0.12.1.linux-amd64.tar.gz&quot;, \
        &quot;start_node_exporter.sh&quot;, \
        &quot;start_mysqld_exporter.sh&quot;, \
        &quot;.my.cnf&quot;,&quot;/tmp/&quot;]
    USER root
    RUN groupadd -g 1001 mysql
    RUN useradd -u 1001 -r -g 1001 mysql
    RUN yum install -y perl.x86_64 \
        libaio.x86_64 \
        numactl-libs.x86_64 \
        net-tools.x86_64 \
        sudo.x86_64 \
        openssl.x86_64
    WORKDIR /tmp/
    RUN rpm -ivh Percona-Server-shared-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-shared-compat-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-client-57-5.7.30-33.1.el7.x86_64.rpm \
        Percona-Server-server-57-5.7.30-33.1.el7.x86_64.rpm
    RUN mkdir -p /opt/exporters/ &amp;amp;&amp;amp; \
        tar -xzvf ./node_exporter-1.0.1.linux-amd64.tar.gz -C /opt/exporters &amp;amp;&amp;amp; \
        tar -xzvf ./mysqld_exporter-0.12.1.linux-amd64.tar.gz -C /opt/exporters
    WORKDIR /opt/exporters/
    RUN mv node_exporter-1.0.1.linux-amd64 node_exporter &amp;amp;&amp;amp; \
        mv mysqld_exporter-0.12.1.linux-amd64 mysqld_exporter &amp;amp;&amp;amp; \
        mv /tmp/start_node_exporter.sh /opt/exporters/node_exporter/ &amp;amp;&amp;amp; \
        mv /tmp/start_mysqld_exporter.sh /opt/exporters/mysqld_exporter/ &amp;amp;&amp;amp; \
        mv /tmp/.my.cnf /opt/exporters/mysqld_exporter/ &amp;amp;&amp;amp; \
        chmod o+x /opt/exporters/node_exporter/start_node_exporter.sh &amp;amp;&amp;amp; \
        chmod o+x /opt/exporters/mysqld_exporter/start_mysqld_exporter.sh &amp;amp;&amp;amp; \
        rm -rf /tmp/*.rpm &amp;amp;&amp;amp; \
        /usr/bin/install -m 0775 -o mysql -g mysql -d /var/lib/mysql \
        /var/run/mysqld /docker-entrypoint-initdb.d
    VOLUME [&quot;/var/lib/mysql&quot;, &quot;/var/log/mysql&quot;,&quot;/etc/percona-server.conf.d&quot;]
    COPY ps-entry.sh /tmp/docker-entrypoint.sh
    RUN chmod +x /tmp/docker-entrypoint.sh
    ENTRYPOINT [&quot;/tmp/docker-entrypoint.sh&quot;]
    USER mysql
    EXPOSE 3306
    CMD [&quot;mysqld&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;도커파일은 다음과 같이 구성되어있다. &lt;br /&gt;
  상세한 분석은 다음시간에 알아보자&lt;/p&gt;

&lt;p&gt;생성한 도커 이미지를 컨테이너로 만들어보자&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name mydb -e MYSQL_ROOT_PASSWORD=”root” -d mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접속&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec -it -uroot mydb /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;도커파일-기반-mysql-masterslave-prometheus-구성&quot;&gt;도커파일 기반 mysql (master,slave prometheus 구성)&lt;/h2&gt;

&lt;p&gt;우선 기존의 도커 컨테이너를 모두 삭제한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker stop mydb db001 db002 db003&lt;/li&gt;
  &lt;li&gt;docker rm mydb db001 db002 db003&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mysql 그룹과 유저를 각각 생성 해준다. 그리고 chown을 통해서 오너를 변경한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;groupadd -g 1001 mysql&lt;/li&gt;
  &lt;li&gt;useradd -u 1001 -r -g 1001 mysql&lt;/li&gt;
  &lt;li&gt;chown -R mysql:mysql /db/db001 /db/db002 /db/db003&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;새로운 도커 컨테이너 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name db003 -h db003 -p 3308:3306 –net mybridge –net-alias=db003 -v /db/db003/data:/var/lib/mysql -v /db/db003/log:/var/log/mysql -v /db/db003/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;같은 방법으로 002,003 도 실행&lt;/p&gt;

&lt;p&gt;프로메테우스 설정을 위한 디렉터리 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/prom001 /db/prom001/data /db/prom001/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/prom001 /db/prom001/data /db/prom001/conf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/db/prom001/conf에 promethus.yml 설정파일 만들었다.&lt;/p&gt;

&lt;p&gt;promethus 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name prom001 -h prom001 –net mybridge –net-alias=prom001 -p 9090:9090 -v /db/prom001/data:/data -v /db/prom001/conf:/etc/prometheus -d prom/prometheus-linux-amd64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;promethus를 이용할 유저 생성 (db001)에서 생성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create user ‘exporter’@’localhost’ identified by ‘exporter123’ WITH MAX_USER_CONNECTIONS 3;&lt;/li&gt;
  &lt;li&gt;grant PROCESS, REPLICATION CLIENT, select on &lt;em&gt;.&lt;/em&gt; to ‘exporter’@’localhost’;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exporters 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec db001 sh /opt/exporters/node_exporter/start_node_exporter.sh&lt;/li&gt;
  &lt;li&gt;docker exec db001 sh /opt/exporters/mysqld_exporter/start_mysqld_exporter.sh&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;db001,db002,db003 모두 exporter를 실행한다. &lt;br /&gt;
  그러면 모니터링을 위한 exporter가 준비 완료 되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://{도커.ip}/graph 에서 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;그라파나-설정&quot;&gt;그라파나 설정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name grafana -h grafana -p 13000:3000 –net mybridge –net-alias=grafana -d grafana/grafana&lt;/li&gt;
  &lt;li&gt;http://{도커.ip}/13000 에 들어가서 직접 대시보드를 볼수있다.
    &lt;ul&gt;
      &lt;li&gt;id : admin , pwd : admin&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;grafana의 설정에서 prometheus를 설정할수있으며 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/percona/grafana-dashboards/blob/master/dashboards/MySQL_Overview.json&lt;/code&gt; 에서 json파일을 복사하여 웹상에서 import하면 유용하게 대시보드를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;doker-compose&quot;&gt;doker compose&lt;/h2&gt;

&lt;p&gt;여러 컨테이너를 한방에 배포하기&lt;/p&gt;

&lt;p&gt;도커 컴포즈 설치&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;curl -L “https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;권한 설정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;chmod +x /usr/local/bin/docker-compose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker-compose -v&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기존의 컨테이너 및 host의 data 공유 폴더 삭제&lt;/p&gt;

&lt;p&gt;도커 컴포즈를 이용한 여러 컨테이너 다움&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker-compose up -d&lt;/li&gt;
  &lt;li&gt;그후 shallscript를 이용해서 각각의 설정을 해줘야함 (유저생성, 권한 생성 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;scalability&quot;&gt;Scalability&lt;/h2&gt;

&lt;p&gt;도커 호스트에 리소스가 부족해지면 어떻게 해야할까??&lt;/p&gt;

&lt;p&gt;가장 쉽게 생각 할 수 있는것은 바로 scale up이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scale up  : 컴퓨터의 리소스를 업그레이드 시키는 방법 (cpu,ram)등을 더 높은 사양으로 교체한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리소스를 늘릴수 없다면 ??  scale out이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scale out : 비슷한 컴퓨터 리소스를 구성하여 확장하는 시스템이다. 물론 자동으로 확장되는것은 아니고 다양한 설정이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;도커에서는 도커Swarm을 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker Swarm : 여러대의 도커 호스트를 하나의 도커호스트처럼 사용 할 수 있게 해준다.&lt;/li&gt;
  &lt;li&gt;Swarm mode : 매니저,워커 노드로 구성된 docker culster이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker-hub에-custom-image-등록&quot;&gt;docker hub에 custom image 등록&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker login&lt;/li&gt;
  &lt;li&gt;docker tag mysql57:0.0 elyo9381/mysql57:0.0&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker push elyo9381/mysql57:0.0&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;docker service create –name db001 -hostname db001 -p 3306:3306 -mount type=bind,source=/db/db001/data,target=/var/lib/mysql -mount type=bind,source=/db/db001/log,target=/var/log/mysql -mount type=bind,source=/db/db001/conf,target=/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” –with-registry-auth elyo9381/mysql57:0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 docker service는 swarm mode시에 사용될 custom image를 허브에 올린 image를 사용하여 도커 런 한다.&lt;/p&gt;

&lt;p&gt;–with-registry-auth 는&lt;/p&gt;

&lt;h2 id=&quot;백업과-복구&quot;&gt;백업과 복구&lt;/h2&gt;

&lt;p&gt;swarm을 이용해서 복구를 진행할것인데 이는 swarm mode를 테스트 실습 해보고 스크랩 하겠다.&lt;/p&gt;

</description>
        <pubDate>Thu, 03 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/03/mysqlOnDocker-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/03/mysqlOnDocker-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>security batch</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spring-batch&quot;&gt;spring batch&lt;/h2&gt;

</description>
        <pubDate>Wed, 02 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/02/spring-batch-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/02/spring-batch-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;리팩터링-해야할-시기&quot;&gt;리팩터링 해야할 시기&lt;/h2&gt;

&lt;p&gt;저자는 리팩터링을 시행해야하는 시기를 정확하게 말해주지 않는다. 시작시기 및 종료시기는 숙련된 개발자의 직관이 정확하다고 말해주고 있다.&lt;/p&gt;

&lt;p&gt;나는 리팩터링은 사소한 일이라고 생각한다.&lt;br /&gt;
  설거지,방청소와 같은 개념으로 생각한다.&lt;/p&gt;

&lt;p&gt;리팩터링을 진행하면서 가장 처음 진행될 일은 기이한 이름 바꾸기 이다.&lt;/p&gt;

&lt;p&gt;네이밍 바꾸기, 함수추출하기, 클래스만들기 등 다양한 리팩터링 기법이 존재 할수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;리팩터링을-위한-테스트코드-작성&quot;&gt;리팩터링을 위한 테스트코드 작성&lt;/h2&gt;

</description>
        <pubDate>Tue, 01 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/01/refactoring-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/01/refactoring-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>mysql on Docker with centos - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;mySQL on Docker&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;container&quot;&gt;container&lt;/h2&gt;

&lt;p&gt;도커에서 mysql 실행&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -i -t –name db001 -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행된 컨테이너 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker ps&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컨테이너 접속(execute)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker exec -it db001 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mysql 접속&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mysql -uroot -p&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-i -t : container에 shell 로 접속해서 사용하기 위한 옵션 &lt;br /&gt;
  –name : container의 이름 &lt;br /&gt;
  -e:환경변수 세팅 &lt;br /&gt;
  -d: background mode로 container 실행&lt;/p&gt;

&lt;h2 id=&quot;외부에서-mysql-접속하기&quot;&gt;외부에서 mysql 접속하기&lt;/h2&gt;

&lt;p&gt;container 외부에서 Mysql접속하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/p&gt;

    &lt;p&gt;-p 옵셥을 통해서 포트를 설정할수있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mysql 접속하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mysql -uroot -p -h {docker_host_ip}
  &lt;!-- - mysql -uroot -p -h 172.31.2.88 --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 나는 percona-mysql을 사용하였다. 그러므로 이를 들어갈 클라이언트를 등록해야 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stateless VS Stateful&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;container는 언제든지 재 시작 될 수 있다.&lt;/li&gt;
  &lt;li&gt;Docker image만 있으면 언제든지 동일한 구성의 Container를 실행시킬 수 있다.&lt;/li&gt;
  &lt;li&gt;container가 삭제 후 재 생성되면 docker image 초기의 상태로 시작된다.&lt;/li&gt;
  &lt;li&gt;Web server처럼 특정 요청을 받아서 처리해주고 상태값이나 데이터를 갖지 않는 형태의 서비스에 적합 : Stateless&lt;/li&gt;
  &lt;li&gt;하지만, DB는 데이터를 저장.&lt;/li&gt;
  &lt;li&gt;MYSQL Container가 삭제되고 재생성되면 어떻게 될까 ? -&amp;gt; data loss발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;volume-설정&quot;&gt;Volume 설정&lt;/h2&gt;

&lt;p&gt;### &lt;strong&gt;&lt;em&gt;host와 볼륨 공유하기&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우리는 하나의 서버를 만들었고 이를 마스터로 사용할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/db001/data&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db001/log /db/db001/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db /db/db001 /db/db001/data&lt;/li&gt;
  &lt;li&gt;chmod -p /db/db001/log /db/db001/conf&lt;/li&gt;
  &lt;li&gt;docker run -i -t –name db003 -p 3308:3306 -v /db/db003/data:/var/lib/mysql -v /db/db003/log:/var/log/mysql -v /db/db003/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  create database testdb default character set=utf8;

  create table t1(id int not null);

  insert into t1 values(1),(2),(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;db-replication&quot;&gt;DB replication&lt;/h2&gt;

&lt;p&gt;슬레이브를 생성한다&lt;/p&gt;

&lt;p&gt;외부에서 접근가능하며 호스트에서 데이터공유가능하며 마스터와 데이터 복제를 진행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir -p /db/db002/data /db/db003/data&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db002 /db/db002/data&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db003 /db/db003/data&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db002/log /db/db002/conf&lt;/li&gt;
  &lt;li&gt;mkdir -p /db/db003/log /db/db003/conf&lt;/li&gt;
  &lt;li&gt;chmod 777 /db/db002/log /db/db002/conf&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chmod 777 /db/db003/log /db/db003/conf&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -h db001 -p 3306:3306 -v /db/db001/data:/var/lib/mysql -v /db/db001/log:/var/log/mysql -v /db/db001/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30 : mysql 만들기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;docker ps –format “table \t\t” : 내가 원하는 항목만 볼수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE USER 'rep1'@'%' IDENTIFIED BY 'rep1';

  GRANT REPLICATION SLAVE ON *.* TO 'rep1'@'%';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;마스터 컨테이너의 rep1유저 생성(MySQL)&lt;/p&gt;

&lt;p&gt;master container의 ip : 172.17.0.3&lt;/p&gt;

&lt;p&gt;그후에 db002 컨테이너의 mysql로 들어간다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CHANGE MASTER TO MASTER_HOST='172.17.0.3', MASTER_USER='rep1', MASTER_PASSWORD='rep1', MASTER_AUTO_POSITION=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;그후 start slave 명령어를 통해서 slave를 시작하고 show slave status\G 명령어를 통해서 잘 연결되었는지 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;브릿지-네트워크-구성&quot;&gt;브릿지 네트워크 구성&lt;/h2&gt;
&lt;p&gt;컨테이너는 언제든지 재 시작 될 수 있고 컨테이너가 재시작 되면 해당 컨테이너의 IP가 변경될수있습니다.&lt;/p&gt;

&lt;p&gt;MYSQL 의 Replication 설정이나 HA 설정에 IP를 사용하게 되면 컨테이너가 재 시작 될 경우 변경된 ip 때문에 replication이 깨질 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 방지하기 위해 Brige Network를 구성하고 net alias를 사용하여 ip변경에도 문제가 발생하지 않도록 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker network ls : 도커의 네트워크 list를 볼수있는 명령어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker network create –driver bridge mybridge : 브릿지 네트워크생성 명령어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name db001 -h db001 -p 3306:3306 –net mybridge –net-alias=db001 -v /db/db001/data:/var/lib/mysql -v /db/db001/log:/var/log/mysql -v /db/db001/conf:/etc/percona-server.conf.d -e MYSQL_ROOT_PASSWORD=”root” -d percona:5.7.30&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;orchestrator&quot;&gt;orchestrator&lt;/h2&gt;

&lt;p&gt;failOver가 발생했을때 처리하는 방법&lt;/p&gt;

&lt;p&gt;slave를 master로 올릴수 있다.&lt;/p&gt;

&lt;p&gt;오케스트레이터 컨테이너 실행하기&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;docker run -i -t –name orchestrator -h orchestrator –net mybridge –net-alias=orchestrator -p 3000:3000 -d openarkcode/orchestrator:latest&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker inspect –format ‘’ db001 : db001 컨테이너의 ip주소 확인&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;orchestrator를 사용할 유저생성 (in db001)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reate user orc_client_user@’172.%’ identified by’orc_client_password’;&lt;/li&gt;
  &lt;li&gt;grant super,process, replication slave, reload on &lt;em&gt;.&lt;/em&gt; to orc_client_user@’172.%’;&lt;/li&gt;
  &lt;li&gt;grant select on mysql.slave_master_info TO orc_client_user@’172.%’;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;publicIP:3000/web/cluster 로 들어가면 orchestrator의 웹이 나온다.&lt;/p&gt;

&lt;h2 id=&quot;hahigh-availability-test&quot;&gt;HA(High Availability test)&lt;/h2&gt;

&lt;p&gt;시나리오 1&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;db001이 정지되어 db002를 마스터로 올립니다.&lt;/li&gt;
  &lt;li&gt;db001은 개별 마스터가 되어 독립적으로 존재합니다.&lt;/li&gt;
  &lt;li&gt;db001을 db002의 slave로 등록시킵니다.
    &lt;ul&gt;
      &lt;li&gt;방법은 set global read_only = 1;&lt;/li&gt;
      &lt;li&gt;CHANGE MASTER TO MASTER_HOST=’db002’, MASTER_USER=’rep1’, MASTER_PASSWORD=’rep1’, MASTER_AUTO_POSITION=1;&lt;/li&gt;
      &lt;li&gt;start slave;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 01 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/06/01/mysqlOnDocker-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/06/01/mysqlOnDocker-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 5</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;권한의-이해&quot;&gt;권한의 이해&lt;/h2&gt;

&lt;p&gt;Authorization은 filter를 거친후에 url단에서 권한을 검사할수있으며 , Global Method 권한 위원회에 의해서 컨드롤러,서비스, 레포지터리단을 애노테이션기반으로 검사할수있다.&lt;/p&gt;

&lt;p&gt;SecurityFilterChain 당 한개의 filterSecurityIntercetor를 둘 수 있고, 각 SecurityInterceptor당 한개의 AccessDecisionManager를 둘 수 있습니다. 반면 Method 권한 판정을 global 한 권한 위원회를 둡니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SecurityInterceptor -&amp;gt; AccessDecisionManager -&amp;gt; AccessDecisionVoter -&amp;gt; pass / AccessDeny
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;과정으로 진행된다.&lt;/p&gt;

&lt;h2 id=&quot;voter&quot;&gt;voter&lt;/h2&gt;
&lt;p&gt;이 과정에서 기존의 방법으로는 voter의 방법이 사용되고 더 나은 방법으로는 expression 방법이 존재한다.&lt;/p&gt;

&lt;p&gt;voter는 MethodSecurityConfiguration에 GlobalMethodSecurityConfiguration을 구현체로 사용해서 accesDecisionManager()를 구현해야한다. &lt;br /&gt;
  accesDecisionManager()에서 decision을 결정할수있다. &lt;br /&gt;
  PreInvocationAuthorizationAdviceVoter, RoleVoter, AuthenticatedVoter 에서 voter가 작동하고 커스텀한 voter또한 등록하여 사용할수있다.&lt;/p&gt;

&lt;p&gt;MethodSecurityExpressionHandler를 통해서 permissionEvaluator를 핸들러에 추가할수있고 
  핸들러의 타입은 DefaultMethodSecurityExpressionHandler을 가지며 이를 생성하기 위해서는 new CustomMethodSecurityExpressionRoot(authentication, invocation);을 이용해야 가능하다.&lt;/p&gt;

&lt;p&gt;그리고 난후 handler.setPermissionEvaluator(permissionEvaluator); 클래스에 다양한 검사를 넣을수있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler(){
            @Override
            protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
                CustomMethodSecurityExpressionRoot root = new CustomMethodSecurityExpressionRoot(authentication, invocation);
                root.setPermissionEvaluator(getPermissionEvaluator());
                return root;
            }
        };
        handler.setPermissionEvaluator(permissionEvaluator);
        return handler;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;expressionvoter와-piiavoter&quot;&gt;ExpressionVoter와 PIIAVoter&lt;/h2&gt;
&lt;p&gt;WebExpressionVoter, PreInvocationAuthoriztionAdviceVoter는 SpEL 방식으로 동작한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @PostAuthorize(&quot;hasPermission(#paperId, 'paper', 'read')&quot;)
  @PostAuthorize(&quot;returnObject.studentIds.contains(principal.username)&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hasPermission&lt;/code&gt;메서드를 통해서 검사가 가능하며 SpEL을 사용해야한다. #,@등으로 SpEL을 진행할수있다. 
  returnObject을 통해서 Expression을 통해서 검사가 진행된다. Expression은 MethodSecurityExpressionOperations에서 메서드를 재정의를 통해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;AccessDecisionManager에서 AbstractAccessDecisionManager에서 AccessDecisionVoter를 통해서 voter가 진행되고 이를 통해서 Attribute가 진행되고 post,webExpress,preInvocation 등에서 postAuthorize,PostFilter등을 사용할 수 있다.&lt;/p&gt;

</description>
        <pubDate>Mon, 31 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/31/spring-security-concept-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/31/spring-security-concept-5/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;baseauthenticationfilter&quot;&gt;baseAuthenticationFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 로그인 페이지를 사용할 수 없는 상황에서 사용합니다.
    &lt;ul&gt;
      &lt;li&gt;SPA 페이지&lt;/li&gt;
      &lt;li&gt;브라우저 기반의 모바일 앱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용방법
  ```
  public class SecurityConfig extends WebSecurityConfigurerAdapter {&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Override
  protected void configure(HttpSecurity http) throws Exception {
      http
              .httpBasic()
              ;
  }
  }&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  http에서 header에 username:password 값이 묻어가기 때문에 보안에 매우 취약합니다. 반드시 https 프로토콜에서 사용할 것을 권장하고 있습니다.

  최조 로그인시에만 인증을 처리하고, 이후에는 session에 의존합니다. 또 RememberMe를 설정한 경우, 쿠기가 브러우저에 저장되기 때문에 세션이 만료된 이후라도 브라우저 기반의 앱에서는 장시간 서비스를 로그인 페이지를 거치지 않고 이용할 수 있습니다. 
  

  테스트 방법
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class BasicTokenTest {

    @LocalServerPort
    int port;

    private RestTemplate restTemplate = new RestTemplate();

    @DisplayName(&quot;1. Basic Token Test&quot;)
    @Test
    void test_1(){

        String url = format(&quot;http://localhost:%d%s&quot;, port, &quot;/greeting&quot;);
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.AUTHORIZATION, &quot;basic &quot;+ Base64.getEncoder().encodeToString(&quot;user1:1111&quot;.getBytes()));
        HttpEntity entity = new HttpEntity(&quot;&quot;, headers);

        ResponseEntity&amp;lt;String&amp;gt; response = restTemplate.exchange(url,
                HttpMethod.GET, entity, String.class);

        assertEquals(&quot;Hello jongwon&quot;, response.getBody());
    }

}   ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;session-with-basic-authentication&quot;&gt;Session with Basic Authentication&lt;/h2&gt;

&lt;p&gt;Basic Authentication을 이용해서 세선과 클라이언트 로그인을 진행 할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 인증 처리는 세션과는 별도로 동작하도록 설계되어 있습니다. 그래서 session을 사용하건 사용하지 않건 같은 authentication과 authenticationProvider를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버의 세션정책과 스프링의 인정 체계가 서로 맞물려 작동하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;SecurityContextPersistenceFilter&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;RememberMeAuthenticationFilter&lt;/code&gt;등과 여러 인증을 보조해주는 다른 필터들의 도움을 받아야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;securitycontextpersistencefilter&quot;&gt;&lt;strong&gt;SecurityContextPersistenceFilter&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;SecurityContextRepository에 저장된 SecurityContext를 request의 localThread에 넣어주었다가 뺐는 역할을 한다. doFilter 메소드를 따라가보면 알수 있다. 세션에 SecurityContext를 보관했다가 다음 request에서 넣어줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SecurityContextPersistenceFilter -&amp;gt; SecurityContextRepository
SecurityContextPersistenceFilter -&amp;gt; SecurityContextHolder

HttpSessionSecurityContextRepository -&amp;gt; SecurityContextRepository
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;remembermeauthenticationfilter&quot;&gt;RememberMeAuthenticationFilter&lt;/h2&gt;

&lt;p&gt;인증 정보를 세션관리하는 경우 , 세션 timeout이 발생하게 되면, remember-me 쿠키를 이용해 로그인을 기억했다 자동으로 재로그인 시켜주는 기능입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RememberMeAuthenticationFilter -&amp;gt; RememberMeServices
  
  AbstrackRememberMeService -&amp;gt; RememberMeService

  TokenBasedRememberMeService -&amp;gt; AbstrackRememberMeService
  PersistenceTokenBasedRememberMeService -&amp;gt; AbstrackRememberMeService

  PersistenceTokenBasedRememberMeService -&amp;gt; PersistenceTokenRepository
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PersistenceTokenRepository에 username, series, token,last_used 정보가 들어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;토큰기반의 TokenBasedRememberMeService은 다음과 같은 특징이 존재합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포맷 : 아이디 : 만료시간 : Md5Hex(아이디:만료시간:비밀번호:인증키)&lt;/li&gt;
  &lt;li&gt;만약 User가 password를 바꾼다면 토큰을 쓸 수 없게 됩니다.&lt;/li&gt;
  &lt;li&gt;기본 유효기간은 14일 이고 설정에서 바꿀 수 있습니다.&lt;/li&gt;
  &lt;li&gt;약점 : 탈취된 토큰은 비밀번호를 바꾸지 않는한 유효기간동안 만능키가 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇기 때문에 토큰기반의 탈취시 문제의 소지가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PersistenceTokenBasedRememberMeServices&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포멧 : series:token&lt;/li&gt;
  &lt;li&gt;토큰에 username이 노출되지 않고, 만료시간도 노출되지 않습니다. 만료시간은 서버에서 정하고 노출하지 않고 서버는 로그인 시간만 저장합니다.&lt;/li&gt;
  &lt;li&gt;series 값이 키가 된다. 일종의 채널이라고 보면 편리하다.&lt;/li&gt;
  &lt;li&gt;대신 재로그인이 될 때마다 token 값을 갱신해 줍니다. 그래서 토큰이 탈취되어 다른 사용자가 다른 장소에서 로그인을 했다면 정상 사용자가 다시 로그인 할 때, CookieTheftException 이 발생하게 되고, 서버는 해당 사용자로 발급된 모든 remember-me 쿠키값들을 삭제하고 재로그인을 요청하게 됩니다.&lt;/li&gt;
  &lt;li&gt;InmemoryTokenRepository 는 서버가 재시작하면 등록된 토큰들이 사라집니다. 따라서 자동로그인을 설정했더라도 다시 로그인을 해야 합니다. 재시작 후에도 토큰을 남기고 싶다면 JdbcTokenRepository를 사용하거나 이와 유사한 방법으로 토큰을 관리해야 합니다.&lt;/li&gt;
  &lt;li&gt;로그아웃하게 다른 곳에 묻혀놓은 remember-me 쿠키값도 쓸모가 없게 됩니다. 만약 다른 곳에서 remember-me로 로그인한 쿠키를 살려놓고 싶다면, series 로 삭제하도록 logout 을 수정해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-4/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;authentication&quot;&gt;Authentication&lt;/h2&gt;

&lt;p&gt;인증은 다음과 같이 구성되어있다. &lt;br /&gt;
  그리고 인증을 구성하기 위해서 사용되는 토큰이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication
    &lt;ul&gt;
      &lt;li&gt;Credentiails&lt;/li&gt;
      &lt;li&gt;Principal&lt;/li&gt;
      &lt;li&gt;Details&lt;/li&gt;
      &lt;li&gt;Authorities&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러개의 토큰을 사용해서 인증을 구성한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UsernamePasswordAuthentication Token&lt;/li&gt;
  &lt;li&gt;RunAsUser Token&lt;/li&gt;
  &lt;li&gt;TestingAuthentication Token&lt;/li&gt;
  &lt;li&gt;AnonymouseAuthenication Token&lt;/li&gt;
  &lt;li&gt;RememberMeAuthentication Token&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;authenticationprovider&quot;&gt;AuthenticationProvider&lt;/h2&gt;
&lt;p&gt;Authentication을 검증하여 Principal을 제공합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class StudentManager implements AuthenticationProvider, InitializingBean {

    private HashMap&amp;lt;String, Student&amp;gt; studentDB = new HashMap&amp;lt;&amp;gt;();

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        StudentAuthenticationToken token = (StudentAuthenticationToken) authentication;
        if(studentDB.containsKey(token.getCredentials())){
            Student student = studentDB.get(token.getCredentials());
            return StudentAuthenticationToken.builder()
                    .principal(student)
                    .details(student.getUsername())
                    .authenticated(true)
                    .authorities(student.getRole())
                    .build();
        }
        return null;
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; authentication) {
        return authentication == StudentAuthenticationToken.class;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        Set.of(
                new Student(&quot;hong&quot;, &quot;홍길동&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;))),
                new Student(&quot;kang&quot;, &quot;강아지&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;))),
                new Student(&quot;rang&quot;, &quot;호랑이&quot;, Set.of(new SimpleGrantedAuthority(&quot;ROLE_STUDENT&quot;)))
        ).forEach(s-&amp;gt;
            studentDB.put(s.getId(), s)
        );
    }   
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;authenticationProvider를 커스텀해서 사용할수있다. 이를 만들기 위해서 student, StudentAuthenticationToken이 필요하다.&lt;/p&gt;

&lt;p&gt;student는 사용자의 데이터를 받을 클래스,StudentAuthenticationToken 정보를 담을 클래스이다. &lt;br /&gt;
  StudentAuthenticationToken은 즉 userDetails가 되는것이다.&lt;/p&gt;

&lt;p&gt;이를 구현하고 securityConfig에서 사용하면된다. 그리고&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   public class CustomLoginFilter extends UsernamePasswordAuthenticationFilter {

    public CustomLoginFilter(AuthenticationManager authenticationManager){
        super(authenticationManager);
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        String username = obtainUsername(request);
        username = (username != null) ? username : &quot;&quot;;
        username = username.trim();
        String password = obtainPassword(request);
        password = (password != null) ? password : &quot;&quot;;
        String type = request.getParameter(&quot;type&quot;);
        if(type == null || !type.equals(&quot;teacher&quot;)){
            // student
            StudentAuthenticationToken token = StudentAuthenticationToken.builder()
                    .credentials(username).build();
            return this.getAuthenticationManager().authenticate(token);
        }else{
            // teacher
            TeacherAuthenticationToken token = TeacherAuthenticationToken.builder()
                    .credentials(username).build();
            return this.getAuthenticationManager().authenticate(token);
        }
    }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;아래와 같이 filter 또한 직접 커스텀해서 사용가능하다.&lt;/p&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-3/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;폼-로그인&quot;&gt;폼 로그인&lt;/h1&gt;

&lt;h2 id=&quot;defaultloginpagegeneratingfilter&quot;&gt;DefaultLoginPageGeneratingFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;GET /login 을 처리&lt;/li&gt;
  &lt;li&gt;별도의 로그인 페이지 설정을 하지 않으면 제공되는 필터&lt;/li&gt;
  &lt;li&gt;기본 로그인 폼을 제공&lt;/li&gt;
  &lt;li&gt;OAuth2 / OpenID / Saml2 로그인과도 같이 사용할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;usernamepasswordauthenticationfilter&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;POST /login 을 처리. processingUrl 을 변경하면 주소를 바꿀 수 있음.&lt;/li&gt;
  &lt;li&gt;form 인증을 처리해주는 필터로 스프링 시큐리티에서 가장 일반적으로 쓰임.&lt;/li&gt;
  &lt;li&gt;주요 설정 정보
    &lt;ul&gt;
      &lt;li&gt;filterProcessingUrl : 로그인을 처리해 줄 URL (POST)&lt;/li&gt;
      &lt;li&gt;username parameter : POST에 username에 대한 값을 넘겨줄 인자의 이름&lt;/li&gt;
      &lt;li&gt;password parameter : POST에 password에 대한 값을 넘겨줄 인자의 이름&lt;/li&gt;
      &lt;li&gt;authenticationDetailSource : Authentication 객체의 details 에 들어갈 정보를 직접 만들어 줌.
```
@Override
public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
      throws AuthenticationException {
  if (this.postOnly &amp;amp;&amp;amp; !request.getMethod().equals(“POST”)) {
      throw new AuthenticationServiceException(“Authentication method not supported: “ + request.getMethod());
  }
  String username = obtainUsername(request);
  username = (username != null) ? username : “”;
  username = username.trim();
  String password = obtainPassword(request);
  password = (password != null) ? password : “”;
  UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
  // Allow subclasses to set the “details” property
  setDetails(request, authRequest);
  return this.getAuthenticationManager().authenticate(authRequest);
}&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;defaultlogoutpagegeneratingfilter&quot;&gt;DefaultLogoutPageGeneratingFilter&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;GET /logout 을 처리&lt;/li&gt;
  &lt;li&gt;POST /logout 을 요청할 수 있는 UI 를 제공&lt;/li&gt;
  &lt;li&gt;DefaultLoginPageGeneratingFilter 를 사용하는 경우에 같이 제공됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logoutfilter&quot;&gt;LogoutFilter&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;POST /logout 을 처리. processiongUrl 을 변경하면 바꿀 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실습-예제&quot;&gt;실습 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;HomeController&lt;/li&gt;
  &lt;li&gt;SecurityConfig&lt;/li&gt;
  &lt;li&gt;RequestInfo&lt;/li&gt;
  &lt;li&gt;CustomAuthDetails&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 컨드롤러 및 컨피그를 설정하여 실습을 진행함 
  컨트롤러에는 로그인, 로그아웃, 홈, 엑세스디나인, 유저 , 어드민을 갈수있는 url이 설정되어있다. &lt;br /&gt;
  페이지는 간단하게 string만 출력한다.&lt;/p&gt;

&lt;p&gt;유저는 SecurityContig에서 간단하게 설정하였다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .inMemoryAuthentication()
                .withUser(
                        User.withDefaultPasswordEncoder()
                                .username(&quot;user1&quot;)
                                .password(&quot;1111&quot;)
                                .roles(&quot;USER&quot;)
                ).withUser(
                User.withDefaultPasswordEncoder()
                        .username(&quot;admin&quot;)
                        .password(&quot;2222&quot;)
                        .roles(&quot;ADMIN&quot;)
        );

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;request를 위한 필터 설정은 SecurityConfig의 configure(HttpSecurity http)에서 설정하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests(request-&amp;gt;{
                    request
                            .antMatchers(&quot;/&quot;).permitAll()
                            .anyRequest().authenticated()
                            ;
                })
                .formLogin(
                        login-&amp;gt;login.loginPage(&quot;/login&quot;)
                        .permitAll()
                        .defaultSuccessUrl(&quot;/&quot;,false)
                        .failureUrl(&quot;/login-error&quot;)
                        .authenticationDetailsSource(customAuthDetails)
                )
                .logout(logout-&amp;gt;logout.logoutSuccessUrl(&quot;/&quot;))
                .exceptionHandling(exception-&amp;gt;exception.accessDeniedPage(&quot;/access-denied&quot;))
                ;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드에서 각 유저의 로그인을 설정하였고 커스텀한 Details를 설정하였다. &lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;커스텀 Details&lt;/code&gt;는 아래와 같이 구성되어있고 ip,sessionId,로그인시각을 기록한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Component
    public class CustomAuthDetails implements AuthenticationDetailsSource&amp;lt;HttpServletRequest,RequestInfo&amp;gt; {

        @Override
        public RequestInfo buildDetails(HttpServletRequest request) {
            return RequestInfo.builder()
                    .remoteIp(request.getRemoteAddr())
                    .sessionId(request.getSession().getId())
                    .loginTime(LocalDateTime.now())
                    .build();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 원리 - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;security&quot;&gt;security&lt;/h1&gt;

&lt;p&gt;spring은 웹서버로 많이 사용된다. &lt;br /&gt;
  이때 클라이언트로 부터 request를 받고 서버(spring)은 response를 준다.&lt;/p&gt;

&lt;p&gt;서버가 reqeust를 스프링을 request응 다양한 filter로 확인을 하고 필터에 해당하지 않으면 에러를 발송한다. &lt;br /&gt;
  이때 스프링이서 필터들을 관리하고 다양한 필터가 설정되는곳이 스프링 시큐리티이다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떠한 필터가 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HeaderWriterFilter : Http 해더를 검사한다. 써야 할 건 잘 써있는지, 필요한 해더를 더해줘야 할 건 없는가?&lt;/li&gt;
  &lt;li&gt;CorsFilter : 허가된 사이트나 클라이언트의 요청인가?&lt;/li&gt;
  &lt;li&gt;CsrfFilter : 내가 내보낸 리소스에서 올라온 요청인가?&lt;/li&gt;
  &lt;li&gt;LogoutFilter : 지금 로그아웃하겠다고 하는건가?&lt;/li&gt;
  &lt;li&gt;UsernamePasswordAuthenticationFilter : username / password 로 로그인을 하려고 하는가? 만약 로그인이면 여기서 처리하고 가야 할 페이지로 보내 줄께.&lt;/li&gt;
  &lt;li&gt;ConcurrentSessionFilter : 여거저기서 로그인 하는걸 허용할 것인가?&lt;/li&gt;
  &lt;li&gt;BearerTokenAuthenticationFilter : Authorization 해더에 Bearer 토큰이 오면 인증 처리 해줄께.&lt;/li&gt;
  &lt;li&gt;BasicAuthenticationFilter : Authorization 해더에 Basic 토큰을 주면 검사해서 인증처리 해줄께.&lt;/li&gt;
  &lt;li&gt;RequestCacheAwareFilter : 방금 요청한 request 이력이 다음에 필요할 수 있으니 캐시에 담아놓을께.&lt;/li&gt;
  &lt;li&gt;SecurityContextHolderAwareRequestFilter : 보안 관련 Servlet 3 스펙을 지원하기 위한 필터라고 한다.(?)&lt;/li&gt;
  &lt;li&gt;RememberMeAuthenticationFilter : 아직 Authentication 인증이 안된 경우라면 RememberMe 쿠키를 검사해서 인증 처리해줄께&lt;/li&gt;
  &lt;li&gt;AnonymousAuthenticationFilter : 아직도 인증이 안되었으면 너는 Anonymous 사용자야&lt;/li&gt;
  &lt;li&gt;SessionManagementFilter : 서버에서 지정한 세션정책을 검사할께.&lt;/li&gt;
  &lt;li&gt;ExcpetionTranslationFilter : 나 이후에 인증이나 권한 예외가 발생하면 내가 잡아서 처리해 줄께&lt;/li&gt;
  &lt;li&gt;FilterSecurityInterceptor : 여기까지 살아서 왔다면 인증이 있다는 거니, 니가 들어가려고 하는 request 에 들어갈 자격이 있는지 그리고 리턴한 결과를 너에게 보내줘도 되는건지 마지막으로 내가 점검해 줄께&lt;/li&gt;
  &lt;li&gt;그 밖에… OAuth2 나 Saml2, Cas, X509 등에 관한 필터들도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등의 다양한 필터가 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;authentication&quot;&gt;authentication&lt;/h2&gt;

&lt;p&gt;필터와 인증제공자를 통해서 SecurityContextHolder에 인증이 만들어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SecurityContextHolder : 인증보관함 보관소
    &lt;ul&gt;
      &lt;li&gt;Authentication : 인증
        &lt;ul&gt;
          &lt;li&gt;Principal(UserDetails) : 인증대상
            &lt;ul&gt;
              &lt;li&gt;GrantedAuthority : 권한&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AuthenticationManager : 인증관리자
    &lt;ul&gt;
      &lt;li&gt;ProviderManager : 인증 제공 관리자
        &lt;ul&gt;
          &lt;li&gt;AuthenticationProvider : 인증제공자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;security는 위와 같이 구성되어있다고 볼수있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로그인을 위한 토큰을 제공하는 필터는 다음과 같다.
    &lt;ul&gt;
      &lt;li&gt;UsernamePasswordAuthenticationFilter : 폼 로그인 -&amp;gt; UsernamePasswordAuthenticationToken&lt;/li&gt;
      &lt;li&gt;RememberMeAuthenticationFilter : remember-me 쿠키 로그인 -&amp;gt; RememberMeAuthenticationToken&lt;/li&gt;
      &lt;li&gt;AnonymousAuthenticationFilter : 로그인하지 않았다는 것을 인증함 -&amp;gt; AnonymousAuthenticationToken&lt;/li&gt;
      &lt;li&gt;SecurityContextPersistenceFilter : 기존 로그인을 유지함(기본적으로 session 을 이용함)&lt;/li&gt;
      &lt;li&gt;BearerTokenAuthenticationFilter : JWT 로그인&lt;/li&gt;
      &lt;li&gt;BasicAuthenticationFilter : ajax 로그인 -&amp;gt; UsernamePasswordAuthenticationToken&lt;/li&gt;
      &lt;li&gt;OAuth2LoginAuthenticationFilter : 소셜 로그인 -&amp;gt; OAuth2LoginAuthenticationToken, OAuth2AuthenticationToken&lt;/li&gt;
      &lt;li&gt;OpenIDAuthenticationFilter : OpenID 로그인&lt;/li&gt;
      &lt;li&gt;Saml2WebSsoAuthenticationFilter : SAML2 로그인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Authentication을 제공하는 인증제공자는 여러개가 동시에 존재할 수있고, 인증 방식에 따라 providerManager도 복수로 존재할수있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Authentication 은 인터페이스로 아래와 같은 정보들을 갖고 있습니다.
    &lt;ul&gt;
      &lt;li&gt;Set&lt;GrantedAuthority&gt; authorities : 인증된 권한 정보&lt;/GrantedAuthority&gt;&lt;/li&gt;
      &lt;li&gt;principal : 인증 대상에 관한 정보. 주로 UserDetails 객체가 옴&lt;/li&gt;
      &lt;li&gt;credentials : 인증 확인을 위한 정보. 주로 비밀번호가 오지만, 인증 후에는 보안을 위해 삭제함.&lt;/li&gt;
      &lt;li&gt;details : 그 밖에 필요한 정보. IP, 세션정보, 기타 인증요청에서 사용했던 정보들.&lt;/li&gt;
      &lt;li&gt;boolean authenticated : 인증이 되었는지를 체크함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/spring-security-concept-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/spring-security-concept-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>리팩터링 리뷰 - 1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;repactoring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;리팩토링&quot;&gt;리팩토링&lt;/h2&gt;

&lt;p&gt;리팩터링 어디에 써먹을까?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리팩터링이 필요한 이유를 윗사람에게 설득할수있다.&lt;/li&gt;
  &lt;li&gt;고민의 일정량을 줄일 수 있다. (성능과 코드의 가독성…)
    &lt;ul&gt;
      &lt;li&gt;나의 주관으로는 코드의 가독성을 유지하되 성능이 필요하면 성능적으로 작성하면 되지 않을까 싶다.&lt;/li&gt;
      &lt;li&gt;디버깅이 어려울수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;나의 리팩토링 이유는 생산성 향상에 목표를 둘것이다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩터링-하는-이유&quot;&gt;리팩터링 하는 이유&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;리팩터링하면 소프트웨어 설계가 좋아진다.
    &lt;ol&gt;
      &lt;li&gt;규칙적인 리팩터링은 코드의 구조를 지탱해줄것이다.&lt;/li&gt;
      &lt;li&gt;중복코드를 제거하면 모든코드가 언제나 고유한 일을 수행함을 보장 할 수있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;리팩터링 하면 소프트웨어를 이해하기 쉬워진다.
    &lt;ol&gt;
      &lt;li&gt;코드의 목적은 타인에게 말하기 쉬워진다.&lt;/li&gt;
      &lt;li&gt;나의 코드는 내가보기에 이해하기 쉽지만 타인의 시선에서는 다르다.&lt;/li&gt;
      &lt;li&gt;이는 내가 나의 코드를 알아보기 쉬워진다는 이야기이다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;리팩터링 하면 버그를 쉽게 찾을 수 있다.&lt;/li&gt;
  &lt;li&gt;리팩터링하면 프로그래밍 속도를 높일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;리팩터링-하지-말아야-할때&quot;&gt;리팩터링 하지 말아야 할때&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;외부 API를 호출해서 사용하는 코드 (지저분해도 그냥 둔다.)&lt;/li&gt;
  &lt;li&gt;리팩터링 하는것 or 새로작성하는것 » 둘중 판단이 서지 않을때는 리팩터링 하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;why? 이를 결정하는것은 뛰어난 판단력과 경험이 있어야 하므로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;리팩터링-시-고려할-문제&quot;&gt;리팩터링 시 고려할 문제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;새 기능, 개발속도 저하 ?
    &lt;ul&gt;
      &lt;li&gt;새기능을 구현하기 편해지겠다 싶으면 리팩터링을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 경우에는 리팩터링 하지 않는다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;반면에 내가 직접 건드릴일이없는 분야&lt;/li&gt;
  &lt;li&gt;불편한 정도가 심하지 않는 경우&lt;/li&gt;
  &lt;li&gt;리팩토링으로 개선되지 않을것같은 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리팩터링시 가장 중요한 요소는 경제적 요소이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;리팩토링은 경제적 생산성 향상을 위해서 진행 되어야 한다. !!!&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;리팩터링과-성능&quot;&gt;리팩터링과 성능&lt;/h2&gt;

&lt;p&gt;리팩터링을 하면 성능이 느려질 수 도 있다는것은 사실이다. &lt;br /&gt;
  하지만 빠른 소프트웨어를 만들기에 부족한 점은 아니다. &lt;br /&gt;
  먼저 리팩터링을 통해 튜닝하기 쉽게 만들고 원하는 속도가 나오게끔 튜닝하는것이 베스트라고 생각한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능을 향상시키는 다양한 방법
    &lt;ol&gt;
      &lt;li&gt;최신의 하드웨어를 사용한다.
        &lt;ul&gt;
          &lt;li&gt;리얼타임 SW등 하드웨어에 종속적인 SW는  하드웨어를 바꾸는게 성능을 향상시키는방법이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;끊임없는 관심을 기울인다.
        &lt;ul&gt;
          &lt;li&gt;시간과 공간을 많이 잡아먹는 지점을 알아낸다.(프로파일러 프로그램)&lt;/li&gt;
          &lt;li&gt;성능에 큰 영향을 주는 작은 부분을 찾아낸다.&lt;/li&gt;
          &lt;li&gt;위의 단계를 반복하면서 최적화한다. (리팩토링이 되어있다면 코드를 보기 수월하니 좋은 방법이라 생각한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/24/refactoring-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/24/refactoring-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 JWT - 2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;jwt&quot;&gt;JWT&lt;/h2&gt;
&lt;p&gt;JSON WEB TOKEN : JWT&lt;/p&gt;

&lt;p&gt;정의 : 당사자간에 정보를 JSON 객체로 안전하게 전송하기 위한 컴팩트하고 독립적인 방식을 정의 하는 개방형 표준 입니다. &lt;br /&gt;
  JWP는 비밀(RSA or ECDSA)로 암호화및 복호화를 통해 서명 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;JWT는 다음과 같이 구성되어있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;header
    &lt;ul&gt;
      &lt;li&gt;알고리즘과 타입으로 구성되어있고 Base64UrI로 인코딩 되어있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;payload : 어떤 정보이다.
    &lt;ul&gt;
      &lt;li&gt;클래임을 가진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;signature
    &lt;ul&gt;
      &lt;li&gt;헤더의 정보와 페이로드와 개인키를 암호알고리즘으로 암호화 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  xxxx-yyyy-zzzz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JWT는 header,payload,signature를 각각 base64인코딩하여 JWT를 구성하고 web의 로컬스토리지에 담긴다.&lt;/p&gt;

&lt;p&gt;그리고 이를 서버에 넘긴다.&lt;/p&gt;

&lt;p&gt;JWT를 받은 서버는 신뢰할수있는 토큰인지 검증한다.&lt;/p&gt;

&lt;p&gt;JWT를 암호화할때 RSA또는 hs256으로 암호화 할수있다. (전자서명)&lt;/p&gt;
</description>
        <pubDate>Sun, 23 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/23/spring-security-4-JWT/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/23/spring-security-4-JWT/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 JWT</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;세션&quot;&gt;세션&lt;/h2&gt;

&lt;p&gt;우리가 알아볼내용 jwt에서 가장 중요한 질문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jwt을 왜 사용되는지&lt;/li&gt;
  &lt;li&gt;jwt가 어디에 쓰는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jwt를 공부하기 앞서 session에 대해서 다시 한번 정리 해보겠습니다.&lt;/p&gt;

&lt;p&gt;session은 어떠한 정보가 내포 되어있는 캐시의 개념입니다.  &lt;br /&gt;
  session은 쿠키에 저장됩니다.  &lt;br /&gt;
  쿠키는 http.header에 보관(저장) 됩니다.&lt;/p&gt;

&lt;p&gt;우리는 홈페이지에 여러번 로그인하거나 방문할수있습니다. 
  재접속 하거나 재방문 할때마다 session(쿠키)를 요구한다면 매우 비효율적일것입니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 우리는 쿠키를 보관하고 이를 통해서 재방문,로그인,다양한 정보를 보관합니다.&lt;/p&gt;

&lt;p&gt;세션(쿠키)는 다음과 같은 방식으로 동작합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최초 요청시 서버는 목록에 쿠키를 저장하고 헤더에 쿠키를 담아 클라이언트에 던져줍니다.&lt;/li&gt;
  &lt;li&gt;브라우저 내부에 쿠키를 보관하고 있습니다.
    &lt;ol&gt;
      &lt;li&gt;클라이언트가 재요청시 요청에 쿠키의 정보를 사용하여 재요청을 보냅니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 요청을 받고 쿠키를 확인하고 목록에서 쿠키가 있으면 기존의 사용자임을 확인합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;세션은 서버측에서도 삭제할수있고 클라이언트측에서도 삭제 할수있습니다. 특별한 경우가 없을경우 시간에 따라 삭제됩니다.&lt;/p&gt;

&lt;p&gt;세션의 단점 : 클라이언트가 많은때 &lt;code class=&quot;highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;이 일어난다. 서버가 여러대일때 내가 최초 들어갔던 서버가 아니면 세션은 계속 생성된다.&lt;/p&gt;

&lt;p&gt;세션의 단점을 처리는 방법은 여러 방법이 존재한다. 해결방법은 : 공유되는 메모리 &lt;code class=&quot;highlighter-rouge&quot;&gt;메모리서버&lt;/code&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;이러한 고질점은 해결하기 위해서 JWT를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;

&lt;p&gt;물,데,네,트,세,프,용 !!&lt;/p&gt;

&lt;p&gt;OSI 7계층을 알아야한다. &lt;br /&gt;
  OSI 7계층은 각 계층별로 선정되는 데이터가 존재하고 다음 계층으로 전달한다. &lt;br /&gt;
  대략적인 느낌은 이렇게는 것이다.  &lt;br /&gt;
  정확한 내용은 다른 블로그를 참고 하길 바랍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP
    &lt;ul&gt;
      &lt;li&gt;신뢰를 기반으로 전송하는 방법이다.&lt;/li&gt;
      &lt;li&gt;ack를 기반으로 통신한다. ack가 오지 않는다면 다시 전송을 진행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDP
    &lt;ul&gt;
      &lt;li&gt;ack를 보내지 않고 데이터를 전송한다.&lt;/li&gt;
      &lt;li&gt;신뢰적 전송을 제공하지 않는다.&lt;/li&gt;
      &lt;li&gt;UDP는 하나의 회선을 차지하고 있는다. 그리고 stream, 전화등에서 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ciaconfidential-integrety-authability&quot;&gt;CIA(confidential, Integrety, authability)&lt;/h2&gt;

&lt;p&gt;위에서 TCP에 대해서 간단하게 정립하였다. &lt;br /&gt;
  TCP 전송중에 누군가 데이터를 확인한다면 ? 어떻게 되는가?? : 기밀성이 깨진다.&lt;/p&gt;

&lt;p&gt;그 데이터를 변경하면 ?? : 무결성이 깨진다.&lt;/p&gt;

&lt;p&gt;마지막으로 우리는 원래 받아야할 데이터를 못받았므로 가용성이 깨진다.&lt;/p&gt;

&lt;p&gt;통신에서 CIA를 지키기 위해서 암호화를 한다.&lt;/p&gt;

&lt;p&gt;암호화를 하기위해서 다양한 방법이 필요하다 (대칭키 , 비대칭키)&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;public key : 공개키&lt;/p&gt;

&lt;p&gt;private key : 개인키&lt;/p&gt;

&lt;p&gt;송신자는 수신자의 공개키로 암호화하고 수신자는 본인의 개인키로 복호화 할수있다. &lt;br /&gt;
  우리는 이렇한 방법을 통해서 암호화가 가능하다 &lt;br /&gt;
  이것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;RSA&lt;/code&gt; 암호 방식이다.&lt;/p&gt;

&lt;p&gt;또한 공개키 , 개인키를 기반으로 전자서명이 존재한다.&lt;/p&gt;

&lt;p&gt;A는 본인의 개인키로 암호화하고 누군가에게 송신한다. &lt;br /&gt;
  A의 메세지를 수신받은 B는 A의 공개키로 메세지를 열어볼수있고 이를 통해서 메세지 내용을 확인할수있다. &lt;br /&gt;
  우리는 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;전자서명&lt;/code&gt;이라 한다.&lt;/p&gt;

&lt;p&gt;RSA는 이산대수 문제의 원리를 통해서 암복호화 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;주어진 g, x, p를 이용하여 y = g^x mod p를 구하긴 쉽지만, g, y, p 값을 이용하여 원래의 x는 찾기 어렵다는 것이다
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rfc문서&quot;&gt;RFC문서&lt;/h2&gt;
&lt;p&gt;인터넷 통신을 프로토콜로 정의해놓은 문서이다.&lt;/p&gt;

</description>
        <pubDate>Sun, 23 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/23/spring-security-3-JWT/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/23/spring-security-3-JWT/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>시큐리티 OAuth login</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;security&quot;&gt;security&lt;/h1&gt;

&lt;p&gt;oauth2를 위한 버튼, url 등이 필요하며 응답을 받을 url을 각 페이지에서 설정해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  .and()
    .oauth2Login()
    .loginPage(&quot;/login&quot;)
    .userInfoEndpoint()
    .userService(principalOauth2UserService);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;oauth2 사용을 위한 DefaultOAuth2UserService (loadUser메서드)&lt;/p&gt;

&lt;p&gt;Authentication 객체가 가질수있는 2가지 타입&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UserDetails&lt;/li&gt;
  &lt;li&gt;OAuth2User&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/20/spring-security-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/20/spring-security-2/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>security study</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;security&quot;&gt;security&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;spring security는 여러가지 기능을 가지고 있다.
    &lt;ul&gt;
      &lt;li&gt;authentication, authrize 기능이 대표적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 어떻게 진행되는것인가?&lt;/p&gt;

&lt;p&gt;시큐리티는 다음과같은 설정과 방법이 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;시큐리티 기능사용을 위한 의존성 등록&lt;/li&gt;
  &lt;li&gt;시큐리티 기능을 수행하기에 앞서 설정 (SecurityConfig)
    &lt;ol&gt;
      &lt;li&gt;WebSecurityConfigurerAdapter를 상속받는 SecurityConfig&lt;/li&gt;
      &lt;li&gt;configure()를 오버라이딩 하여 http.request요청이에 다양한 설정을 등록수있다.
        &lt;ul&gt;
          &lt;li&gt;권한, 로그인설정 등등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;로그인관련 요청이 들어오면 시큐리티가 로그인을 진행한다.
    &lt;ol&gt;
      &lt;li&gt;이때 설정한 내용을 토대로 Security ContextHolder에 시큐리티 세션이 만들어진다.&lt;/li&gt;
      &lt;li&gt;Security (sesseion =&amp;gt; Authentication =&amp;gt; UserDetails) 타입으로 구성되어있다.&lt;/li&gt;
      &lt;li&gt;그래서 우리는 UserDetails객체를 이용한 PrincipalDetails,PrincipalDetailService를 만들어야한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시큐리티는 크게 위와같은 로직으로 동작한다.&lt;/p&gt;

&lt;p&gt;시큐리티 구현을 위한 세부적인 로직(다양한 설정)은 자세히 알아보자&lt;/p&gt;

&lt;h2 id=&quot;구현-목록&quot;&gt;구현 목록&lt;/h2&gt;

&lt;p&gt;시큐리티 구현을 위해서는 PrincipalDetails, PrincipalDetailService, securityConfig가 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;securityConfig는 WebSecurityConfigurerAdapter를 상속받고 오버라이딩을 통해서 기능 구현한다.
    &lt;ul&gt;
      &lt;li&gt;@EnableWebSecurity !&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PrincipalDetails은 UserDetails상속받고 오버라이딩을 통해 기능 구현한다.&lt;/li&gt;
  &lt;li&gt;PrincipalDetailService는 Serivce로 등록해서 시큐리티가 login을 동작시킬 로직을 작성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;principaldetails&quot;&gt;PrincipalDetails&lt;/h2&gt;

&lt;p&gt;PrincipalDetails에서 우리는 사용할 객체를 콤포지션한다.&lt;/p&gt;

&lt;p&gt;그리고 생성자를 만들어서 사용할 객체를 주입한다.&lt;/p&gt;

&lt;p&gt;여기에서 우리는 다양한 메서드를 오버라이딩 해야한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Authentication 객체에 저장할 수 있는 유일한 타입
  @Data
  public class PrincipalDetails implements UserDetails{

	private User user;

	public PrincipalDetails(User user) {
		super();
		this.user = user;
	}
	
	@Override
	public String getPassword() {
		return user.getPassword();
	}

	@Override
	public String getUsername() {
		return user.getUsername();
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}
	
	@Override
	public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
		Collection&amp;lt;GrantedAuthority&amp;gt; collet = new ArrayList&amp;lt;GrantedAuthority&amp;gt;();
		collet.add(()-&amp;gt;{ return user.getRole();});
		return collet;
	}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;principaldetailsservice&quot;&gt;PrincipalDetailsService&lt;/h2&gt;
&lt;p&gt;PrincipalDetailsService은 DetailsUserSerivce의 구현체이다.&lt;/p&gt;

&lt;p&gt;longin 요청이 오면 자동으로 UserDetailsService 타입으로 IoC되어 있는 loadUserByUsername 함수가 실행된다.&lt;/p&gt;

&lt;p&gt;loadUserByUsername()는 login시에 username이 존재하는지 확인한다. 어디서? 레포지터리에서&lt;/p&gt;

</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/20/spring-security-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/20/spring-security-1/</guid>
        
        <category>security</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>spring AOP-4(spring AOP)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;aop--logback-springxml&quot;&gt;AOP &amp;amp; logback-spring.xml&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;AOP를 사용하여 로그(파일,콘솔) 찍는 연습 및 코드&lt;/li&gt;
  &lt;li&gt;setry를 이용한 온라인 로그 찍기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;logback-spring&quot;&gt;&lt;strong&gt;logback-spring&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;로그를 파일로 저장하기 위해서는 logback-spring.xml 파일을 만들어 설정을 해줘야한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LOGS_ABSOLUTE_PATH&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./logs&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STDOUT&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;layout&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.classic.PatternLayout&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;Pattern&amp;gt;&lt;/span&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{36} - %msg%n&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FILE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${LOGS_ABSOLUTE_PATH}/logback.log&lt;span class=&quot;nt&quot;&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{35} - %msg%n&lt;span class=&quot;nt&quot;&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${LOGS_ABSOLUTE_PATH}/logback.%d{yyyy-MM-dd}.%i.log.gz&lt;span class=&quot;nt&quot;&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;5MB&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;30&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;root&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;level=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STDOUT&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;logger&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.ddoel.person.demo.config&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;level=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WARN&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FILE&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/logger&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;이 코드는 거의 복붙하는것이다. 우리가 설정해줘야하는 부분은 &amp;lt;root&amp;gt;, &amp;lt;logger&amp;gt; 부분이다. &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;aop-연습&quot;&gt;&lt;strong&gt;AOP 연습&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;우리는 validate 그리고 로그를 aop를 이용해서 처리(중복처리) 할수있다.&lt;/p&gt;

&lt;p&gt;이는 joinpot, pointcut, advice를 통해서 가능하는데 이는 이전 포스트를 참고하자.&lt;/p&gt;

&lt;p&gt;AOP시에 중요한것은 Advice를 설정과 Dto 설정이다.&lt;/p&gt;

&lt;p&gt;validate를 설정하고 이를 판별할때 dto를 사용하지 않는다면 entity의 직접적인 접근이되어 값이 변할 가능성이 존재한다. 그러므로 commonDto,joinReqDto,updateReqDto를 설정하여 관리하는것이 좋다. (user-domain(entity))에서&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//@Before
//@After
@Around(&quot;execution(* com.ddoel.person.demo.web..*Controller.*(..))&quot;)
public Object validCheck(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {


    //request 값 처리 못하나요?
    HttpServletRequest request =
            ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
    log.info(&quot;주소 : {}&quot;,request);
    
    
    String type = proceedingJoinPoint.getSignature().getDeclaringTypeName();
    String method = proceedingJoinPoint.getSignature().getName();

    log.info(&quot;type confirm : {}&quot;, type);
    log.info(&quot;method confirm : {}&quot;, method);

    // 아규먼트 리턴
    Object[] args = proceedingJoinPoint.getArgs();

    for (Object arg : args) {
        if(arg instanceof BindingResult){
            BindingResult bindingResult = (BindingResult) arg;


            // 서비스 : 정상적인 화면 -&amp;gt; 사용자요청
            if(bindingResult.hasErrors()){
                Map&amp;lt;String,String&amp;gt; errorMap = new HashMap&amp;lt;&amp;gt;();

                for(FieldError error : bindingResult.getFieldErrors()){
                    errorMap.put(error.getField(),error.getDefaultMessage());
                    log.warn(type+&quot;.&quot;+method+&quot;()=&amp;gt;필드 : &quot;+error.getField()+&quot;, 메시지:&quot;+error.getDefaultMessage());
                    Sentry.captureMessage(type+&quot;.&quot;+method+&quot;()=&amp;gt;필드 : &quot;+error.getField()+&quot;, 메시지:&quot;+error.getDefaultMessage());
                }

                return new CommonDto&amp;lt;&amp;gt;(HttpStatus.BAD_REQUEST.value(),errorMap);
            }
        }
    }

    return proceedingJoinPoint.proceed();// 함수의 시택을 실행하라.
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드는 advice를 설정한 코드이다.&lt;/p&gt;

&lt;p&gt;@Around,@Before,@After 등을 통해서 조인포인트를 설정할수있다. 또한 excution을 통해 어떤 메소드를 포인트컷할지 설정도 가능하다.&lt;/p&gt;

&lt;p&gt;위의 설정을 끝내고 실질적인 advice (중복 메서드) 가 실행된다.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/17/spring-ioc-17-AOP(4)/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/17/spring-ioc-17-AOP(4)/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>git &amp; github 정리</title>
        <description>&lt;h2 id=&quot;왜-add를-사용하는가&quot;&gt;왜 add를 사용하는가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정한 원하는 파일만 저장하기 위해서이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;log--diff&quot;&gt;log &amp;amp; diff&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git log 를 진행하면 역사를 볼수있다. 
- git log - p : 최신 커밋과 이전커밋의 차이점을 볼수있다.
 - +++는 추가된 내용이며, ---는 이전 버전의 내용이다. 
 - git log에는 커밋it가 나와있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;git diff 커밋id, 커밋id : 커밋들의 차이를 보여준다. 소스코드의 차이점을 보여줌&lt;/li&gt;
  &lt;li&gt;git diff : 현재 내가 작업한(수정한) 내용을 볼수있다. 이전코드와 수정한 코드의 차이를 볼수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;commit-cancel&quot;&gt;Commit cancel&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- reset : 특정 커밋을 최신상태로 하고싶을때 -&amp;gt; git reset 커밋id --hard
  - 리셋은 공유환경에서 사용하면 안된다. 
  - --hard : 

- revert : 특정 커밋을 취소하고 해당 커밋을 새로운 버전으로 생성한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-add-원리&quot;&gt;git add 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git의 파일의 이름은 index에 담겨있고 파일의 내용은 objects파일에 들어있다.
- index, objects 파일은 .git 폴더안에 들어있다.
- git은 파일의 이름이 다르더라도 내용이 같다면 같은 인덱스를 가진다. 그리고 이 인덱스는 같은 오브젝트를 가르킨다.
- git은 해쉬값 + 몇가지 부가적인 값을 통해서 add 를 진행하고 커밋을 객체를 만든다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-commit-원리&quot;&gt;git commit 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 커밋파일에는 커밋 메시지, tree , 사용자정보, parent 가 들어있다. 
- tree는 우리가 작성한 파일의 이름이 존재한다. 각각의 버전마다 tree의 값이 다르다. 
  - 이를 스냅샷을 찍었다라고 한다. 
- parent는 이전 커밋을 의미한다. 

- 중요정보 parent, tree의 관계가 중요하다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index-파일-지레짐작&quot;&gt;index 파일 지레짐작&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- status의 상태를 어떻게 알까?
- object와 index의 내용이 같으면 status가 같다고 보는것같다. 
- 이는 해쉬값을 통해서 비교하는것 같다. 인덱스, 트리, 그리고 local데이터를 비교하여 다르면 status를 바꾼다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-branch&quot;&gt;git branch&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git branch : 브랜치를 조회할수있는 명령어
- git branch filename : 브랜치 생성
- git checkout filename : 브랜치 이동

- git log --branches --decorate : 모든 브랜치를 볼수있는 명령어
- git log --branches --decorate --graph : 그래프 기능이 추가된다. 
- git log --branches --decorate --graph --oneline : 한눈에 보기 싶다. 

- git log master..exp : 마스터에는 없고 exp에는 존재하는 커밋을 보여줌
- git log exp..master -p : exp에는 없고 마스터에는 존재하는것 그리고 -p를 통해서 상세하게 비교해준다. 

- git diff master..exp : exp에 추가적인 정보가 어떤게 있는지 비교하여 보여준다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-merge&quot;&gt;git Merge&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마스터로 머지하려면 마스터로 checkout해야한다. 
- git merge exp : 현재 브랜치에 exp를 머지한다.
- git merge master : exp의 브랜치를 master로 시점을 맞춰주는 역할을한다.

만약에 병합이 잘되었다면 기존의 exp branch는 삭제 해도된다. 
- git branch - d exp : 브런치를 삭제하는 명령어
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-연습&quot;&gt;git 연습&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git tutorial 을 통해서 연습하자. 

마스터 브랜치가 존재하고 이에 따른 커밋을 3번하였다.

이때 새로운 브런치를 생성한다. 
```
git checkout -b issue53; 
```

이렇게 되면git은 두가지의 브랜치를 갖는다. 그리고 브런치를 커밋하면 브랜치는 새로운 브랜치를 가르킨다. 

이때 또다른 B 브랜치를 생성하고 이를 마스터 브랜치에 머지한다. 

이럴때 FastForward가 발생한다. 
FastForward : B 브랜치를 마스터에 병합할때 마스터가 B 브런치를 가르키게 하는 역할을 한다. 
 - 즉 빨리감기를 한다. 

그리고 마지막 브런치 A(issue53)을 마스터에 병합할때 merge recursion이 발생한다. 

이때 깃은 마스터와 A의 공통의 parent를 찾고 후에 3wayMerge방법을 이용해서 브랜치들을 병합하고 
별도의 커밋을 생성한다. 그리고 새로운 커밋을 마스터가 가르킨다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-stash&quot;&gt;git stash&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 작업이 끝나지 않았을때 다른 브랜치로 이동해서 급하게 일을 수행하는경우 사용한다. 
- 브랜치를 특정 공간에 숨길수있다. 그리고 새로운 업무를 진행하고 다시 숨긴 브랜치를 사용할수있는것이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-branch-의-원리&quot;&gt;git branch 의 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git을 init하면 head 파일이 생성된다. 
- 그리고 커밋을 하면 refs/heads/master 가 생성된다. 이는 가장 최신 커밋을 가르킨다.

- git의 head는 최신 커밋을 가리키고 이는 object파일의 내용을 알수있다. 또한 object,tree,index 등의 해쉬값을 통해서 최신 커밋의 상태또한 알수있다. 
이전커밋은 parent를 통해서 이전 커밋도 알수잇다. 

- 브랜치를 생성하면 ./.git/refs/heads/exp가 생성된다. 이는 일반 텍스트 파일이다. 

- HEAD의 역할을 checkout을 한 최신 커밋을 가르킨다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-conflict&quot;&gt;git conflict&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마스터와 브랜치가 하나의 파일의 같은 라인소스를 수정할때 충돌이 일어난다. 
- 같은 코드의 다른 라인을수정한다면 이는 문제가 되지 않고 git이 recursionMerge한다. 

```
 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
 function(master){
 ========
 function(exp){
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
```

- == 는 코드의 다른 부분을 보여주는 분기이다. 
- 충돌해결은 재주것 해야한다. 리팩토링의 관점에서 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-reset-checkout-원리&quot;&gt;git reset checkout 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git reset --hard 커밋id : HEAD이 커밋ID를 보게 되고 이는 최신커밋ID 바꾸는 행위이다. 
- git은 rest을 하여도 삭제된것은 아니다. resert을 취소할수도 있기 떄문이다. 

- git log --hard ORIG_HEAD : reset을 취소할수있다. 

- git reflog : 각각의 로그를 볼수있다. 

- --hard, --soft, --mixed 개념 알기 
  1. working directory(workgin tree, working copy)  
  2. index(stating area,cache) 
  3. repository
  soft,mixed,hard는 각각 초기화되는 부분이 다르다.   
  soft(3), mixed(2,3), hard(1,2,3)의 범위를 갖는다.    
  
- soft : 레포지토리의 영역만 초기화된다.
- index : add영역(index)의 영역 + 레포지토리 초기화된다.
- hard : local(working)까지 모든 영역을 초기화한다.

- ORIG_HEAD : reset을 취소할때도 hard, soft, mixed를 설정해야한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conflict-원리&quot;&gt;conflict 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 3way merge 를 통해서 오토 커밋이 가능하다. 
  - 3Way merge : base,a,b 셋을 고려해서 병합하는 방법
  - 2way merge : a,b (branch)를 둘을 이용해서 병합하는 방법

  3Way는 4가지 출돌 경우의 수가 존재한다.
    1. a,base가 같은 코드이고 b가 수정했을때 B로 병합된다.
    2. a,base,b가 모두 같은 코드를 가르킬때 같은 데이터로 병합된다.
    3. base와 a,b가 모두 다를때 충돌이 발생한다.
    4. b,base가 같고 a가 코드를 수정했을때 a의 코드로 병합된다. 

    3Way는 모두 다를때만 충돌 나고 ,2way는 같을때 뺴고는 모두 충돌난다. 

- 병합을 전문적으로 하는 kdiff3가 존재한다. intellij, sourtree 등 다양하다. 

- 충돌이 났을때는 base, local, remote 가 존재한다. 
  - base는 common파일이며, local,remote는 같은코드를 접근한 파일이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;remote-repository&quot;&gt;remote repository&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git init --bare : 저장소로서의 기능만 수능하는 init bare는 불변의 특징을 갖게하는것이다. 

- git remote add 경로 : 현재 디렉터리에 원격저장소 경로를 연결한다
- git push  : 원격 저장소에 데이터를 푸시(보낸다)
  - --set-upstream origin master : 마스터에서 푸시하면 자동으로 오리진 마스터에 푸시하겠다는 뜻
    : 로컬브랜치와 원격브랜치사이의 명시적인 설정 set-upstream 

- fork : fork를 하면 내가 특정 프로젝트를 내컴퓨터에서 사용할수있다. (복제)
  : 원격저장소에 복사된다. 
- git clone : 특정 원격 레포지토리를 다운로드한다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;원격-저장소의-원리&quot;&gt;원격 저장소의 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 로컬 master를 원격 저장소의 마스터에 연결해야한다. 
- remote를 하면 원격저장소를 위한 폴더(파일)이 생긴다. 
- 그리고 push --set-upstream origin master 를 하게 되면 각각 로컬과 원격저장소를 가르키는 파일들이 같은 커밋을 가르키게 된다. 
- 원격의 오리진과 지역의 마스터,HEAD르가 다를때 master를 orgin master에 push 하면 같은 커밋을 가르키게 되는것이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-pull-과-fetch의-차이&quot;&gt;git pull 과 fetch의 차이&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- pull : 원격과 로컬의 데이터가 차이가 없게 다운한다. HEAD, origin/master 가 같은 커밋을 가르킨다. 
  다운받고병합까지 할것이면 pull!!
- fetch : 원격저장소가 로컬저장소를 앞서게 된다. 
  이말은 무엇인가? : 원격저장소와 지역 저장소의 차이를 확인할수있다.    
  git diff등을 통하여 ex) git diff HEAD origin/master   
  그리고 이를 병합할수있다. git merge origin/master 같은 커밋을 가르키도록 병합할수있다.
  소스코드는 다운받지 않지만 차이점을 확인할때 fetch!!!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-tag&quot;&gt;git tag&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;branch와 비슷하지만 다르다. 

releases : 사용자들에게 제공되어도 되는 각각의 버전을 뜻한다. 
tab : 특정 커밋을 사용자가 다운로드하거나 기억할수있도록 하는것

- git tag 1.0.0 커밋id or 브랜치이름-&amp;gt; checkout을 통해서 특정 버전으로 갈수있다. 
- git tag - a 1.1.0 -m &quot;bug fix&quot; : annotated 를 설정할수잇다.  -a
  tag에 상세한 주석을 첨부할수있다.

- 원격 저장소에tag를 올릴수도 있다. git push --tag 
- tag 삭제 방법 : git tag -d 버전 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-tag-원리&quot;&gt;git tag 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tag를 생성하면 refs/tags/tag이름 파일이 생성된다.    
즉 tag는 텍스트 파일이다.   

이를 원격저장소 또는 로컬의 git에서 내부적으로 적용되는 방법은 workingtree, index, repository의 원리에 의해서 작동된다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-rebase&quot;&gt;git rebase&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rebase : 소스코드를 병합하는 하나의 방법이다.
  1. merge 병렬적으로 병합하지만 rebase는 임시저장소를 이용해 직렬적으로 병합한다. 
  2. 공통 base를 토대로 브런치를 직렬화하면서 병합한다. 

- git rebase branchName
- git rebase continue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/05/17/git-tip/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/05/17/git-tip/</guid>
        
        <category>git</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>면접 질문 리스트 &amp; 답변</title>
        <description>&lt;p&gt;라이브러리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;독립성을 가진 최소단위의 기능이다. (함수[메서드] 단위)
    &lt;ul&gt;
      &lt;li&gt;재사용 가능한 최소 단위 기능 또는 기능들의 집합이다.&lt;/li&gt;
      &lt;li&gt;기능을 사용하기 위해 다른 기능이 필요하지 않아야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이브러리의 예&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 정렬한다  () or 역 정렬한다().&lt;/li&gt;
  &lt;li&gt;데이터를 하닜기 반환한다. or 반한화면서 삭제한다.&lt;/li&gt;
  &lt;li&gt;날짜에서 요일을 반환한다.() or 날짜에서 시간을 반환한다().&lt;/li&gt;
  &lt;li&gt;숫자를 더한다 or 숫자를 곱한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이브러리 구분&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;표준 라이브러리
    &lt;ul&gt;
      &lt;li&gt;언어가 제공해주는 기본 함수 ##stdio.h , import java.util.* 등의 SDK들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 정의 라이브러리
    &lt;ul&gt;
      &lt;li&gt;표준 라이브러리를 사용하여 만든 라이브러리.&lt;/li&gt;
      &lt;li&gt;기능별로 그룹화 하여 Wrapping 한것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프레임 워크&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Library와 다른 Framework의 집합체이다.
    &lt;ul&gt;
      &lt;li&gt;여러 Library와 여러 Framework가 포함되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;library와 framework의 단점과 장점
단점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;느리다 무겁다. 비용이 많이 듣다.&lt;/li&gt;
  &lt;li&gt;통제가 안된다. (오픈소스는 가능)&lt;/li&gt;
  &lt;li&gt;세팅,학습하는데 오래걸린다.
  ex) juery를 전체 적용했다가 코어부분은 바닐라js 다시 구현하는경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개발이 편하다. 재사용이 가능하다. 개발일정이 단축된다.&lt;/li&gt;
  &lt;li&gt;전문적인 고민과 노하우가 있어서 오류가 적다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속도와 성능이 필요한 서버 개발만 native로 하면된다. 
성능과 개발 생산성을 함께 고려해야한다. 최적화가 필요하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;왜 이렇게 생각하는지 모두 적어보자&lt;/p&gt;

&lt;p&gt;질문&lt;/p&gt;

&lt;h2 id=&quot;rest-api는-무엇인가&quot;&gt;Rest API는 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;API 설계시에 리소스중심이며 HTTP Method를 통해 api를 설계하는것이 restful api입니다.&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;open API를 제공하기 쉽다.&lt;/li&gt;
      &lt;li&gt;멀티 플랫폼 지원이 용이히다.&lt;/li&gt;
      &lt;li&gt;원하는 타입으로 데이터를 주고 받을수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;http 통신 모델에 대해서만 지원한다.&lt;/li&gt;
      &lt;li&gt;분산환경에는 부적합하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;절차지향과-객체지향의-차이점은-무엇이며-장단점은-무엇인가-&quot;&gt;절차지향과 객체지향의 차이점은 무엇이며 장단점은 무엇인가 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;절차지향 : 수행되어야 할 연속적인 계산과 과정을 포함하고 있는 프로그래밍 패러다임입니다.&lt;/li&gt;
  &lt;li&gt;객체지향 : 강한 응집력과 약한 결합력을 위해 현실세계의 객체라는 개념을 이용한 프로그래밍 패러다임입니다.&lt;/li&gt;
  &lt;li&gt;공통점 : 모듈화된 프로그램구현 방법이 사용됩니다.&lt;/li&gt;
  &lt;li&gt;차이점 : 추상화, 다형성, 상속, 캡슐화을 통하여서 강한 응집력과 약한 결합력을 나타낼수있으며 이러한 특징을 통해서 재사용성이 용이합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-설계-5원칙&quot;&gt;객체지향 설계 5원칙&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;SRP(단일 책임 원칙) : 클래스와 메소드는 하나의 역할만 하도록 한다.&lt;/li&gt;
  &lt;li&gt;OCP(개방 폐쇠 원칙) : 자신의 확장은 개방하고, 변경은 (방지)한다.&lt;/li&gt;
  &lt;li&gt;LSP(리스코프 치환 원칙) : 서브타입은 언제나 자신의 상위타입으로 교체할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;ISP(인터페이스 분리 원칙) : 객체는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.&lt;/li&gt;
  &lt;li&gt;DIP(의존 역전 원칙) : 자신보다 변하기 쉬운것에 의존하지 마라
    &lt;ul&gt;
      &lt;li&gt;추상화된것에 구체적인것이 의존해야한다. 이것의 반대가 되면 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;데이터-타입과-변수의-차이는-뭔가요&quot;&gt;데이터 타입과 변수의 차이는 뭔가요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 타입 : 컴퓨터에서 값을 식별하기위한 식별자입니다.
    &lt;ul&gt;
      &lt;li&gt;프로그램을 실행하지 않고도 결정할 수있는 프로그램의 특성으로 정의 됩니다.&lt;/li&gt;
      &lt;li&gt;기본타입과 참조타입으로 나눠집니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변수 : 특정 데이터 타입에서 변할수있는 값저장소 라고 말할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;차이점 :  둘의 차이는 계층이 다르다고 생각합니다. 데이터타입이 더 상위 계층이라고 생각합니다.
    &lt;ul&gt;
      &lt;li&gt;변수의 값은 범위내에서 변할수있는 데이터 이지만 데이터 타입은 임의적으로 변화해서는 안되는 변수를 표현하는 데이터 형식이라고 생각합니다.&lt;/li&gt;
      &lt;li&gt;변수는 데이터 타입에 종속적입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;밸류타입과-레퍼런스-타입이-무엇인가요-대표적인것을-예로-들어&quot;&gt;밸류타입과 레퍼런스 타입이 무엇인가요 (대표적인것을 예로 들어)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;밸류타입 : 메모리 호출시 메모리에 저장되어있는 값을 복사하는 타입 (primitive type) 타입&lt;/li&gt;
  &lt;li&gt;레퍼런스 : 메모리 호출시 메모리에 저장되어있는 주소 값을 복사하는 타입 (배열,클래스,열거,인터페이스) 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문자열은-char형과-string형으로-나눠진-이유는-뭔가요-&quot;&gt;문자열은 char형과 string형으로 나눠진 이유는 뭔가요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;string 형은 string 클래스 이고 참조타입니다.&lt;/li&gt;
  &lt;li&gt;이는 char배열에 여러가지 메소드를 추가한것이 string 클래스입니다.&lt;/li&gt;
  &lt;li&gt;char배열을 라이브러리로 만든것이 string 클래스라고 할수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;힙과-스택-영역에-대해서-설명할수있나요&quot;&gt;힙과 스택 영역에 대해서 설명할수있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JVM : OS의 한정된 메모리를 효율적으로 사용하기 위한 스택기반의 가상머신(메모리관리, GC)입니다.&lt;/li&gt;
  &lt;li&gt;클래스 로더 : JVM 내에서 클래스를 로드하고 링크하는 역할, JVM위에서 사용하지 않는 클래스들은 메모리에서 삭제되며, 런타임에 참조된다.&lt;/li&gt;
  &lt;li&gt;Execution Engine : 변환된 파일을 실행시키는 역할, 자바 바이트 코드를 기계가 실행할 수 있는 형태로 변경된 코드를 실행한다.&lt;/li&gt;
  &lt;li&gt;GC : 힙영역의 메모리해제를 관리하는 기능입니다. 참조되지 않은 객체, 자주 사용되는 객체, 메모리 할당된 객체를 중점으로 GC가 힙영역의 메모리를 관리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스택이-존재하는-이유는-무엇인가요-&quot;&gt;스택이 존재하는 이유는 무엇인가요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;독립적인 메모리공간을 위해서 스택이 존재합니다. 독립적으로 사용될 변수, 되돌아갈 주소 등을 저장하기 위해서 스택이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals-과--연산자의-차이가-무엇인가요&quot;&gt;equals() 과 == 연산자의 차이가 무엇인가요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;equal함수는 데이터값만 같으면 참거짓을 반환하고 ==은 객체(주소값) 와 데이터 값이 같아야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals에서-객체가-같음을-어떻게-비교-할까요-&quot;&gt;equals에서 객체가 같음을 어떻게 비교 할까요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최종적으로는 == 연산자를 통해서 비교하지만 이를 위해서 형변환 및 equals 오버라이딩이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new는-왜-생성하나요-&quot;&gt;new는 왜 생성하나요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;제한되어 있는 메모리를 효율적으로 사용하기 위해서 new를 사용합니다.&lt;/li&gt;
  &lt;li&gt;이는 heap 영역에서 데이터를 관리하여 메모리를 효율적으로 사용할수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;Eden, old Memory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해쉬코드에-대해서-설명하라&quot;&gt;해쉬코드에 대해서 설명하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;해시(임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변화시키는)자료구조를 통해서 도출된 임의의 값을 생성하는 코드가 해시 코드이다. 자바에서는 이를 통해 객체의 값을 비교 한다. 해시는 해시함수, 해시테이블 등으로 구성되며 충돌이 일어나지 않게 구성해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시의-충돌-해결-방법&quot;&gt;해시의 충돌 해결 방법&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;open Address방식
    &lt;ul&gt;
      &lt;li&gt;해시 충돌이 발생하면, 다른 해시버킷에 해당 자료를 삽입하는 방식이다.&lt;/li&gt;
      &lt;li&gt;충돌이 발생하면 다른 버킷을 찾는데 worstCase의 경우에는 충돌을 해결치 못하고 다시 원상태로 되돌아올수도 있다.&lt;/li&gt;
      &lt;li&gt;linear probing : 버킷을 포함하는 해시테이블의 인덱스를 하나씩 늘려 버킷이 비었는지 확인한다.&lt;/li&gt;
      &lt;li&gt;Quadratic probing : 충돌 발생시 i^2으로 공간이 비었는지 확인한다.&lt;/li&gt;
      &lt;li&gt;DoubleHashing Probing : 해시된 결과값을 한번더 해시한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;seperate chaining
    &lt;ul&gt;
      &lt;li&gt;충돌이 발생하면 충돌지점에 리스트 &amp;amp; 트리 자료구조를 이용해서 충돌 데이터를 저장하는 방법입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장단점
    &lt;ul&gt;
      &lt;li&gt;오픈 어드레스 방법은 삭제하기 어렵다는 단점이 존재하고 버킷을 늘리면 배열과 다를바가 없어 효율적이지 않다.&lt;/li&gt;
      &lt;li&gt;체이닝 기법은 상대적으로 효과적인데 리스트로 충돌을 연결하면 연결할때마다 오버헤드를 감수해야하고 검색시 O(N)이된다.&lt;/li&gt;
      &lt;li&gt;체이닝 기법에서 트리를 사용하면 O(logN)으로 검색을 진행할수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;해쉬코드를-이용해서-같은-객체인지-비교하는-방법은-무엇인가요&quot;&gt;해쉬코드를 이용해서 같은 객체인지 비교하는 방법은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;해시코드를 이용해서 리턴값이 같은지 확인하여 같은객체 인지 확인하고 equals 메서드를 통해서 비교값이 같은지 확인합니다. 해시코드와 equals를 오버라이딩을 통해 값을 비교한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals-오버라이딩&quot;&gt;.equals() 오버라이딩&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;object 타입을 통해서 equals를 오버라이딩 하여 비교 할수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자바의-메모리-구조&quot;&gt;자바의 메모리 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;.java » javac가 컴파일 » .class(자바 바이트코드) » 클래스로더 &amp;lt;-&amp;gt; 익스쿠션엔진 » JVM&lt;/li&gt;
  &lt;li&gt;메모리는 JVM의 Runtime Data Areas에서 관리한다.&lt;/li&gt;
  &lt;li&gt;크게 staticArea , HeapArea , StackArea로 구분할수있다.&lt;/li&gt;
  &lt;li&gt;Method(static) : 클래스,인터페이스의 런타임상수,멤버변수, 생성자와 메소드를 저장하는 공간이다.&lt;/li&gt;
  &lt;li&gt;Heap : 런타임시 동적으로 메모리를 사용하는 영역 ,GC의 대상이된다.&lt;/li&gt;
  &lt;li&gt;Stack : 스레드마다 하나씩 존재하며, 스레드가 시작될때 할당한다. 자바의 primitive 타입, 메소드정보 , 지역변수, 등의 데이터를 저장한다. 또한 메서드 호출시 스레드정보 또한 stack에 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;string-pool이-무엇인가요&quot;&gt;string pool이 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;literal로 생성한 값이 string pool에 들어갑니다. 힙영역내의 literal로 생성한 string은 이에 들어가고 같은 값이 호출시에 string pool을 참조하여 객체를 리턴합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;멤버변수와-지역변수의-차이와-stack영역에-저장되는-변수는-누구인가요&quot;&gt;멤버변수와 지역변수의 차이와 stack영역에 저장되는 변수는 누구인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;stack에 저장되는 변수는 지역변수입니다. 멤버변수는 클래스의 내부변수이므로 Method Areas에 저장됩니다. 반면 지역변수는 스레드와 관계 있는 영역이므로 독립적인 stack에 저장되고 메모리영역의 차이가 둘의 차이입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스택영역와-힙영역의-변수들은-언제-해제가-되나요&quot;&gt;스택영역와 힙영역의 변수들은 언제 해제가 되나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스택영역의 변수들은 스레드 종료시 즉 해제 됩니다. 특정메소드 호출이 종료되거나 스레드가 종료되며 stack에 할당된 데이터는 해제 됩니다.&lt;/li&gt;
  &lt;li&gt;힙영역의 변수들은 명시적으로 해제 해주거나 GC에 의해서 해제가 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어떤-자료구조가-있는가&quot;&gt;어떤 자료구조가 있는가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열,리스트,스택,큐,덱,해싱, 그래프, 트리 등이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료구조를-선택하는-기준은-무엇인가요&quot;&gt;자료구조를 선택하는 기준은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;효율성입니다. 시간, 공간 복잡도를 고려한 효율적인 자료구조를 선택해야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listsetmap에-대해서-설명할수있나요&quot;&gt;list,set,map에 대해서 설명할수있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;list : 순서가 있는 데이터의 집합이며 중복을 허용합니다.&lt;/li&gt;
  &lt;li&gt;set : 순서가 없는 데이터의 집합이며 중복을 허용하지 않습니다. 키 == 밸류&lt;/li&gt;
  &lt;li&gt;map : 키밸류스토어 구조로 이루어진 데이터의 집합이며 키값은 중복 허용하지 않으며 밸류는 중복을 허용합니다.&lt;/li&gt;
  &lt;li&gt;list,set,map은 데이터를 저장하기위한 자료구조 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listsetmap-어떤-인터페이스를-구현하고-있나요&quot;&gt;list,set,map 어떤 인터페이스를 구현하고 있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;list,set은 컬렉션 인터페이스를 구현하고 있고, map은 k,v구조로 이루어진 인터페이스 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;foreach를-사용할수있는-자료구조는-어떠한-인터페이스를-상속받고-있나요&quot;&gt;foreach를 사용할수있는 자료구조는 어떠한 인터페이스를 상속받고 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;collection 구현체들이 foreach를 사용할수있습니다. collection은 iterable interface를 상속받고 있기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;foreach를-사용하기-위한-내부적-메소드는-무엇인가요&quot;&gt;foreach를 사용하기 위한 내부적 메소드는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;foreach는 내부적으로 itertor() 호출하여 이를 통해서 loop를 진행합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator와-iterable의-차이점은-무엇인가요&quot;&gt;iterator와 iterable의 차이점은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;iterable은 foreach와 iterator를 갖는 인터페이스 입니다.&lt;/li&gt;
  &lt;li&gt;iterator는 collection을 지원하기 위한 인터페이스로서 collection 데이터를 읽어올때 사용된다.&lt;/li&gt;
  &lt;li&gt;차이점 : iterator를 이용하면 collection 탐색시에 요소를 삭제하거나 다음 요소를 인덱스가 있는것처럼 활용할수있다. next,remove등의 메소드를 통해서 하지만 iterable의 foreach를 사용하면 collection의 요소를 삭제하거나 특정 요소를 확인할수있는 방법이없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator를-상속받으면-구현해야-하는-메서드는-무엇인가요&quot;&gt;iterator를 상속받으면 구현해야 하는 메서드는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HasNext를 구현해야합니다. (overriding) 그래야 내부적으로 다음 요소를 확인할수있으므로&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열-size변경이-가능한가요&quot;&gt;배열 size변경이 가능한가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 사이즈 변경은 불가능 합니다. 힙영역에 사이즈만큼 주소값을 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열에-10개의-데이터가-있는데-5개의-배열로-줄이고-싶을떄-어떻게-해야하는가&quot;&gt;배열에 10개의 데이터가 있는데 5개의 배열로 줄이고 싶을떄 어떻게 해야하는가.?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 사이즈를 변경하기 위해서는 재할당하고, 배열의 값을 복사해야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;size가-변경될-경우에는-어떠한-자료구조를-사용하는것이-좋을까요&quot;&gt;Size가 변경될 경우에는 어떠한 자료구조를 사용하는것이 좋을까요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터가 많을때는 링크드리스트가 좋으며 , 적을때는 배열이 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;가변-자료구조는-어떤게-있나요&quot;&gt;가변 자료구조는 어떤게 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링크드리스트, 트리 등 Node의 개념을 사용하는 자료구조가 가변적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입과-none-gerneric-타입의-차이를-설명해주세요&quot;&gt;gerneric타입과 none gerneric 타입의 차이를 설명해주세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;gerneric : 데이터 타입을 제한하지 않고 사용할 수 있게 해주는 매개변수화된 타입입니다.&lt;/li&gt;
  &lt;li&gt;none gerneric : 제너릭을 사용하지 않고 모든 순간 타입을 확인하며 형변환 해야하는 타입&lt;/li&gt;
  &lt;li&gt;차이점 : 코드의 재사용성에 차이가 존재하며, 에러 검출시 차이점이 존재합니다. 제너릭은 컴파일 시점에 넌제너릭은 런타임 시점에 에러를 검출하는 차이점이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입-종류는-무엇이-있나요&quot;&gt;gerneric타입 종류는 무엇이 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수화 타입&lt;/li&gt;
  &lt;li&gt;언바운드 와일드카드 타입&lt;/li&gt;
  &lt;li&gt;바운드 타입 매개변수&lt;/li&gt;
  &lt;li&gt;재귀적 타입 바운드&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입--장점은-무엇인가요---object사용하면-되는데&quot;&gt;gerneric타입  장점은 무엇인가요  ? object사용하면 되는데?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;제너릭으로 설정하면 자바가 타입을 확인해 주어 코드상으로 더욱 편한 이점이 존재합니다. 이를 통해 코드의 안전성을 줄수있습니다. object를 사용하면 가능하지만 형변환 할때마다 오버헤드가 존재하므로 제너릭 사용시 이러한 오버헤드를 줄일수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist와-linkedlist의-차이를-설명하세요&quot;&gt;ArrayList와 linkedList의 차이를 설명하세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;동적으로 사이즈를 할당할수있냐 없냐의 차이입니다. arraylist는 동적으로 배열을 할당할수없습니다. 배열의 사이즈를 늘리고 복사하는 방법인 반면에 linkedList는 인덱스 기반이 아닌 sequence 기반으로 동적하기 때문에 데이터의 추가삭제를 위한 동적 사이즈를 늘리를 것에 효율적입니다. 이는 메모리상에서도 동일합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터를-순차적으로-찾을때-가장-적합한-것은-어느것인가요&quot;&gt;데이터를 순차적으로 찾을때 가장 적합한 것은 어느것인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;순차적으로 찾을때는 ArrayList를 사용하는것이 좋습니다. 왜냐하면 인덱스를 기반으로 빠른 탐색이 가능하기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터를-빈번하게-삭제하거나-추가할때-사용하는-자료구조는-어떤것인가요--왜-&quot;&gt;데이터를 빈번하게 삭제하거나 추가할때 사용하는 자료구조는 어떤것인가요?  왜 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;linkedList 자료구조를 사용해야 합니다. arraylist는 내부적으로 삭제 삽입시 사이즈를 고려해여 데이터를 shit해야합니다. 하지만 linkedList는 지정된 요소의 주소에 주소값을 연결하기 때문에 linkedList가 효율적입니다. 손쉽게 데이터를 추가/삭제 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist에서-데이터를-중간에-삭제하면-어떻게-동작하나요&quot;&gt;ArrayList에서 데이터를 중간에 삭제하면 어떻게 동작하나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 인덱스를 찾고 그값을 삭제하면 뒤에있는 데이터들을 삭제한곳부터 한칸식 shift합니다. 중간데이터 하나를 삭제하면 뒤의 모든 데이터를 옮겨야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist와-list중에-검색속도가-빠른것은-무엇이고-느린것은-무엇인가&quot;&gt;Arraylist와 list중에 검색속도가 빠른것은 무엇이고 느린것은 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검색속도가 빠른것은 arrayList입니다. 이는 인덱스를 기반으로 O(1)복잡도로 데이터를 찾을수있습니다.&lt;/li&gt;
  &lt;li&gt;느린것은 linkList이고 리스트는 인덱스 기반이 아니라 Node를 통해서 값인지 아닌지를 확인해야 하기때문에 O(n) 시간복잡도가 걸립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linkedlist의-내부적인-동작방법&quot;&gt;linkedlist의 내부적인 동작방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주소를 가르키는 node와 값을 넣는 data로 구성되어있습니다. 데이터가 추가 삭제 되면 node에 새로운 데이터와 연결하거나 삭제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;map을-사용해야하는경우는-무엇인가요&quot;&gt;map을 사용해야하는경우는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 데이터를 빠르게 검색하고 싶을때 사용합니다. 데이터를 검색할시 key를 이용해서 검색하면 O(1)에 검색 가능하기 때문입니다. map의 key는 중복되지 않기 떄문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시테이블과-해시맵의-차이는&quot;&gt;해시테이블과 해시맵의 차이는&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공통점 : k,v 구조이며 k 는 중복이 없다. v는 중복가능하다.&lt;/li&gt;
  &lt;li&gt;차이점 :
    &lt;ul&gt;
      &lt;li&gt;hashtable은 동기화 되기 떄문에 thread-safe 하지만 HashMap은 동기화 되지 않기 때문에 thread-safe 하지 않는다. 그렇기에 멀티 쓰레드 환경이 아니아면 Hashtable은 HashMap보다 성능이 떨어집니다.&lt;/li&gt;
      &lt;li&gt;HashTable은 key에 null을 허용하지 않습니다. 하지만 HashMap은 key에 null을 허용합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택의-차이를-설명해주세요&quot;&gt;큐와 스택의 차이를 설명해주세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 선입선출이고, 스택은 후입선출입니다. input에 대비하여 output이 다른 차이가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택의-사용-예를-하나씩-설명하라&quot;&gt;큐와 스택의 사용 예를 하나씩 설명하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 스케줄링 관리시스템, 배치 시스템등&lt;/li&gt;
  &lt;li&gt;스택은 웹/앱 브라우저 방문기록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택은-내부적으로-어떤-자료구조를-사용했나요&quot;&gt;큐와 스택은 내부적으로 어떤 자료구조를 사용했나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 리스트, 스택은 백터를 사용하였는데 결국 내부적으로 콜렉션을 사용하였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택을-직접-구현할때-사용해야하는-자료구조는&quot;&gt;큐와 스택을 직접 구현할때 사용해야하는 자료구조는?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스택은 배열을 통해서 큐는 링크드리스트를 통해서 구현하는게 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;우선순위-큐에-대해서-말하라&quot;&gt;우선순위 큐에 대해서 말하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐에서 내부적으로 정렬이 되어있는 경우를 뜻합니다. 정렬은 최소힙과 최대힙을 통해서 구현되어있습니다.&lt;/li&gt;
  &lt;li&gt;힙 : 이진트리를 이용하여 root부터 leaf까지 특정 차순으로 정렬되어있는 구조를 힙이라고 합니다. 오름차순된 힙은 최소힙이며 내림차순된 힙은 최대힙입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트리에-대해서-설명하라--다른-자료구조들과-차이점은-무엇인가-&quot;&gt;트리에 대해서 설명하라 ? 다른 자료구조들과 차이점은 무엇인가 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;트리는 비선형 자료구조입니다.&lt;/li&gt;
  &lt;li&gt;계층구조를 나타내는 자료구조이며 노드 N인 트리는 n-1 간선을 갖는 특징이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어떤경우에-사용하는것이-좋은가&quot;&gt;어떤경우에 사용하는것이 좋은가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;계층화된 데이터 표현할때 사용합니다. 목차, 디렉토리, 카테고리 등&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이진트리를-설명하세요&quot;&gt;이진트리를 설명하세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;노드의 자식의 수가 2개로 이루어지는 트리를 이진트리라고 합니다. 이진트리는 검색,정렬 할 때 효율적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비트리는-내부적인-노드를-어떤것을-가지고-있는가&quot;&gt;비트리는 내부적인 노드를 어떤것을 가지고 있는가?&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리-에-대해서-설명해주세요&quot;&gt;이진검색트리 에 대해서 설명해주세요&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리와-비트리의-내부적인-차이는-&quot;&gt;이진검색트리와 비트리의 내부적인 차이는 ?&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리에서-가장-느린-검색이-되는-경우&quot;&gt;이진검색트리에서 가장 느린 검색이 되는 경우&lt;/h2&gt;

&lt;h2 id=&quot;동기비동기-란-무엇인가&quot;&gt;동기/비동기 란 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;critical section(임계영역)에서 반환값을 기대할수 있는 경우를 동기화 라고 표현하고 반대의 경우를 비동기하고 표현합니다.&lt;/li&gt;
  &lt;li&gt;critical section은 독립성을 유지 해야합니다.&lt;/li&gt;
  &lt;li&gt;실행중인 critical section이 존재할때 종료후에 반환값을 기대하면 동기화된것이고 critical section 실행중에 값의 변화가 진행되면(공유) 비동기화라고 표현합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;동기화를-지원하는-자료구조는&quot;&gt;동기화를 지원하는 자료구조는?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;백터,해쉬테이블, synchronizedList(),synchronizedSet(),synchronizedMap() 을 제공한다&lt;/li&gt;
  &lt;li&gt;현재는 ConcurrentHashMap, ConcurrentLinkedListQueue 의 성능이 더 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;동기화를-지원하는-자료구조는-왜--언제-필요할까요&quot;&gt;동기화를 지원하는 자료구조는 왜 , 언제 필요할까요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;멀티쓰레드 환경에서 즉 쓰레드간 데이터를 공유해야할때 동기화된 (스레드세잎)한 자료구조가 필요합니다. 쓰레드끼리 공유데이터 접근시에 쓰레드세잎하지 않으면 데이터의 값이 예상치 못하게 변경되기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring&quot;&gt;Spring&lt;/h2&gt;
&lt;p&gt;자바진형 프레임워크로 자바 베이직 라이브러리와 웹,앱을 위한 다양한 라이브러리가 제공됩니다. 또한 jdbc를 인터페이스로 다양한 DB를 ORM할수있도록 JPA,security 등 하위 프레임워크를 내포하고있어 개발자의 생산성을 돕습니다.&lt;/p&gt;

&lt;p&gt;그리고 DI,IoC등의 개념을 통해서 객체지향적 프로그램 지향하도록 설계된 프레임워크가 spring입니다.&lt;/p&gt;

&lt;h2 id=&quot;di&quot;&gt;DI&lt;/h2&gt;
&lt;p&gt;dependency Injection 으로 객체지향 원리중 DIP에 해당합니다. 객체내부에 동적으로 객체를 생성하는것이 아닌 객체의 인스턴스를 설정하고 생성자,set,필드 통해서 객체를 생성하는 방식입니다.&lt;/p&gt;

&lt;h2 id=&quot;ioc&quot;&gt;IoC&lt;/h2&gt;
&lt;p&gt;spring에서 Bean을 관리해주는 컨테이너 입니다. IoC에서 빈을 관리하고 애노테이션 스캔을 통해서 DI를 하게 되는데 의존객체가 주체가아닌 IoC 컨테이너에서 빈을 관리하기 때문에 IoC라는 명칭이 붙게 되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;aop&quot;&gt;AoP&lt;/h2&gt;
&lt;p&gt;중복된 코드를 aspect를 이용해서 모듈화 할수있고 이를 특정 위치에 사용할수있는 방법이 AoP입니다. 
  target, advice, PointCut으로 구성되어있습니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa&quot;&gt;JPA&lt;/h2&gt;
&lt;p&gt;spring의 데이터베이스 연동하는 기능이며 객체스타일로 DB를 연동할수있습니다. 또한 영속성이라는 기능을 통해서 DB의 많은 접근을 하지 않아도 되는 이점이 존재하고, DB설정을 java로 설정할수있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;
&lt;p&gt;model, view, controller 를 통해서 구성된 소프트웨어 디자인 패턴입니다. 각 계층을 통해서 명시적으로 업무를 분할 할수있는 장점이 있고 이를 통해서 업무를 분담할수있습니다. 확장성이 용이합니다. 유지보수 비용을 절감할 수 있습니다.&lt;/p&gt;

&lt;p&gt;동작과정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;disPatherServlet에서 요청이 들어옴&lt;/li&gt;
  &lt;li&gt;핸들러매핑(핸들러조회(controller)) 한다.&lt;/li&gt;
  &lt;li&gt;핸들러를 사용할수있는 어댑터가 있는지  조회한다.&lt;/li&gt;
  &lt;li&gt;핸들러 어탭터 실행&lt;/li&gt;
  &lt;li&gt;핸들러 실행(controller가 실행됨)&lt;/li&gt;
  &lt;li&gt;controller 반환값을 핸들러 어탭터에 반환하고 어댑터는 dispatcherServlet에 modelAndView 반환&lt;/li&gt;
  &lt;li&gt;viewResolver 호출&lt;/li&gt;
  &lt;li&gt;viewResolver가 view에 맞는 객체로 변환하여 dispatcherSerlver으로 반환&lt;/li&gt;
  &lt;li&gt;dispatcherSerlver view에 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;security&quot;&gt;Security&lt;/h2&gt;
&lt;p&gt;인증과 허가를 담당하는 하위 프레임워크입니다.&lt;/p&gt;

&lt;h2 id=&quot;쓰레드풀&quot;&gt;쓰레드풀&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;쓰레드풀을 요청시마다 생성할때 단점
    &lt;ol&gt;
      &lt;li&gt;스레드 교환시 컨텍스트 스위칭이 일어나 오버헤드가 발생합니다. 요청이들어올때마다 스레드를 생성하면 비용이 매우 비쌉니다. 또한 서버의 resource를 효율적으로 사용치 못합니다.&lt;/li&gt;
      &lt;li&gt;cpu,memory의 임계점을 넘는 요청이 들어오면 서버가 터질 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;쓰레드풀을 요청시마다 생성할때 장점
    &lt;ol&gt;
      &lt;li&gt;동시 요청을 수행할수있습니다.&lt;/li&gt;
      &lt;li&gt;자원을 모두 소모할수있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드풀 사용 장점
    &lt;ol&gt;
      &lt;li&gt;쓰레드풀은 이런 쓰레드를 보관 및 관리하는 기능입니다. 미리 생성 가능한 쓰레드의 최대치를 관리하며 쓰레드 대기,거절등을 수행할수있습니다. 이를통해 생성및 종료 하는 비용을 줄일수있습니다.(cpu비용절감)&lt;/li&gt;
      &lt;li&gt;쓰레드풀 최대치가 존재함으로 많은 요청이 들어와도 서버가 죽지 않고 기존 요청을 처리할수있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드풀 사용 단점
    &lt;ol&gt;
      &lt;li&gt;스레드풀의 최적사이즈를 알기 어렵습니다. 너무 많으면 서버가 죽고 너무 적으면 서버 응답지연&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssr--csr&quot;&gt;SSR &amp;amp; CSR&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSR : 서버사이드 렌더링으로 서버측에서 최종 HTML 구성하여 보내는 방법을뜻합니다.&lt;/li&gt;
  &lt;li&gt;CSR : 클라이언트 측에서 서버로 부터 받은 데이터를 가지고 클라이언트측에서 동적으로 페이지를 구성하는 방법입니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/05/02/javaInterviewQuestion/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/05/02/javaInterviewQuestion/</guid>
        
        <category>interview</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>querydsl</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-study&quot;&gt;spring study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;querydsl-설정&quot;&gt;querydsl 설정&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [build.gradle ]
  plugins{ 
  //querydsl 추가
  id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot;
  }

  //querydsl 추가 시작
  def querydslDir = &quot;$buildDir/generated/querydsl&quot;
  querydsl {
      jpa = true
      querydslSourcesDir = querydslDir
  }
  sourceSets {
      main.java.srcDir querydslDir
  }
  configurations {
      querydsl.extendsFrom compileClasspath
  }
  compileQuerydsl {
      options.annotationProcessorPath = configurations.querydsl
  }
 //querydsl 추가 끝
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;querydsl-기본문법&quot;&gt;querydsl 기본문법&lt;/h2&gt;

&lt;p&gt;querydsl 사용에 있어서 JPAQueryFactory를 DI해야한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Q파일을 가져다가 사용할수있다. Q파일의 alias를 선언하여 JPQL의 alias를 대신할수있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Test
    public void search() throws Exception {
        //given

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;)
                        .and(member.age.eq(10)))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     *
     * member.username.eq(&quot;member1&quot;) // username = 'member1'
     * member.username.ne(&quot;member1&quot;) // username != 'member1'
     * member.username.eq(&quot;member1&quot;).not() // username != 'member1'
     *
     * member.username.isNotNull() // 이름이 is not null
     *
     * member.age.in(10,20) // age in (10,20)
     * member.age.notIn(10,20) // age not in(10,20)
     * member.age.between(10,30) // between 10,30
     *
     * member.age.goe(30) //age &amp;gt;= 30
     * member.age.gt(30) // age &amp;gt; 30
     * member.age.loe(30) // age &amp;lt;= 30
     * member.age.lt(30) // agr &amp;lt; 30
     *
     * member.username.like(&quot;member%&quot;) // like
     * member.username.contains(&quot;member&quot;) // like '%member%'
     * member.username.startWith(&quot;member&quot;) // like 'member%'
     *
     */
    @Test
    public void searchAndParam(){
        List&amp;lt;Member&amp;gt; findMembers = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;),
                        member.age.eq(10))
                .fetch();

        Member findMember = findMembers.get(0);

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     * fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환
     * fetchOne() : 단건 조회
     *  - 결과가 없으면 null
     *  - 결과가 둘이상이면 com.querydsl.core.NonUniqueResultException
     * fetchFirst() : limit(1).fetchOne()
     * fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
     * fetchCount() : count 쿼리로 변경해서 count수 조회
    *
     * @throws Exception
     */
    @Test
    public void fetchResult() throws Exception{

  //        List&amp;lt;Member&amp;gt; fetch = queryFactory
  //                .select(member)
  //                .from(member)
  //                .fetch();
  //
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchOne();
  //        
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchFirst();

  //        QueryResults&amp;lt;Member&amp;gt; result = queryFactory
  //                .select(member)
  //                .from(member)
  //                .offset(0)
  //                .limit(2)
  //                .fetchResults();
  //
  //
  //        assertThat(result.getLimit()).isEqualTo(2);
  //        assertThat(result.getOffset()).isEqualTo(0);
  //        assertThat(result.getTotal()).isEqualTo(4);
  //
  //
  //        for (Member resultResult : result.getResults()) {
  //            System.out.println(&quot;resultResult = &quot; + resultResult);
  //        }

  //        long count = queryFactory
  //                .selectFrom(member)
  //                .fetchCount();


  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;정렬및집합&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Test
    public void sort() throws Exception{
        //given
        em.persist(new Member(null,100));
        em.persist(new Member(&quot;member5&quot;,100));
        em.persist(new Member(&quot;member6&quot;,100));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(100))
                .orderBy(member.age.desc(),
                        member.username.asc().nullsLast())
                .fetch();

        //when

        //then

        Member member5 = result.get(0);
        Member member6 = result.get(1);
        Member memberNull = result.get(2);

        assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;);
        assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;);
        assertThat(memberNull.getUsername()).isNull();
    }


    /**
     * 집합 함수
     * select
     *   COUNT(m),
     *   SUM(m.age),
     *   AVG(m.age),
     *   MAX(m.age),
     *   MIN(m.age)
     * from Member m
     */
    @Test
    public void aggregation() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member.count(),
                        member.age.sum(),
                        member.age.avg(),
                        member.age.min(),
                        member.age.max())
                .from(member)
                .fetch();
        //when

        //then

        Tuple tuple = result.get(0);
        assertThat(tuple.get(member.count())).isEqualTo(4);
        assertThat(tuple.get(member.age.sum())).isEqualTo(100);
        assertThat(tuple.get(member.age.avg())).isEqualTo(25);
        assertThat(tuple.get(member.age.max())).isEqualTo(40);
        assertThat(tuple.get(member.age.min())).isEqualTo(10);
    }

    /**
     * GroupBy 사용
     * 팀의 이름과 각 팀의 평균 연령을 구해라
     *
     * @throws Exception
     */
    @Test
    public void GroupByTest() throws Exception{
        //given
        em.persist(new Team(&quot;teamC&quot;));
        em.persist(new Member(&quot;member5&quot;,50,null));


        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(team.name,member.age.avg())
                .from(member)
                .join(member.team,team)
  //                .LeftJoin(member.team,team)
                .groupBy(team.name)
                .fetch();
        //when
        //then

  //        Tuple teamA = result.get(0);
  //        Tuple teamB = result.get(1);
  //
  //        assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;);
  //        assertThat(teamA.get(member.age.avg())).isEqualTo(15);
  //
  //        assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;);
  //        assertThat(teamB.get(member.age.avg())).isEqualTo(35);

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   /**
     *
     * join() : innerJoin()
     * leftJoin() : left 외부조인
     * rightJoin() : right 외부조인
     * @throws Exception
     */
    @Test
    public void join() throws Exception{
        //given
        QMember qMember = member;
        QTeam qTeam = QTeam.team;

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when

        //then
        assertThat(result)
                .extracting(&quot;username&quot;) // 결과에서 추출
                .containsExactly(&quot;member1&quot;,&quot;member2&quot;); // 포함하고 있는지확인

        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     *
     * from절에 여러 엔티티를 선택해서 세타조인 할수있다.
     * 하지만 세타조인시 외부조인 불가능하다
     *
     * @throws Exception
     */
    @Test
    public void theta_join() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member,team)
                .where(member.username.eq(team.name))
                .fetch();

        //when
        //then
        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     * 외부조인하는 방법
     * on절을 활용해 조인 대상을 필터링 할때, 외부조인이 아니라 내부조인을 사용하면,
     * where절에서 필터링 하는것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링
     * 을 사용할때, 내부조인이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만
     * 이 기능을 사용하자.
     *
     * @throws Exception
     */
    @Test
    public void join_on_fittering() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
 //                .leftJoin(member.team,team).on(team.name.eq(&quot;teamA&quot;))
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when
        //then

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * 연관관계없는 엔티티 외부조인
     * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
     * JPQL: select m,t from member m left join team t on m.username = t.name
     * SQL : select m.*,t.* from Member m left join  Team t on m.username = t.name
     *
     * 서로 연관관계가 없으니 leftJoin()에서 하나의 엔티티만 들어간다.
     */

    @Test
    public void join_on_no_relation() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
                .leftJoin(team).on(member.username.eq(team.name))
                .fetch();
        //when

        //then
        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * fetch join 적용
     *  join(member.team, team).fetchjoin()
     *  위와같은 방식으로 사용하면된다.
     *  join()에 엔티티를 잘 넣어줘야한다. 그래서 같은 영속성 컨텍스트에서 id를 가져옴
     *
     */

    @PersistenceUnit
    EntityManagerFactory emf;

    @Test
    public void fetch_NO_join_test() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();
        //when
        //then

        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).as(&quot;페치조인 미적용&quot;).isFalse();
    }

    @Test
    public void fetchJoin() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team).fetchJoin()
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        //when
        //then
        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).isTrue();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;서브쿼리,concat&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
     * 서브쿼리
     * com.querydsl.jpa.JPAExpressions 사용한다.
     *
     * 서브쿼리는 select, where절에만 사용가능하다.
     *
     *
     * 예제 1) 나이가 가장 많은 회원 조회
     * 예제 2) 나이가 평균 나이 이상인 회원
     * 예제 3) 서브쿼리 여러건 처리, in 사용
     * 예제 4) select절에 서브쿼리 사용
     *
     * JPAExpressions &amp;lt;&amp;lt; static import 가능
     *
     * from절에 서브쿼리 안된다. JPA에서는 이를 해결하는 방안은
     * 1. 서브쿼리를 join으로 변경한다.(가능한 상황도 있고,불가능한 상황도 있다.
     * 2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
     * 3. nativeSQL을 사용한다.
     *
     */
    @Test
    public void subQuery() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);

 //        예제1
        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(
                        select(memberSub.age.max())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result).extracting(&quot;age&quot;)
                .containsExactly(40);
    }

    @Test
    public void subQuery2() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.goe(
                        select(memberSub.age.avg())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(30,40);
    }

    @Test
    public void subQuery3() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.in(
                            select(memberSub.age)
                                .from(memberSub)
                                .where(memberSub.age.gt(10))
                ))
                .fetch();

        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(20,30,40);

        for (Member member1 : result2) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    @Test
    public void subQuery4() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Tuple&amp;gt; result2 = queryFactory
                .select(member.username,
                        select(memberSub.age.avg())
                                .from(memberSub))
                .from(member)
                .fetch();


        for (Tuple tuple : result2) {
  //            System.out.println(&quot;tuple = &quot; + tuple.get(member.username));
  //            System.out.println(&quot;tuple = &quot; + tuple.get(select(memberSub.age.avg())
  //                                .from(memberSub)));
  //            System.out.println(&quot;tuple = &quot; + tuple);

        }
    }

    @Test
    public void concat() throws Exception{
        //given

        Tuple tuple1 = queryFactory
                .select(member.username,Expressions.constant(&quot;A&quot;))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;tuple1 = &quot; + tuple1);



        String result2 = queryFactory
                .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue()))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;result2 = &quot; + result2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 09 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/09/QueryDsl-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/09/QueryDsl-2/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>querydsl</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-study&quot;&gt;spring study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;querydsl-설정&quot;&gt;querydsl 설정&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [build.gradle ]
  plugins{ 
  //querydsl 추가
  id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot;
  }

  //querydsl 추가 시작
  def querydslDir = &quot;$buildDir/generated/querydsl&quot;
  querydsl {
      jpa = true
      querydslSourcesDir = querydslDir
  }
  sourceSets {
      main.java.srcDir querydslDir
  }
  configurations {
      querydsl.extendsFrom compileClasspath
  }
  compileQuerydsl {
      options.annotationProcessorPath = configurations.querydsl
  }
 //querydsl 추가 끝
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;querydsl-기본문법&quot;&gt;querydsl 기본문법&lt;/h2&gt;

&lt;p&gt;querydsl 사용에 있어서 JPAQueryFactory를 DI해야한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Q파일을 가져다가 사용할수있다. Q파일의 alias를 선언하여 JPQL의 alias를 대신할수있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Test
    public void search() throws Exception {
        //given

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;)
                        .and(member.age.eq(10)))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     *
     * member.username.eq(&quot;member1&quot;) // username = 'member1'
     * member.username.ne(&quot;member1&quot;) // username != 'member1'
     * member.username.eq(&quot;member1&quot;).not() // username != 'member1'
     *
     * member.username.isNotNull() // 이름이 is not null
     *
     * member.age.in(10,20) // age in (10,20)
     * member.age.notIn(10,20) // age not in(10,20)
     * member.age.between(10,30) // between 10,30
     *
     * member.age.goe(30) //age &amp;gt;= 30
     * member.age.gt(30) // age &amp;gt; 30
     * member.age.loe(30) // age &amp;lt;= 30
     * member.age.lt(30) // agr &amp;lt; 30
     *
     * member.username.like(&quot;member%&quot;) // like
     * member.username.contains(&quot;member&quot;) // like '%member%'
     * member.username.startWith(&quot;member&quot;) // like 'member%'
     *
     */
    @Test
    public void searchAndParam(){
        List&amp;lt;Member&amp;gt; findMembers = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;),
                        member.age.eq(10))
                .fetch();

        Member findMember = findMembers.get(0);

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     * fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환
     * fetchOne() : 단건 조회
     *  - 결과가 없으면 null
     *  - 결과가 둘이상이면 com.querydsl.core.NonUniqueResultException
     * fetchFirst() : limit(1).fetchOne()
     * fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
     * fetchCount() : count 쿼리로 변경해서 count수 조회
    *
     * @throws Exception
     */
    @Test
    public void fetchResult() throws Exception{

  //        List&amp;lt;Member&amp;gt; fetch = queryFactory
  //                .select(member)
  //                .from(member)
  //                .fetch();
  //
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchOne();
  //        
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchFirst();

  //        QueryResults&amp;lt;Member&amp;gt; result = queryFactory
  //                .select(member)
  //                .from(member)
  //                .offset(0)
  //                .limit(2)
  //                .fetchResults();
  //
  //
  //        assertThat(result.getLimit()).isEqualTo(2);
  //        assertThat(result.getOffset()).isEqualTo(0);
  //        assertThat(result.getTotal()).isEqualTo(4);
  //
  //
  //        for (Member resultResult : result.getResults()) {
  //            System.out.println(&quot;resultResult = &quot; + resultResult);
  //        }

  //        long count = queryFactory
  //                .selectFrom(member)
  //                .fetchCount();


  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;정렬및집합&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Test
    public void sort() throws Exception{
        //given
        em.persist(new Member(null,100));
        em.persist(new Member(&quot;member5&quot;,100));
        em.persist(new Member(&quot;member6&quot;,100));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(100))
                .orderBy(member.age.desc(),
                        member.username.asc().nullsLast())
                .fetch();

        //when

        //then

        Member member5 = result.get(0);
        Member member6 = result.get(1);
        Member memberNull = result.get(2);

        assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;);
        assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;);
        assertThat(memberNull.getUsername()).isNull();
    }


    /**
     * 집합 함수
     * select
     *   COUNT(m),
     *   SUM(m.age),
     *   AVG(m.age),
     *   MAX(m.age),
     *   MIN(m.age)
     * from Member m
     */
    @Test
    public void aggregation() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member.count(),
                        member.age.sum(),
                        member.age.avg(),
                        member.age.min(),
                        member.age.max())
                .from(member)
                .fetch();
        //when

        //then

        Tuple tuple = result.get(0);
        assertThat(tuple.get(member.count())).isEqualTo(4);
        assertThat(tuple.get(member.age.sum())).isEqualTo(100);
        assertThat(tuple.get(member.age.avg())).isEqualTo(25);
        assertThat(tuple.get(member.age.max())).isEqualTo(40);
        assertThat(tuple.get(member.age.min())).isEqualTo(10);
    }

    /**
     * GroupBy 사용
     * 팀의 이름과 각 팀의 평균 연령을 구해라
     *
     * @throws Exception
     */
    @Test
    public void GroupByTest() throws Exception{
        //given
        em.persist(new Team(&quot;teamC&quot;));
        em.persist(new Member(&quot;member5&quot;,50,null));


        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(team.name,member.age.avg())
                .from(member)
                .join(member.team,team)
  //                .LeftJoin(member.team,team)
                .groupBy(team.name)
                .fetch();
        //when
        //then

  //        Tuple teamA = result.get(0);
  //        Tuple teamB = result.get(1);
  //
  //        assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;);
  //        assertThat(teamA.get(member.age.avg())).isEqualTo(15);
  //
  //        assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;);
  //        assertThat(teamB.get(member.age.avg())).isEqualTo(35);

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   /**
     *
     * join() : innerJoin()
     * leftJoin() : left 외부조인
     * rightJoin() : right 외부조인
     * @throws Exception
     */
    @Test
    public void join() throws Exception{
        //given
        QMember qMember = member;
        QTeam qTeam = QTeam.team;

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when

        //then
        assertThat(result)
                .extracting(&quot;username&quot;) // 결과에서 추출
                .containsExactly(&quot;member1&quot;,&quot;member2&quot;); // 포함하고 있는지확인

        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     *
     * from절에 여러 엔티티를 선택해서 세타조인 할수있다.
     * 하지만 세타조인시 외부조인 불가능하다
     *
     * @throws Exception
     */
    @Test
    public void theta_join() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member,team)
                .where(member.username.eq(team.name))
                .fetch();

        //when
        //then
        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     * 외부조인하는 방법
     * on절을 활용해 조인 대상을 필터링 할때, 외부조인이 아니라 내부조인을 사용하면,
     * where절에서 필터링 하는것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링
     * 을 사용할때, 내부조인이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만
     * 이 기능을 사용하자.
     *
     * @throws Exception
     */
    @Test
    public void join_on_fittering() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
 //                .leftJoin(member.team,team).on(team.name.eq(&quot;teamA&quot;))
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when
        //then

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * 연관관계없는 엔티티 외부조인
     * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
     * JPQL: select m,t from member m left join team t on m.username = t.name
     * SQL : select m.*,t.* from Member m left join  Team t on m.username = t.name
     *
     * 서로 연관관계가 없으니 leftJoin()에서 하나의 엔티티만 들어간다.
     */

    @Test
    public void join_on_no_relation() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
                .leftJoin(team).on(member.username.eq(team.name))
                .fetch();
        //when

        //then
        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * fetch join 적용
     *  join(member.team, team).fetchjoin()
     *  위와같은 방식으로 사용하면된다.
     *  join()에 엔티티를 잘 넣어줘야한다. 그래서 같은 영속성 컨텍스트에서 id를 가져옴
     *
     */

    @PersistenceUnit
    EntityManagerFactory emf;

    @Test
    public void fetch_NO_join_test() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();
        //when
        //then

        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).as(&quot;페치조인 미적용&quot;).isFalse();
    }

    @Test
    public void fetchJoin() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team).fetchJoin()
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        //when
        //then
        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).isTrue();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;서브쿼리,concat&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
     * 서브쿼리
     * com.querydsl.jpa.JPAExpressions 사용한다.
     *
     * 서브쿼리는 select, where절에만 사용가능하다.
     *
     *
     * 예제 1) 나이가 가장 많은 회원 조회
     * 예제 2) 나이가 평균 나이 이상인 회원
     * 예제 3) 서브쿼리 여러건 처리, in 사용
     * 예제 4) select절에 서브쿼리 사용
     *
     * JPAExpressions &amp;lt;&amp;lt; static import 가능
     *
     * from절에 서브쿼리 안된다. JPA에서는 이를 해결하는 방안은
     * 1. 서브쿼리를 join으로 변경한다.(가능한 상황도 있고,불가능한 상황도 있다.
     * 2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
     * 3. nativeSQL을 사용한다.
     *
     */
    @Test
    public void subQuery() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);

 //        예제1
        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(
                        select(memberSub.age.max())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result).extracting(&quot;age&quot;)
                .containsExactly(40);
    }

    @Test
    public void subQuery2() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.goe(
                        select(memberSub.age.avg())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(30,40);
    }

    @Test
    public void subQuery3() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.in(
                            select(memberSub.age)
                                .from(memberSub)
                                .where(memberSub.age.gt(10))
                ))
                .fetch();

        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(20,30,40);

        for (Member member1 : result2) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    @Test
    public void subQuery4() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Tuple&amp;gt; result2 = queryFactory
                .select(member.username,
                        select(memberSub.age.avg())
                                .from(memberSub))
                .from(member)
                .fetch();


        for (Tuple tuple : result2) {
  //            System.out.println(&quot;tuple = &quot; + tuple.get(member.username));
  //            System.out.println(&quot;tuple = &quot; + tuple.get(select(memberSub.age.avg())
  //                                .from(memberSub)));
  //            System.out.println(&quot;tuple = &quot; + tuple);

        }
    }

    @Test
    public void concat() throws Exception{
        //given

        Tuple tuple1 = queryFactory
                .select(member.username,Expressions.constant(&quot;A&quot;))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;tuple1 = &quot; + tuple1);



        String result2 = queryFactory
                .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue()))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;result2 = &quot; + result2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 08 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/08/QueryDsl-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/08/QueryDsl-1/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-5</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-jpa-study&quot;&gt;spring jpa study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;스프링-데이터-jpa-분석&quot;&gt;스프링 데이터 JPA 분석&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 데이터 JPA가 제공하는 인터페이스의 구현체&lt;/li&gt;
  &lt;li&gt;org.springframework.data.jpa.repository.support.SimpleJpaRepository&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Repository 적용 : JPA 예외를 스프링이 추상화한 예외로 변환
@Transactional 트랜잭션 적용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JPA의 모든 변경은 트랜잭션 안에서 동작&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA는 변경(등록,수정,삭제) 메서드를 트랜잭션 처리&lt;/li&gt;
  &lt;li&gt;서비스 계층에서 트랜잭션을 시작하지 않으면 리파지토리에서 트랜잭션 시작&lt;/li&gt;
  &lt;li&gt;그래서 스프링 데이터 JPA를 사용할 때 트랜잭션이 없어도 데이터 등록, 변경이 가능했음(사실은 트랜잭션이 리포지토리 계층에 걸려있는것임)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Transactional() 에 관한 자세한 내용은 JPA책 15.4.2 읽기 전용 쿼리 참조&lt;/p&gt;

&lt;h2 id=&quot;persistable-구현&quot;&gt;Persistable 구현&lt;/h2&gt;

&lt;p&gt;&lt;mark&gt;JPA 식별자 생성 전략이 @GenerateValue면 save() 호출 시점에 식별자가 없으므로 새로운 엔티티로 인식해서 정상 동작한다. 그런데 JPA식별자 생성 전략이 @Id만 사용해서 직접 할당이면 이미 식별작ㅂㅅ이 있는 상태로 save()를 호출한다. 따라서 이 경우 merge()가 호출된다.   
  merge()는 우선 DB를 호출해서 값을 확인하고, DB에 값이 없으면 새로운 엔티티로 인지하므로 매우 비효율 적이다. 따라서 Persistable를 사용해서 새로운 엔티티 확인 여부를 직접 구현하는게 효과적이다.   
  참고로 등록시간(@CreateDate)을 조합해서 사용하면 이 필드로 새로운 엔티티여부를 편리하게 확인할 수 있다.&lt;/mark&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  package study.datajpa.entity;
    import lombok.AccessLevel;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.CreatedDate;
    import org.springframework.data.domain.Persistable;
    import org.springframework.data.jpa.domain.support.AuditingEntityListener;
    import javax.persistence.Entity;
    import javax.persistence.EntityListeners;
    import javax.persistence.Id;
    import java.time.LocalDateTime;
             
   @Entity
  @EntityListeners(AuditingEntityListener.class)
  @NoArgsConstructor(access = AccessLevel.PROTECTED)
  public class Item implements Persistable&amp;lt;String&amp;gt; {
      @Id
      private String id;
      @CreatedDate
      private LocalDateTime createdDate;
      public Item(String id) {
          this.id = id;
  }
      @Override
      public String getId() {
  return id; }
      @Override
      public boolean isNew() {
          return createdDate == null;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;나머지-기능&quot;&gt;나머지 기능&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Specifications(명세)&lt;/li&gt;
  &lt;li&gt;Query by Example&lt;/li&gt;
  &lt;li&gt;Projections&lt;/li&gt;
  &lt;li&gt;네이트브 쿼리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 4가지 나머지 기능은 Querydsl을 사용하면 더 호율적이다.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-5/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-4</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-jpa-study&quot;&gt;spring jpa study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;사용자-정의-리포지토리-구현&quot;&gt;사용자 정의 리포지토리 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 데이터 JPA 리포지토리는 인터페잇만 정의하고 구현체는 스프링이 자동생성&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA가 제공하는 인터페이스를 직접 구현하면 구현해야 하는 기능이 너무 많음&lt;/li&gt;
  &lt;li&gt;다양한 이유로 인터페이스의 메소드를 직접 구현하고 싶다면?
    &lt;ul&gt;
      &lt;li&gt;JPA직접사용(EntityManager)&lt;/li&gt;
      &lt;li&gt;spring JDBC Template 사용&lt;/li&gt;
      &lt;li&gt;MyBatis 사용&lt;/li&gt;
      &lt;li&gt;DB Connection 사용&lt;/li&gt;
      &lt;li&gt;Querydsl 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [사용자 정의 인터페이스]
 public interface MemberRepositoryCustom{
   List&amp;lt;Member&amp;gt; findMemberCustom();
 }

 --------------------------------------------
 [사용자 정의 인터페이스 구현 클래스]
 @RequiredArgsConstructor
 public class MemberRepositoryImpl implements MemberReposityCustom{
   private final EntityManager em;

   @Override
   public List&amp;lt;Member&amp;gt; findMemberCustom(){
     returm em.createQuery(&quot;select m from Member m&quot;)
          .getResultList();
   }
 }

 --------------------------------------------
 [사용자 정의 인터페이스 상속]
 public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; MemberRepositoryCustom{

 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;사용자 정의 구현 클래스&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;규칙 : 리포지토리 인터페이스 이름 + Impl&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA가 인식해서 스프링 빈으로 등록&lt;/li&gt;
&lt;/ul&gt;

&lt;makr&gt;주의 ! 항상 사용자 정의 리포지토리가 필요한것은 아니다. 임의의 리포지토리를 만들어도 된다. MemberQueryRepository를 클래스로 생성하고 스프링빈으로 등록하여 직접 사용해도 된다. &amp;lt;/mark&amp;gt;


스프링 데이터 2.x부터는 사용자 정의 구현 클래스에 리포지토리 인터페이스 이름 + Impl을 적용하는 대신에 사용자 정의 인터페이스 명 + Impl 방식도 지원한다. 

```
@RequiredArgsConstructor
public class MemberRepositoryCustomImpl implememts MemberRepositoryCustom{
  private final EntityManager em;

  @Override
  public List&lt;Member&gt; findMemberCustom(){
    return em.createQuery(&quot;select m from Member m&quot;).getResultList();
  }
}
```


## Auditing


엔티티 생성, 변경 할때 변경한 사람과 시간을 추적 하고 싶으면?
  - 등록일
  - 수정일 
  - 등록자
  - 수정자

순수 JPA 사용

```
  [BaseEntity 생성]
  @MappedSuperclass
  @Getter
  public class JpaBaseEntity{
    
    @Column(updatable = false)
    private LocalDateTime createdDate;
    private LocalDateTime updatedDate;

    @PrePersist
    public void prePersist(){
      LocalDateTime now = LocalDateTime.now();
      createdDate = now;
      updatedDate = now;
    }

    @PreUpdate
    public void preUpdate(){
      updatedDate = LocalDateTime.now();
    }
  }
  ---------------------------------------------

  [entity들 baseEntity 상속받음]

  public Member extends JpaBaseEntity{}

  --------------------------------------------

  [test code]
  public void JpaEventBaseEntity() throws Exception {
  //given
      Member member = new Member(&quot;member1&quot;);
      memberRepository.save(member); //@PrePersist
      Thread.sleep(100);
      member.setUsername(&quot;member2&quot;);
      em.flush(); //@PreUpdate
      em.clear();
  //when
      Member findMember = memberRepository.findById(member.getId()).get();
  //then
      System.out.println(&quot;findMember.createdDate = &quot; +
  findMember.getCreatedDate());
      System.out.println(&quot;findMember.updatedDate = &quot; +
  findMember.getUpdatedDate());
  }
```

#### 스프링 데이터 JPA 사용 

스프링 데이터 JPA 사용에 있어서 설정이 필요하다. 

@EnableJpaAuditing &amp;gt;&amp;gt; 스프링 부트 설정 클래스에 적용해야함
@EntityListeners(AuditingEntityListener.class) &amp;gt;&amp;gt; 엔티티에 적용

```
  [스프링 데이터 Auditing적용 - 등록일, 수정일]
  @EntityListeners(AuditingEntityListener.class)
  @MappedSuperclass
  @Getter
  public class BaseTimeEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
  }

  --------------------------------------------

  [스프링 데이터 Auditing적용 - 등록자, 수정자]
  public clas BaseEntity extends BaseTimeEntity {
  
    @CreateBy
    @Column(updatable = false)
    private String createBy;

    @LastModifiedBy
    private String lastModifiedBy;

  --------------------------------------------

  [등록자 수정자를 처리해주는 AuditorAware 스프링 빈 등록]
  @Bean
  public AuditorAware&lt;String&gt; auditorProvider(){
    return () -&amp;gt; Optional.of(UUID.randomUUID().toString());
  }

```

&lt;mark&gt;실무에서는 세션정보나 스프링 시큐리티 로그인 정보에서 ID를 받음&lt;/mark&gt;

@EntityListeners(AuditingEntityListener.class)를 생략하고 글로벌 설정하고 싶다면 orm.xml을 만들어 설정해야한다. 

## Web 확장 - 도메인 클래스 컨버터

```
  [도메인 클래스 컨버터 사용전]
  @RestController
  @RequiredArgsConstructor
  public class MemberController {
      private final MemberRepository memberRepository;
      @GetMapping(&quot;/members/{id}&quot;)
      public String findMember(@PathVariable(&quot;id&quot;) Long id) {
          Member member = memberRepository.findById(id).get();
          return member.getUsername();
      }
  }
  --------------------------------------------
  [도메인 클래스 컨버터 사용후]
  @RestController
  @RequiredArgsConstructor
  public class MemberController {
      private final MemberRepository memberRepository;
      @GetMapping(&quot;/members/{id}&quot;)
      public String findMember(@PathVariable(&quot;id&quot;) Member member) {
          return member.getUsername();
      }
  }

```

주의 : 도메인 클래스 컨버터로 엔티티를 파라미터로 받으면, 이 엔티티는 단순 조회용으로만 사용해야한다.

## web 확장  - 페이징과 정렬

스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC에서 편리하게 사용할 수 있다. 

```
  @GetMapping(&quot;/members&quot;)
    public Page&lt;Member&gt; list(Pageable pageable) {
        Page&lt;Member&gt; page = memberRepository.findAll(pageable);
        return page;
    }
```

파라미터로 Pageable을 받을수 있다. 

Pageable은 인터페이스, 실제는 org.springframework.data.domain.PageRequest 객체 생성

**요청 파라미터**
  - 예) /members?page=0&amp;amp;size=3&amp;amp;sort=id,desc&amp;amp;sort=username,desc
  - page: 현재 페이지, 0부터 시작한다.
  - size : 한 페이지에 노출할 데이터 건수
  - sort: 정렬 조건을 정의한다. 예) 정렬 속성,정렬 속성...(ASC | DESC), 정렬 방향을 변경하고 싶으면 sort 파라미터 추가 ( asc 생략 가능)

**기본 값**
  - spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/ 
  - spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈/

**개별 설정**

```
  @RequestMapping(value = &quot;/members_page&quot;, method = RequestMethod.GET)
    public String list(@PageableDefault(size = 12, sort = “username”,
      ... 
    }
```

**접두사**
  - 페이징 정보가 둘 이상이면 접두사로 구분
  - @Qualifier에 접두사명 추가 &quot;{접두사명}_xxx&quot;
  - 예제 : /members?member_page=0&amp;amp;order_page=1
```
  public String list(
      @Qualifier(&quot;member&quot;) Pageable memberPageable,
      @Qualifier(&quot;order&quot;) Pageable orderPageable, ...
  
```

**Page 내용을 DTO로 변환**
  - 엔티티를 API로 노출하면 다양한 문제가 발생한다. 그래서 엔티티를 꼭 DTO로 변환해서 반환해야한다.
  
```
  [MemberDto]
  @Data
  public class MemberDto {
      private Long id;
      private String username;
      public MemberDto(Member m) {
          this.id = m.getId();
     
           this.username = m.getUsername();
      }
}
  ------------------------------------------------------------
  [Page.map() 사용 ]
  @GetMapping(&quot;/members&quot;)
  public Page&lt;MemberDto&gt; list(Pageable pageable) {
      Page&lt;Member&gt; page = memberRepository.findAll(pageable);
      Page&lt;MemberDto&gt; pageDto = page.map(MemberDto::new);
      return pageDto; 
  }
```

&lt;mark&gt;스프링 데이터는 Page를 0부터 시작한다. 1부터 사용하여면? Pageable,Page를 파라미터와 응답값으로 사용하지 않고 직접 클래스를 만들어서 처리한다. 다른 하나의 방법도 있지만 단점이 존재하므로 사용치 않는다. (인덱스 0부터 사용햐쟈 그냥..)&lt;/mark&gt;
&lt;/MemberDto&gt;&lt;/Member&gt;&lt;/MemberDto&gt;&lt;/Member&gt;&lt;/Member&gt;&lt;/String&gt;&lt;/Member&gt;&lt;/makr&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-4/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쿼리메소드-기능&quot;&gt;쿼리메소드 기능&lt;/h2&gt;

&lt;p&gt;특정한 메소드를 작성하려면 어떻게 작성해야할까? &lt;br /&gt;JpaRepository는 인터페이스인데 새로운 메소드를 작성하려면 구현체 class를 만들면 되는것일까??&lt;br /&gt;새로운 구현체 클래스를 만들게 되면 기존에 find, findAll 등의 메소드 또한 다시 재정의해야한다. &lt;br /&gt;이는 매우 힘든일이다. (왜? 기존 메소드는 스프링이 만들어주니까!!)&lt;/p&gt;

&lt;p&gt;그렇기 때문에 우리는 쿼리메소드 기능을 이용하여서 새로운 특정 메소드를 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;순수 JPA로 만든 findByUsernameAndAgeGreaterThen()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    public List&amp;lt;Member&amp;gt; findByUsernameAndAgeGreaterThan(String username,int age) {
        return em.createQuery(&quot;select m from Member m where m.username = :username and m.age &amp;gt; :age&quot;)
                .setParameter(&quot;username&quot;,username)
                .setParameter(&quot;age&quot;,age)
                .getResultList();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;test를 돌려보면&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
  public void findByUsernameAndAgeGreaterThan() {
      Member m1 = new Member(&quot;AAA&quot;, 10);
      Member m2 = new Member(&quot;AAA&quot;, 20);
      memberJpaRepository.save(m1);
      memberJpaRepository.save(m2);
      List&amp;lt;Member&amp;gt; result =
  memberJpaRepository.findByUsernameAndAgeGreaterThan(&quot;AAA&quot;, 15);
      assertThat(result.get(0).getUsername()).isEqualTo(&quot;AAA&quot;);
      assertThat(result.get(0).getAge()).isEqualTo(20);
      assertThat(result.size()).isEqualTo(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/14a04d89bbc94c46bf2261d1bdebd519/e98effeb-6d68-4556-95db-530cbb49f499.png&quot; alt=&quot;&quot; title=&quot;SpringDataJpa - 3 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 sql이 나가는것을 알수있다. &lt;/p&gt;

&lt;p&gt;MemberRepository interface에서도 이와 같은 동일한 기능을 제공한다.&lt;br /&gt;메소드 이름을 통해서 쿼리를 작성하는 기능을 제공하는데 코드상으로는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
   List&amp;lt;Member&amp;gt; findByUsernameAndAgeGreaterThan(String username,int age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jpql로 작성한 메소드와 동일한 결과를 도출한다. &lt;/p&gt;

&lt;p&gt;메소드 이름을 통한 쿼리작성은 다음과 같은 규칙이 존재한다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조회: find…By, read…By , query…By, get…By&lt;/li&gt;
  &lt;li&gt;COUNT : count….By return ‘long’&lt;/li&gt;
  &lt;li&gt;EXISTS : exists…By return ‘boolean’&lt;/li&gt;
  &lt;li&gt;delete : delete…By return ‘long’&lt;/li&gt;
  &lt;li&gt;DISTINCT : findDistinct, findMemberDistinctBy&lt;/li&gt;
  &lt;li&gt;LIMIT : findFirst3, findFirst, findTop, findTop3&lt;br /&gt;- https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.limit-query-result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스프링 데이터 JPA 공식 사이트에서 자세히 참고 하기 바란다.&lt;br /&gt;(https://docs.spring.io/spring-data/jpa/docs/current/&lt;/p&gt;

&lt;p&gt;reference/html/#jpa.query-methods.query-creation)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;@ 메소드 이름을 통한 쿼리작성은 엔티티의 필드명과 인터페이스 메소드 명이 같아야하는점을 주의하자.&lt;/p&gt;

&lt;h2 id=&quot;jpa-namedquery&quot;&gt;JPA NamedQuery&lt;/h2&gt;

&lt;p&gt; - 실무에서 쓸일이없다. - &lt;/p&gt;

&lt;p&gt;애노테이션으로 쿼리를 등록해놓고 나중에 다시 불러다 쓸수있는 기능이다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@NameQuery(name=&quot;Member.findByUsername&quot;,
          query=&quot;select m from Member m where m.username = :username&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;장점 : 네임드 쿼리는 애플리케이션 로딩시점에 파싱하여 에러를 검증할수있음&lt;/p&gt;

&lt;h2 id=&quot;레포지터리-쿼리직접-쿼리를-정의함&quot;&gt;레포지터리 쿼리(직접 쿼리를 정의함)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
  ...

  @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)
  List&amp;lt;Member&amp;gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;장점 : 애플리케이션 로딩시점에 쿼리를 파싱하여 에러 검증할수있음(이름이 없는 네임드 쿼리라고 볼수있음)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실무에서 자주 쓰인다. -&lt;br /&gt;&lt;mark class=&quot;cdx-marker&quot;&gt;간단한 쿼리는 네임드 쿼리를 사용하고 복잡한 쿼리는 레포지터리 쿼리를 사용한다.&lt;br /&gt;동적 쿼리는 QueryDSL을 사용해라&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;query-값-dto-조회&quot;&gt;@Query, 값, Dto 조회&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
  ...

  @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)
  List&amp;lt;Member&amp;gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age);

  // 간단조회 
  @Query(&quot;select m.username from Member m&quot;)
  List&amp;lt;Member&amp;gt; findUsernameList();

  // dto 조회 (dto가 존재해야한다.)
  @Query(&quot;select new (멤버dto의 경로 입력 해야함)MemberDto(m.id, m.username, t.name) from Member m join m.team.t&quot;)
  List&amp;lt;MemberDto&amp;gt; findMemberDto();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;파라미터-바인딩&quot;&gt;파라미터 바인딩&lt;/h2&gt;

&lt;p&gt;위치기반과 이름기반이 존재하는데 이름기반을 무조건 써야합니다.!!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; {

  // 단건 조건
  @Query(&quot;select m from Member m where m.username = :name&quot;)
  Member findMembers(@Param(&quot;name&quot;) String username);
  
  //컬렉션 파라미터 바인딩
  @Query(&quot;selecet m from Member m where m.username in :names&quot;)
  List&amp;lt;Member&amp;gt; findByNames(@Param(&quot;names&quot;) List&amp;lt;String names);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;반환-타입&quot;&gt;반환 타입&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;List&lt;Member&gt; findByUsername(String name); // 컬렉션&lt;/Member&gt;&lt;/li&gt;
  &lt;li&gt;Member findByUsername(String name); // 단건&lt;/li&gt;
  &lt;li&gt;Optional&lt;Member&gt; findByUsername(String name); // 단건 Optional&lt;/Member&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;조회 결과가 많거나 없으면 ?&lt;/p&gt;

&lt;p&gt;결과 없음 :  빈 컬렉션 반환&lt;/p&gt;

&lt;p&gt;단건조회&lt;/p&gt;

&lt;p&gt;결과없음 : NULL반환&lt;/p&gt;

&lt;p&gt;결과가 2건 이상 : javax.persistence.NonUniqueResultException 예외 발생&lt;/p&gt;

&lt;h2 id=&quot;순수-jpa-페이징과-정렬&quot;&gt;순수 JPA 페이징과 정렬&lt;/h2&gt;

&lt;p&gt;JPA에서 페이징을 어떻게 할 것인가?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;검색조건 : 나이가 10살&lt;/li&gt;
  &lt;li&gt;정렬조건 : 이름으로 내림차순&lt;/li&gt;
  &lt;li&gt;페이징 조건 : 첫번째 페이지, 페이지당 보여줄 데이터는 3건&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public List&amp;lt;Member&amp;gt; findByPage(int age, int offset, int limit){
    return em.createQuery(&quot;select m from Member m where m.age = :age order by m.username desc&quot;)
        .setParameter(&quot;age&quot;, age)
        .setFirstResult(offet)
        .setMaxResult(limit)
        .getResultList();
  }

  public long totalCount(int age){
    returm em.createQurey(&quot;select count(m) from Member m where m.age = :age&quot;, Long.class)
        .setParameter(&quot;age&quot;, age)
        .getSingleResult();
  }


  --------------------------------------------------------
  &amp;lt;TestCode&amp;gt;

  @Test
    public void paging() throws Exception {
    //given
      memberJpaRepository.save(new Member(&quot;member1&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member2&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member3&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member4&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member5&quot;, 10));
      int age = 10;
      int offset = 0;
      int limit = 3;
    //when
      List&amp;lt;Member&amp;gt; members = memberJpaRepository.findByPage(age, offset, limit);
      long totalCount = memberJpaRepository.totalCount(age);
    //페이지 계산 공식 적용...
    // totalPage = totalCount / size ...
    // 마지막 페이지 ... // 최초 페이지 ..
    //then
      assertThat(members.size()).isEqualTo(3);
      assertThat(totalCount).isEqualTo(5);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;순수 JPA로 페이징을 진행하려면 sql(JPQL)로 쿼리를 불러오고 이때 정렬과 검색 조건을 등록한다. 일반적인 쿼리를 생각한다.&lt;/p&gt;

&lt;p&gt;하지만 페이징에서는 sql의 방언을 지원하기 떄문에(JPA) offset,limit 를 통해서 정해진 규칙을 지켜야한다.&lt;/p&gt;

&lt;p&gt;그것은 setFirstResult(),setMamResult()이다.&lt;/p&gt;

&lt;p&gt;테스트코드를 봐보면 페이징만 끊어오고 페이징의 계산은 직접 구현해야함을 볼수있다.&lt;/p&gt;

&lt;h2 id=&quot;스프링-데이터-jpa-페이징과-정렬&quot;&gt;스프링 데이터 JPA 페이징과 정렬&lt;/h2&gt;

&lt;p&gt;결론적으로 말하자면 위의 순수JPA 페이징과 정렬의 구현에서 스프링이 많은걸 도움을 준다. 그래서 개발자는 실질적인 코드생성을 절약 할수있고 빠른 구현이 가능하다. 하지만 spring data가 만능은 아니니 순수JPA 또한 잘 숙지해야한다.&lt;/p&gt;

&lt;p&gt;페이징과 정렬 파라미터&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.springframework.data.domain.Sort : 정렬 기능&lt;/li&gt;
  &lt;li&gt;org.springframework.data.domain.Pageable : 페이징 기능(내부에 sort 포함)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특별한 반환 타입&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.springframework.data.domain.Page : 추가 count 쿼리 결과를 포함하는 페이징&lt;/li&gt;
  &lt;li&gt;org.springframework.data.domain.Slice : 추가 count 쿼리 없이 다음 페이지만 확인 가능(내부적으로 limit+1 조회)&lt;/li&gt;
  &lt;li&gt;List(자바컬렉션):추가 count 쿼리 없이 결과만 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;페이징과 정렬 사용 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Page&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용
 Slice&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용한함
 List&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용안함
 List&amp;lt;Member&amp;gt; findByUsername(String name, Sort sort);

 --------------------------------
 [실행코드]

  public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
    Page&amp;lt;Member&amp;gt; findByAge(int age, Pageble pageable);
  }


  ----------------------------------
  [Test code]

  //페이징 조건과 정렬 조건 설정
  @Test
  public void page() throws Exception {
  //given
    memberRepository.save(new Member(&quot;member1&quot;, 10));
    memberRepository.save(new Member(&quot;member2&quot;, 10));
    memberRepository.save(new Member(&quot;member3&quot;, 10));
    memberRepository.save(new Member(&quot;member4&quot;, 10));
    memberRepository.save(new Member(&quot;member5&quot;, 10));
  //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
  &quot;username&quot;));
    Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(10, pageRequest);
  //then
    List&amp;lt;Member&amp;gt; content = page.getContent(); //조회된 데이터 
    assertThat(content.size()).isEqualTo(3); //조회된 데이터 수 
    assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수 
    assertThat(page.getNumber()).isEqualTo(0); //페이지 번호 
    assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호 
    assertThat(page.isFirst()).isTrue(); //첫번째 항목인가? 
    assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;두번째 파라미터로 받은 Pageable은 인터페이스다. 따라서 실제 사용할 때는 해당 인터페이스를 구현한 PageRequest 객체를 사용한다.&lt;/p&gt;

&lt;p&gt;PageRequest 생성자의 첫번째 파라미터에는 현재페이지, 두번째 파라미터는 조회할 데이터 수 , 추가적으로 정렬 정보또한 세번째 파라미터로 작성가능하다, 생략 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;mark&gt;페이저블 객체를 사용시에 주의할점이 존재한다.&lt;br /&gt; 예를들면 페치조인하여 데이터를 가져왔을때 계속 추가적인 페치조인의 count값을 들고 온다. 이때 count는 페치조인의 지속적이 여부는 필요없고 count를 할수있는 엔티티의 count만 한다면 최적화가 가능하다.&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;이럴때 페이저블 객체 사용하며 쿼리를 분리해낼수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Query(value = &quot;select m from Member m&quot;. 
        countQuery = &quot;select count(m.username) from Member m&quot;)
  Page&amp;lt;Member&amp;gt; findMemberAllCountBy(Pageable pageable);

  ------------------------------
  [페이지를 유지하면서 엔티티를 DTO로 변환하기] // 엔티티를 어디든 제공하면 안되므로 ... DTO 변환 이유 하시겠죠?

  Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(10,pageRequest);
  page&amp;lt;Member&amp;gt; dtopage = page.map(m -&amp;gt; new MemberDto());

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;벌크성-수정-쿼리&quot;&gt;벌크성 수정 쿼리&lt;/h2&gt;

&lt;p&gt;JPA는 변경감지(dirty check)를 이용해서 update를 날릴수있다. 하지만 모든 어트리뷰트에 값을 변경하려면 쿼리를 날려야하고 이때 벌크성 수정 쿼리를 사용한다.&lt;/p&gt;

&lt;p&gt;순수 JPA를 이용한 벌크성 수정쿼리&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public int bulkAgePlus(int age){
    int resultCount = em.createQuery(&quot;update Member m set m.age = m.age + 1 where m.age &amp;gt;= :age&quot;)
      .setParameter(&quot;age&quot;, age)
      .exexcuteUpate();

    return resultCount;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;스프링 데이터 JPA&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Modifying
  @Query(&quot;update Member m set m.age = m.age +1 where m.age &amp;gt;= :age&quot;)
  int bulkAgePlus(@Param(&quot;age&quot;) int age);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;벌크성 수정, 삭베 쿼리는 @Modifying 어노테이션을 사용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용치 않으면 다음 예외 발생&lt;/li&gt;
  &lt;li&gt;org.hibernate.hql.internal.QueryExeutionRequestException: Not Supported for DML operations&lt;/li&gt;
  &lt;li&gt;벌크성 쿼리를 실행하고 나서 영속성 컨텍스트 초기화: @Modifying(clearAutoMatically = true)
    &lt;ul&gt;
      &lt;li&gt;이 옵션 없이 회원을 findById로 다시 조회하면 영속성 컨텍스트에 과거 값이 남아서 문제가 될수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;벌크성 쿼리의 영속성 컨텍스트 문제!! 뭔지 기억하지&lt;/p&gt;

&lt;h2 id=&quot;엔티티-그래프&quot;&gt;엔티티 그래프&lt;/h2&gt;

&lt;p&gt;연관된 엔티티들을 SQL 한번에 조회하는 방법 »  페치조인&lt;/p&gt;

&lt;h4 id=&quot;n--1-문제가-무엇이냐&quot;&gt;n + 1 문제가 무엇이냐??&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;지연로딩 사용시 연관된 엔티티를 조회하면 연관된 엔티티 조회 할때마다 조회 쿼리가 생성되어 발생된다.&lt;/li&gt;
  &lt;li&gt;A 엔티티에 연관된 B 엔티티가 100개라면 A 조회시 1번 B 조회시 100번의 쿼리가 발생하고 이를 n+1 문제이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;n--1-문제를-해결하는-방법이-무엇이냐&quot;&gt;n + 1 문제를 해결하는 방법이 무엇이냐??&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;n+1를 해결하기 위해서는 연관된 엔티티 A,B를 한번에 조회해오면 주기적인 쿼리를 날릴일 일이 없어지고 n 번의 문제가 해결된다.&lt;/li&gt;
  &lt;li&gt;JPA에서는 fetch join이라는 기능으로 이를 해결할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;페치조인은 다음과 같이 사용된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [순수 JPA]
  @Query(&quot;select m from Member m left join fetch m.team&quot;)
  List&amp;lt;Member&amp;gt; findMemberFetchJoin();

  [스프링 데이터 JPA]
  // 공통 메서드 오버라이드
  @Override
  @EntityGraph(attributePaths = {&quot;team&quot;})
  List&amp;lt;Member&amp;gt; findAll();

  //JPQL + 엔티티 그래프
  @EntityGraph(attributePaths = {&quot;team&quot;})
  @Query(&quot;select m from Member m&quot;)
  List&amp;lt;Member&amp;gt; findMemberEntityGraph();

  //메서드 이름으로 쿼리에서 특히 편리하다.
  @EntityGraph(attributePaths = {&quot;team&quot;})
  List&amp;lt;Member&amp;gt; findByUsername(@Param(&quot;username&quot;) String username)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-3/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;b&gt;공통 인터페이스 및 설정&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;MemberReposity는 interface이고 사용자는 반복적인 CRUD 사용에 있어 구현체를 구현하면된다. &lt;br /&gt;하지만 구현체도한 스프링이 도와준다 &lt;br /&gt;어떻게 구현체를 만드는것일까?&lt;/p&gt;

&lt;p&gt;MemberReposity extends JpaRepository&amp;lt;Member, Long&amp;gt;을 사용할때&lt;br /&gt;인터페이스내부의 메소드를 사용할때 스프링이 프록시객체를 생성한다. 그리고 이에 맞춰서 스프링이 구현체를 작성하여 인터페이스 메소드에 주입하는 형식으로 구성되었다. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/8e82bcf2dd77404d8de2a90c6ff8de5a/ad3c6a1e-437d-415b-86c2-be32a4de4dc6.png&quot; alt=&quot;&quot; title=&quot;SpringDataJPA - 2 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;공통 인터페이스 분석&lt;/b&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JpaRepository &amp;gt;&amp;gt; PagingAndSortingRepository &amp;gt;&amp;gt; CrudRepository &amp;gt;&amp;gt; Repository 를상속받는다.&lt;/li&gt;
  &lt;li&gt;해당하는 각 인터페이스 마다 다양한 메소드를 지원한다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  공통 인터페이스 구성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/8e82bcf2dd77404d8de2a90c6ff8de5a/f809cfb6-4f6d-4c07-a785-bdd078af5e50.png&quot; alt=&quot;&quot; title=&quot;SpringDataJPA - 2 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 DB별 공통지원기능이 존재하므로 Common 기능을 제공하는 인터페이스가 따로 존재한다. &lt;/p&gt;

&lt;p&gt;주요 메서드&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.&lt;/li&gt;
  &lt;li&gt;delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntitiManager.remove() 호출&lt;/li&gt;
  &lt;li&gt;findById(ID):엔티티 하나를 조회한다. 내부에서 EntityManager.find() 호출&lt;/li&gt;
  &lt;li&gt;getOne(ID):엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference()호출&lt;/li&gt;
  &lt;li&gt;findAll() : 모든엔티티를 조회한다. 정렬, 페이징 조건을 파라미터로 제공가능&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/05/dataJpa-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/05/dataJpa-2/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예제 도메인 모델과 동작확인&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/167f86083f244d2a85545359afd5492f/a60bb7d1-3df1-4501-8d01-b5cd7dbbb03f.png&quot; alt=&quot;&quot; title=&quot; SpringDataJpa - 1 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인은 멤버와 팀이 존재한다. &lt;/p&gt;

&lt;p&gt;멤버와 팀은 일대다 관계이다.&lt;/p&gt;

&lt;p&gt;JPA를 통해서 연관관계를 설정하고 JPA매핑을 진행한다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ERD에서 테이블은 JPA의 객체와 매핑되어야한다&lt;/li&gt;
  &lt;li&gt;JPA 매핑을 위해서 연관관계 설정, 연관관계메소드, 컬럼변수, FK설정 등을 진행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Member와 Team간의 연관관계 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ManyToOne, @OneToMany를 통한 양방향관계설정&lt;/li&gt;
  &lt;li&gt;chageTeam()를 통해서 연관관계 편의 메소드 생성&lt;/li&gt;
  &lt;li&gt;fetch = FetchType.LAZY를 통해 지연로딩 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;mark class=&quot;cdx-marker&quot;&gt;지연로딩, 연관관계 편의메소드, 관계설정등의 개념은 JPA기본편 참조&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;Member Entity &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {&quot;id&quot;, &quot;username&quot;, &quot;age&quot;})
public class Member {

    @Id @GeneratedValue
    @Column(name = &quot;member_id&quot;)
    private Long id;
    private String usernaem;
    private int age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;team_id&quot;)
    private Team team;


    public Member(String username) {
        this.usernaem = username;
        this.age = 0;
    }

    public Member(String username,int age) {
        this.usernaem = username;
        this.age = age;
    }

    public Member(String usernaem, int age,Team team) {
        this.usernaem = usernaem;
        this.age = age;
        if(team != null){
            changeTeam(team);
        }
    }

    public void changeTeam(Team team){
        this.team = team;
        team.getMembers().add(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Team Entity&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {&quot;id&quot;,&quot;name&quot;})
public class Team {

    @Id @GeneratedValue
    @Column(name = &quot;team_id&quot;)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;team&quot;)
    List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();

    public Team(String name){
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MemberJpaRepository 직접 만들어 CRUD를 생성하였다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Repository
public class MemberJpaRepository {

    @PersistenceContext
    private EntityManager em;

    public Member save(Member member){
        em.persist(member);
        return member;
    }

    public void delete(Member member){
        em.remove(member);
    }

    public List&amp;lt;Member&amp;gt; findAll(){
        return em.createQuery(&quot;select m from Member m&quot;,Member.class)
                .getResultList();
    }

    public Optional&amp;lt;Member&amp;gt; findById(Long id){
        Member member = em.find(Member.class,id);
        return Optional.ofNullable(member);
    }

    public long count(){
        return em.createQuery(&quot;select count(m) from Member m&quot;, Long.class)
                .getSingleResult();
    }

    public Member find(Long id){
        return em.find(Member.class,id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MemberJpaRepositoryTest&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@SpringBootTest
@Transactional
@Rollback(false)
class MemberJpaRepositoryTest {

    @Autowired
    MemberJpaRepository memberJpaRepository;

    @Test
    public void testMember() throws Exception{
        //given
        Member member = new Member(&quot;MemberA&quot;);
        Member savedMember = memberJpaRepository.save(member);
        Member findMember = memberJpaRepository.find(savedMember.getId());

        //when

        Assertions.assertThat(findMember.getId()).isEqualTo(member.getId());
        Assertions.assertThat(findMember.getUsernaem()).isEqualTo(member.getUsernaem());

        /**
         * 영속성 컨텍스트에서 1차 캐시에 의한 동일 객체임을 확인
         */
        Assertions.assertThat(findMember).isEqualTo(member);
        //then
    }

    @Test
    public void basicCRUD() {
        Member member1 = new Member(&quot;member1&quot;);
        Member member2 = new Member(&quot;member2&quot;);
        memberJpaRepository.save(member1);
        memberJpaRepository.save(member2);

        //단건 조회 검증
        Member findMember1 = memberJpaRepository.findById(member1.getId()).get();
        Member findMember2 = memberJpaRepository.findById(member2.getId()).get();
        Assertions.assertThat(findMember1).isEqualTo(member1);
        Assertions.assertThat(findMember2).isEqualTo(member2);

        //리스트 조회 검증
        List&amp;lt;Member&amp;gt; all = memberJpaRepository.findAll();
        Assertions.assertThat(all.size()).isEqualTo(2);

        //카운트 검증
        long count = memberJpaRepository.count();
        Assertions.assertThat(count).isEqualTo(2);

        //삭제 검증
        memberJpaRepository.delete(member1);
        memberJpaRepository.delete(member2);

        long deletedCount = memberJpaRepository.count();
        Assertions.assertThat(deletedCount).isEqualTo(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;간단한 CRUD를 검증하였다. &lt;/p&gt;

&lt;p&gt;springDataJpa study를 위한 간단한 예제를 만들어보았고 앞으로 MemberRepository interface가 어떻게 설정되어있는지 그리고 interface를 분석해보려한다.&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/05/dataJpa-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/05/dataJpa-1/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-9</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;객체지향-쿼리-언어&quot;&gt;객체지향 쿼리 언어&lt;/h2&gt;

&lt;h3 id=&quot;jpql&quot;&gt;JPQL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EntityManager.find() 가장 단순한 조회 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;jpa를 사용하면 엔티티 객체를 중심으로 개발&lt;/li&gt;
  &lt;li&gt;문제는 검색쿼리&lt;/li&gt;
  &lt;li&gt;검색을 할때도 테이블이 아닌 엔티티 객체를 대상으로 검색&lt;/li&gt;
  &lt;li&gt;모든 DB데이터를 객체로 변환해서 검색하는것은 불가능&lt;/li&gt;
  &lt;li&gt;애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요&lt;/li&gt;
  &lt;li&gt;객체를 대상으로 쿼리 =&amp;gt; JPQL&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  String jpql = &quot;selece m from Member m where m.name like '%hello%'&quot;;

  List&amp;lt;Member&amp;gt; result = emd. createQuery(jpql, Member.class).getResultList();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;QueryDSL은 사용하는것이 좋다. 하지만 criteriaJPA 사용하지마라&lt;/li&gt;
  &lt;li&gt;QueryDSL장점
    &lt;ul&gt;
      &lt;li&gt;문자가 아닌 자바코드로 JPQL을 작성할 수 있음&lt;/li&gt;
      &lt;li&gt;JPQL 빌더 역할&lt;/li&gt;
      &lt;li&gt;컴파일 시점에 문법 오류를 찾을 수 있음&lt;/li&gt;
      &lt;li&gt;동적 쿼리 작성 편리함&lt;/li&gt;
      &lt;li&gt;단순하고 쉬움&lt;/li&gt;
      &lt;li&gt;실무사용 권장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기본문법과-기능&quot;&gt;기본문법과 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는것이 아니라 엔티티 객체를 대상으로 쿼리한다.&lt;/li&gt;
  &lt;li&gt;JPQL은 SQL을 추상화해서 특정데이터ㅔ이스 SQL에 의존하지 않는다.(방언을 지원하므로 )&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JPQL은 결국 SQL로 변환된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DML 사용가능(select - where,groupby,having,orderby 등등)&lt;/li&gt;
  &lt;li&gt;TypeQuery : 반환타입이 명확할 때 사용
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  TypeQuery&amp;lt;Member&amp;gt; query =
      em.createQuery(&quot;select m from Member m&quot;,Member.class);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;Query : 반환 타입이 명확하지 않을 때 사용
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Query query = 
    em.createQuery(&quot;select m.usernaem, m.age from Member m&quot;);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결과 조회 API
    &lt;ul&gt;
      &lt;li&gt;query.getResultList(): 결과가 하나 이상일때, 리스트반환
        &lt;ul&gt;
          &lt;li&gt;결과가 없으면 빈 리스트 반환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;query.getSingleResult() : 결과가 정확히 하나, 단일 객체 반환
        &lt;ul&gt;
          &lt;li&gt;결과가없으면 : javax.persistence.NoResultException&lt;/li&gt;
          &lt;li&gt;둘이상이면 : javax.persistence.NonUniqueExcetion&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파라미터 바인딩 - 이름,위치 있는데 이름만 사용할것
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select m from Member m where m.username = :username
query.setParameter(&quot;username&quot;,usernameParam);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝션
    &lt;ul&gt;
      &lt;li&gt;엔티티 프로젝션&lt;/li&gt;
      &lt;li&gt;임베디드 타입 프로젝션&lt;/li&gt;
      &lt;li&gt;스탈라 타입 프로젝션&lt;/li&gt;
      &lt;li&gt;프로젝션 여러값조회
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objectp[] 타입으로 조회
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이징API
    &lt;ul&gt;
      &lt;li&gt;JPA는 페이징을 추상화함&lt;/li&gt;
      &lt;li&gt;setFirstResult(int startPosition) : 조회시작 위치&lt;/li&gt;
      &lt;li&gt;setMaxResult(int maxResult):조회할 데이터수
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m order by m.name desc&quot;;
List&amp;lt;Member&amp;gt; resultList = em.createQuery(jpql, Member.class)
  .setFirstResult(10);
  .setMaxResult(20)
  .getResultList();
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인
    &lt;ul&gt;
      &lt;li&gt;내부조인 : select m from Member m [INNER] join m.team t&lt;/li&gt;
      &lt;li&gt;외부조인 : select m from Member m left [outer] join m.team t&lt;/li&gt;
      &lt;li&gt;세타조인 : selece count(m) from Member m, Team t where m.username = t.name&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;[]는 생략가능&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;조인 - on 사용가능
        &lt;ul&gt;
          &lt;li&gt;조인 대상 필터링
```
-jqpl-
select m.t from Member m left join m.team t on t.name = ‘A’&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;-sql-
select m.&lt;em&gt;, t.&lt;/em&gt; from Member m left join team t on m.team_ID=t.id and t.name = ‘A’&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 연관관계 없는 엔티티 외부 조인 가능
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;-jqpl-
select m,t from Member m left join Team t on m.username = t.name&lt;/p&gt;

        &lt;p&gt;-sql-
select m.&lt;em&gt;, t.&lt;/em&gt; from Member m left join Team t on m.username = t.name
```&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;서브쿼리 사용가능
        &lt;ul&gt;
          &lt;li&gt;exists, all, any,some, in 등 서브쿼리 지원함수 사용가능
``` 
//팀a의 소속인 회원(팀a가 존재하는지 확인후 회원확인)
select m from Member m where exist (select t from m.team t where t.name = ‘팀a’)&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;//전체상품 각각의 재고보다 주문량이 많은 주문들
select o from Order o where o.orderAmount &amp;gt; ALL (select p.stockAmount from Product p)&lt;/p&gt;

        &lt;p&gt;//어떤 팀이든 팀에 소속된 회원
select m from Membeer m where m.team = any(select t from Team t)
```&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;서브쿼리의 한계
            &lt;ul&gt;
              &lt;li&gt;JPA는 where,having 절에서만 서브쿼리 사용가능&lt;/li&gt;
              &lt;li&gt;select절도 가능(하이버네이트지원)&lt;/li&gt;
              &lt;li&gt;From절의 서브쿼리는 현재 JPQL에서 불가능
                &lt;ul&gt;
                  &lt;li&gt;조인으로 풀수있으면 풀어서 해결&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조건식 사용가능
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; select
  case when m.age &amp;lt;=10 then '학생요금'
       when m.age &amp;gt;=60 then '경로요금'
       else '일반요금'
  end
from Member m

select
  case t.name
       when 'teamA' then '인센110'
       when 'teamB' then '인센120'
       else '인센105'
  end
from Team t
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;coalesce : 하나씩 조회해서 null이 아니면 반환
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select  coalesce(m.username,'이름없는 회원')from Member m
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;nullif : 두 값이 같으면 null 반환, 다르면 첫번째 값 반환
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select  NULLIF(m.username,'관리자')from Member m
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;페치조인--실무에서-정말정말-중요함-&quot;&gt;페치조인 ( 실무에서 정말정말 중요함 )&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL 조인 종류 X&lt;/li&gt;
  &lt;li&gt;JPQL에서 성능 최적화를 위해 제공하는 기능
  ##### * 연관된 엔티티나 컬렉션을 sql 한번에 함께 조회 하는 기능&lt;/li&gt;
  &lt;li&gt;join fetch 명령어 사용&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;페치 조인 ::= [ left [ outer ]&lt;/td&gt;
          &lt;td&gt;inner ] join fetch 조인경로&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;회원을 조회하면서 연관된 팀도 함께 조회
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m join fetch m.team&quot;
List&amp;lt;Member&amp;gt; members = em.createQuery(jpql,Member.calss).getResultList();

for(Member member : members){
  System.out.println(&quot;username = &quot; = member.getUsername() + &quot;, &quot; + &quot;teamName = &quot; + member.getTeam().name());
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;컬렉션 페치 조인 사용코드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select t from Team t join fetch t.members where t.name = '팀A'&quot; List&amp;lt;Team&amp;gt; teams = em.createQuery(jpql, Team.class).getResultList();

for(Team team : teams) {
System.out.println(&quot;teamname = &quot; + team.getName() + &quot;, team = &quot; + team); for (Member member : team.getMembers()) {
//페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함
System.out.println(“-&amp;gt; username = &quot; + member.getUsername()+ &quot;, member = &quot; + member); }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;위와 같은 컬렉션 페치 조인은 중복된 결과를 가져온다.&lt;/li&gt;
      &lt;li&gt;SQL에 DISTINCT를 추가하지만 데이터가 다르므로 SQL 결과 에서 중복제거 실패&lt;/li&gt;
      &lt;li&gt;JPQL의 distinct 애플리케이션에서 중복 제거 시도 - 2가지 기능제공
        &lt;ul&gt;
          &lt;li&gt;sql에 distinct를 추가&lt;/li&gt;
          &lt;li&gt;애플리케이션에서 엔티티 중복제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페치 조인과 일반 조인의 차이
        &lt;ul&gt;
          &lt;li&gt;JPQL은 결과를 반환할 때 연관관계 고려X&lt;/li&gt;
          &lt;li&gt;단지 select 절에 지정한 엔티티만 조회할 뿐&lt;/li&gt;
          &lt;li&gt;여기서는 팀 에네티티만 조회하고, 회원 엔티티는 조회X&lt;/li&gt;
          &lt;li&gt;페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시로딩)&lt;/li&gt;
          &lt;li&gt;페치조인은 객체 그래프를 SQL 한번에 조회하는 개념&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페치 조인 대상에는 별칭을 줄 수 없다.&lt;/li&gt;
      &lt;li&gt;둘이상의 컬렉션은 페치 조인 할 수 없다.&lt;/li&gt;
      &lt;li&gt;컬렉션을 페치 조인하면 페이징AP를 사용할 수 없다.
        &lt;ul&gt;
          &lt;li&gt;일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능&lt;/li&gt;
          &lt;li&gt;하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우위험)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;연관된 엔티티들을 sql 한번으로 조회-성능최적화&lt;/li&gt;
      &lt;li&gt;엔티티직접 적용하는 글로벌 로딩 전략보다 우선함
        &lt;ul&gt;
          &lt;li&gt;@OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실무에서 글로벌 로딩 전략은 모두 지연로딩&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;최적화가 필요한 곳은 페치 조인 적용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;페치조인 정리
        &lt;ul&gt;
          &lt;li&gt;모든 것을 페치 조인으로 해결할 수 는 없음&lt;/li&gt;
          &lt;li&gt;페치조인은 객체 그래프를 유지할 때 사용하면 효과적&lt;/li&gt;
          &lt;li&gt;여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;경로-표현식&quot;&gt;경로 표현식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상태 필드 : 단순히 값을 저장히기 위한 필드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(경로 탐색의 끝, 탐색 X)
select m.username, m.age from Member m
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;연관필드 : 연관관계를 위한 필드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;단일값 연관경로 : 묵시적 내부 조인 발생, 탐색 O
select m.team from Team t
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;연관필드는 사용치 말고 이를 명시적인 join을 사용해라&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select m from Member m join m.team t
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;###### why???&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n+1의 문제 발생가능하므로&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;경로 표현식 예제
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select o.member.team from Order o -&amp;gt; 성공

select t.members from Team -&amp;gt; 성공

select t.members.username from Team t -&amp;gt; 실패

select m.username from Team t join t.members m -&amp;gt; 성공
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;실무조언
    &lt;ul&gt;
      &lt;li&gt;가급적 묵시적 조인 대신에 명시적 조인 사용&lt;/li&gt;
      &lt;li&gt;조인은 SQL튜닝에 중요 포인트&lt;/li&gt;
      &lt;li&gt;묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다형성-쿼리&quot;&gt;다형성 쿼리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;조횧 대상을 특정 자식으로 한정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select i from Item i
where type(i) IN (BOOK,Movie)
-------

-jpql-
select i from Item i 
where treat(i as Book).auther = 'kim'
-sql-
select i.* from Item i 
where i.DTYPE = 'B' and i.author = 'kim'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;엔티티-직접-사용&quot;&gt;엔티티 직접 사용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본키 값을 사용
    &lt;h3 id=&quot;named-query&quot;&gt;Named query&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;미리 정의해서 이름을 부여해두고 사용하는 jpql&lt;/li&gt;
  &lt;li&gt;정척쿼리&lt;/li&gt;
  &lt;li&gt;어노테이션,xml에 정의&lt;/li&gt;
  &lt;li&gt;애플리 케이션 로딩 시점에 초기화 후 재사용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 로딩 시점에 쿼리를 검증&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;=&amp;gt; named query의 장점
    &lt;ul&gt;
      &lt;li&gt;로딩시점에 쿼리를 검증하므로 애러를 막을수있음&lt;/li&gt;
      &lt;li&gt;로딩시점에 쿼리를 파싱하므로 빠름
        &lt;h3 id=&quot;벌크-연산&quot;&gt;벌크 연산&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿼리한번으로 여러 테이블 로우 변경(엔티티)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m where m.age = 20&quot;

int resultCount = em.createQuery(jpql,INTEGER.class).executeUpdate();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;벌크연산주의
    &lt;ul&gt;
      &lt;li&gt;벌크 연산은 영속성 컨테스트를 무시하고 데이터 베이스에 직접 쿼리
        &lt;ul&gt;
          &lt;li&gt;벌크연산을 먼저수행한다.&lt;/li&gt;
          &lt;li&gt;벌크 연산 수행후 영속성 컨텍스트 초기화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why?? 초기화 해야하는가?
        &lt;ul&gt;
          &lt;li&gt;DB상에 직접쿼리를 날리므로 그전에 persist(entity)한 값들이 1차캐시에 남아있다. 컨텍스트를 초기화 하지않고 조회하면 그전에 1차캐시의 값들을 가져오기 때문에&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/31/jpa-concept-9/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/31/jpa-concept-9/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-8</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;데이터-타입-분류&quot;&gt;데이터 타입 분류&lt;/h2&gt;

&lt;h3 id=&quot;기본값-타입&quot;&gt;기본값 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;엔티티 타입
    &lt;ul&gt;
      &lt;li&gt;@Entity로 정의하는 객체&lt;/li&gt;
      &lt;li&gt;데이터가 변해도 식별자로 지속해서 추적 가능&lt;/li&gt;
      &lt;li&gt;예) 회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값 타입
    &lt;ul&gt;
      &lt;li&gt;int, Integer,String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체&lt;/li&gt;
      &lt;li&gt;식별자가 없고 갑만 있으므로 변경시 추적 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본값타입 : int ,string 자바 기본타입&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션 값 타입 : 자바 컬렉션에 기본값타입을 넣은것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 값 타입 특징
    &lt;ul&gt;
      &lt;li&gt;생명주기를 엔티티의 의존&lt;/li&gt;
      &lt;li&gt;값 타입은 공유하면 X&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;임베디드-타입&quot;&gt;임베디드 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;임베디드 타입 : 커스텀한 값타입 (새로운 값타입을 직접 정의할 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;member.class&amp;gt;
    @Embedded
    private Period workPeriod;

    // 주소
    @Embedded
    private Address homeAddress;

    ---------------------
    &amp;lt;Period.class&amp;gt;
    @Embeddable // 값타입이라고 알려주는 애노테이션
    public class Period {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;재사용이 가능하다&lt;/li&gt;
      &lt;li&gt;높은 응집도&lt;/li&gt;
      &lt;li&gt;Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음.&lt;/li&gt;
      &lt;li&gt;임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;임베디드 타입은 엔티티의 값일 뿐이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컬럼 명이 중복됨( 한 엔티티에서 같은 값 타입을 사용하려면?)
    &lt;ul&gt;
      &lt;li&gt;@AttributeOverrides를 사용하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;값타입과-불변-객체&quot;&gt;값타입과 불변 객체&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;임베디드 타입을 사용할시에 여러가지 튜플이 존재할수있고 이를 하나의 어트리뷰트를 가르킬수있다. 
객체(jpa)상에서 회원1과 회원2가 같은 Address를 가리키는것!&lt;/li&gt;
  &lt;li&gt;이때 임베디드 타입은 객체 타입이므로 회원1의 Address 변경시 회원2또한 변경된다.
    &lt;ul&gt;
      &lt;li&gt;객체타입은 주소값을 넘기는 참조값이므로 (값을 복사하는 기본값타입이 아님)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 부작용(side effect)이 발생가능 하고 이를 추적하기 매우 까다로움&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그러므로 이를 미연에 방지하는 코드가 좋은 코드이다. 이를 방지하기 위해서는&lt;/li&gt;
  &lt;li&gt;객체를 불변객체로만드는것과 값(인스턴스)를 복사해서 사용하는것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Address address = new Address(&quot;city&quot;,&quot;street&quot;,&quot;10000&quot;);
  Member member = new Member();
  member.setName(&quot;aaa&quot;);
  member.setHomeAddress(address);
  em.persist(member);

  Address newAddress = new Address(&quot;city&quot;,&quot;street&quot;,&quot;10000&quot;);
  Member member2 = new Member();
  member2.setName(&quot;bbb&quot;);
  member2.setHomeAddress(newAddress);
  em.persist(member2);

  //member.getHomeAddress().setCity(&quot;newCity&quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드와 같이 각각의 멤버에 새로운 인스턴스를 설정해서 사이트이팩트를 방지해야한다.&lt;/p&gt;

&lt;h3 id=&quot;값타입-컬렉션&quot;&gt;값타입 컬렉션&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;값 타입을 하나 이상 저장할 때 사용&lt;/li&gt;
  &lt;li&gt;@ElementCollection, @CollectionTable사용&lt;/li&gt;
  &lt;li&gt;데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션을 저장하기 위한 별도의 테이블이 필요함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;값타입 컬렉션의 제약사항
    &lt;ul&gt;
      &lt;li&gt;값타입은 엔티티와 다르게 식별자 개념이 없다.&lt;/li&gt;
      &lt;li&gt;값은 변경하면 추적이 어렵다.&lt;/li&gt;
      &lt;li&gt;값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제 하고, 값타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값타입 컬렉션 대안
    &lt;ul&gt;
      &lt;li&gt;실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/30/jpa-concept-8/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/30/jpa-concept-8/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-7</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
  &lt;h2 id=&quot;프록시&quot;&gt;프록시&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li&gt;즉시로딩과 지연로딩&lt;/li&gt;
    &lt;li&gt;지연로딩 활용&lt;/li&gt;
    &lt;li&gt;영속성 전이 : cascade&lt;/li&gt;
    &lt;li&gt;고아 객체&lt;/li&gt;
    &lt;li&gt;영속성 전이 + 고아객체, 생명주기&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;프록시와-연관관계&quot;&gt;프록시와 연관관계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Member를 조회할때 Team도 조회 해야할까?
member를 통해서 team까지 연계 되는 비즈니스 로직이라면 효율적이나 &lt;br /&gt;
member만 필요한 비즈니스 로직이라면 비효율적이다. &lt;br /&gt;
=&amp;gt; 이를 위해서 jpa에서는 지연로딩과 프록시를 통해서 케어를한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프록시 기초&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;em.find() : DB를 통해서 실제 엔티티 객체 조회&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;em.getReference() : DB 조회를 미루는 가짜(프록시) 엔티티 객체 조회&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시의 특징 1
        &lt;ul&gt;
          &lt;li&gt;실제 클래스를 상속 받어서 만들어짐&lt;/li&gt;
          &lt;li&gt;실제 클래스와 겉 모양이 같다.&lt;/li&gt;
          &lt;li&gt;사용하는 입장에서는 진짜 객체인지 프롯기 객체인지 구분하지 않고 사용하면 됨(이론상)&lt;/li&gt;
          &lt;li&gt;프록시 객체는 실제 객체의 참조(target)를 보관&lt;/li&gt;
          &lt;li&gt;프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드호출&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시 호출순서
        &lt;ol&gt;
          &lt;li&gt;getName()&lt;/li&gt;
          &lt;li&gt;초기화 요청( 영속성 컨텍스트)&lt;/li&gt;
          &lt;li&gt;DB조회&lt;/li&gt;
          &lt;li&gt;실제 Entity의 메소드 호출함&lt;/li&gt;
          &lt;li&gt;4번의 값을 target.getName()으로 반환함 (실제객체의 참조를 보관)&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시의 특징(주의)
        &lt;ul&gt;
          &lt;li&gt;프록시 객체는 처음 사용할 때 한번만 초기화&lt;/li&gt;
          &lt;li&gt;프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능&lt;/li&gt;
          &lt;li&gt;프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교실패, instance of 사용)&lt;/li&gt;
          &lt;li&gt;영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환&lt;/li&gt;
          &lt;li&gt;영속성 컨텐스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화 하며 문제 발생(하이버네이트는 org.hibernate.LazyinitializationException 예외를 터트림)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시 확인
        &lt;ul&gt;
          &lt;li&gt;프록시 인스턴스의 초기화 여부 확인
            &lt;ul&gt;
              &lt;li&gt;emf.PersistenceUnitUitl.isLoaded(Object entity)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;프록시 클래스 확인 방법
            &lt;ul&gt;
              &lt;li&gt;entity.getclass()&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;강제 초기화
            &lt;ul&gt;
              &lt;li&gt;Hibernate.initialize(entity);&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;즉시로딩과-지연로딩&quot;&gt;즉시로딩과 지연로딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Member를 조회할때 Team도 조회 해야할까?
member를 통해서 team까지 연계 되는 비즈니스 로직이라면 효율적이나 &lt;br /&gt;
member만 필요한 비즈니스 로직이라면 비효율적이다. &lt;br /&gt;
=&amp;gt; 이를 위해서 jpa에서는 지연로딩과 프록시를 통해서 케어를한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 지연 로딩 및 즉시로딩 사용법
  @ManyToOne(fetch = FetchType.LAZY)  //FetchType.EAGAR
  @JoinColumn(name = &quot;TEAM_ID&quot;)
  private Team team;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;지연로딩 내부 순서
    &lt;ul&gt;
      &lt;li&gt;LAZY로 되어있는 entity 조회&lt;/li&gt;
      &lt;li&gt;그리고 관련된 team은 프록시객체 생성되어있다.&lt;/li&gt;
      &lt;li&gt;실질적인 team의 메소드를 호출할때 초기화가 진행되어 쿼리를 날린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실무에서는 즉시로딩 주의
    &lt;ul&gt;
      &lt;li&gt;가급적 지연 로딩만 사용(특히 실무에서)&lt;/li&gt;
      &lt;li&gt;즉시로딩을 적용하면 예상하지 못하는 sql 발생&lt;/li&gt;
      &lt;li&gt;즉시로딩은 JPQL에서 N+1 문제를 일으킨다.&lt;/li&gt;
      &lt;li&gt;무조건 LAZY로 사용해라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지연로딩 활용 - 실무
    &lt;ul&gt;
      &lt;li&gt;모든 연관관계에 지연로딩을 사용해라!&lt;/li&gt;
      &lt;li&gt;실무에서 즉시로딩을 사용하지 마라!&lt;/li&gt;
      &lt;li&gt;JPQL fetch조인이나, 엔티티 그래프 기능을 사용해라!&lt;/li&gt;
      &lt;li&gt;즉시로딩은 상상하지 못한 쿼리가 나간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;영속성-전이--cascade--orhanremoval--true&quot;&gt;영속성 전이 : CASCADE &amp;amp; orhanRemoval = true&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때&lt;/li&gt;
  &lt;li&gt;저장,삽입,삭제 모두 가능
  ```
  @OneToMany(mappedBy = “parent”,cascade = CascadeType.ALL,orphanRemoval = true)
  private List&lt;Child&gt; childList = new ArrayList&amp;lt;&amp;gt;();&lt;/Child&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;————— 트랜잭션 부분 ——-
    Child child1 = new Child();
    Child child2 = new Child();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent parent = new Parent();
parent.addChild(child1);
parent.addChild(child2);

em.persist(parent);
//em.persist(child1);
//em.persist(child2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영속성 전이는 연관관계를 매핑하는것과 아무 관련이 없음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;엔티티를 영속화 할때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;고아객체(orphanRemoval)
    &lt;ul&gt;
      &lt;li&gt;부모엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cascade와 고아객체 모두 주의할점
    &lt;ul&gt;
      &lt;li&gt;참조한느곳이 하나일 때 사용해야 함&lt;/li&gt;
      &lt;li&gt;특정 엔티티가 개인 소유할 떄 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/30/jpa-concept-7/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/30/jpa-concept-7/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-6</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;상속관계-매핑&quot;&gt;상속관계 매핑&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;관계형 데이터베이스는 상속 관계 X&lt;/li&gt;
  &lt;li&gt;슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;슈퍼타입 서브타입 논리모델을 실제 물리 모델로 구현하는 방법
    &lt;ul&gt;
      &lt;li&gt;각각 테이블로 변환 -&amp;gt; 조인 전략 ( 가장 정규화된 방식 )&lt;/li&gt;
      &lt;li&gt;통합 테이블로 변환 -&amp;gt; 단일 테이블 전략&lt;/li&gt;
      &lt;li&gt;서브타입 테이블로 변환 -&amp;gt; 구현 클래스마다 테이블 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인전략(장점)
    &lt;ul&gt;
      &lt;li&gt;테이블 정규화&lt;/li&gt;
      &lt;li&gt;외래 키 참조 무결성 제약 조건 활용가능&lt;/li&gt;
      &lt;li&gt;저장공간 효율화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인전략(단점)
    &lt;ul&gt;
      &lt;li&gt;조회시 조인을 많이 사용, 성능저하&lt;/li&gt;
      &lt;li&gt;조회 쿼리가 복잡함&lt;/li&gt;
      &lt;li&gt;데이터 저장시 insert sql2번 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단일테이블전략(장점)
    &lt;ul&gt;
      &lt;li&gt;조인이 필요 없으므로 일반적으로 조회 성능이 빠름&lt;/li&gt;
      &lt;li&gt;조회 쿼리가 단순함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단일테이블전략(단점)
    &lt;ul&gt;
      &lt;li&gt;자식 엔티티가 매핑한 컬럼은 모두 null허용&lt;/li&gt;
      &lt;li&gt;단일 테이블에 모든 것을 저장하므로 테이블이 커질수 있고 상환에따라서 조회 성능이 오히려 느려질수있다.(임계점을 넘어야한다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현 클래스마다 테이블전략 -&amp;gt; 사용치 마라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##### 어떤전략을 사용해야하나?
    이부분에서는 DB설계자와 잘 협의하여야한다. 기본적으로는 join전략을 사용하는게 좋다. &lt;br /&gt;
    추후 비즈니스 로직이 추가될 것을 생각하면!! &lt;br /&gt;
    하지만 간단한 테이블이고 추후 더 발전 가능성이 없다고 생각하면 단일테이블전략으로 가라 !!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실무에서 상속 관계를 쓰느냐??
경우에 따라 다르다. &lt;br /&gt;
데이터가 많아지면 테이블이 단순해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mappedsuperclass&quot;&gt;@MappedSuperclass&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;공통 매핑 정보가 존재할때 속성만 상속해서 사용하고 싶을때 ( 디비는 각각 다르다 ) 객체에서만 속성을 묶는것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계 매핑 X&lt;/li&gt;
  &lt;li&gt;엔티티 X, 테이블과 매핑X&lt;/li&gt;
  &lt;li&gt;부모클래스를 상속 받는 자식 클래스에 매핑 정보만 제공&lt;/li&gt;
  &lt;li&gt;조회,검색 불가(em.find(BaseEntity)불가)&lt;/li&gt;
  &lt;li&gt;직접 생성해서 사용할 일이 없으므로 추상 클래스 권장&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/29/jpa-concept-6/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/29/jpa-concept-6/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
  </channel>
</rss>

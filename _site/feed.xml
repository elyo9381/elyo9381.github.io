<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elyo</title>
    <description>진심을 다해서 
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 20 May 2021 15:53:42 +0900</pubDate>
    <lastBuildDate>Thu, 20 May 2021 15:53:42 +0900</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>spring AOP-4(spring AOP)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;aop--logback-springxml&quot;&gt;AOP &amp;amp; logback-spring.xml&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;AOP를 사용하여 로그(파일,콘솔) 찍는 연습 및 코드&lt;/li&gt;
  &lt;li&gt;setry를 이용한 온라인 로그 찍기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;logback-spring&quot;&gt;&lt;strong&gt;logback-spring&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;로그를 파일로 저장하기 위해서는 logback-spring.xml 파일을 만들어 설정을 해줘야한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LOGS_ABSOLUTE_PATH&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./logs&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STDOUT&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;layout&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.classic.PatternLayout&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;Pattern&amp;gt;&lt;/span&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{36} - %msg%n&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FILE&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${LOGS_ABSOLUTE_PATH}/logback.log&lt;span class=&quot;nt&quot;&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;[%d{yyyy-MM-dd HH:mm:ss}:%-3relative][%thread] %-5level %logger{35} - %msg%n&lt;span class=&quot;nt&quot;&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${LOGS_ABSOLUTE_PATH}/logback.%d{yyyy-MM-dd}.%i.log.gz&lt;span class=&quot;nt&quot;&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;5MB&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;30&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;root&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;level=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STDOUT&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;logger&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.ddoel.person.demo.config&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;level=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WARN&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FILE&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/logger&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;이 코드는 거의 복붙하는것이다. 우리가 설정해줘야하는 부분은 &amp;lt;root&amp;gt;, &amp;lt;logger&amp;gt; 부분이다. &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;aop-연습&quot;&gt;&lt;strong&gt;AOP 연습&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;우리는 validate 그리고 로그를 aop를 이용해서 처리(중복처리) 할수있다.&lt;/p&gt;

&lt;p&gt;이는 joinpot, pointcut, advice를 통해서 가능하는데 이는 이전 포스트를 참고하자.&lt;/p&gt;

&lt;p&gt;AOP시에 중요한것은 Advice를 설정과 Dto 설정이다.&lt;/p&gt;

&lt;p&gt;validate를 설정하고 이를 판별할때 dto를 사용하지 않는다면 entity의 직접적인 접근이되어 값이 변할 가능성이 존재한다. 그러므로 commonDto,joinReqDto,updateReqDto를 설정하여 관리하는것이 좋다. (user-domain(entity))에서&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//@Before
//@After
@Around(&quot;execution(* com.ddoel.person.demo.web..*Controller.*(..))&quot;)
public Object validCheck(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {


    //request 값 처리 못하나요?
    HttpServletRequest request =
            ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();
    log.info(&quot;주소 : {}&quot;,request);
    
    
    String type = proceedingJoinPoint.getSignature().getDeclaringTypeName();
    String method = proceedingJoinPoint.getSignature().getName();

    log.info(&quot;type confirm : {}&quot;, type);
    log.info(&quot;method confirm : {}&quot;, method);

    // 아규먼트 리턴
    Object[] args = proceedingJoinPoint.getArgs();

    for (Object arg : args) {
        if(arg instanceof BindingResult){
            BindingResult bindingResult = (BindingResult) arg;


            // 서비스 : 정상적인 화면 -&amp;gt; 사용자요청
            if(bindingResult.hasErrors()){
                Map&amp;lt;String,String&amp;gt; errorMap = new HashMap&amp;lt;&amp;gt;();

                for(FieldError error : bindingResult.getFieldErrors()){
                    errorMap.put(error.getField(),error.getDefaultMessage());
                    log.warn(type+&quot;.&quot;+method+&quot;()=&amp;gt;필드 : &quot;+error.getField()+&quot;, 메시지:&quot;+error.getDefaultMessage());
                    Sentry.captureMessage(type+&quot;.&quot;+method+&quot;()=&amp;gt;필드 : &quot;+error.getField()+&quot;, 메시지:&quot;+error.getDefaultMessage());
                }

                return new CommonDto&amp;lt;&amp;gt;(HttpStatus.BAD_REQUEST.value(),errorMap);
            }
        }
    }

    return proceedingJoinPoint.proceed();// 함수의 시택을 실행하라.
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드는 advice를 설정한 코드이다.&lt;/p&gt;

&lt;p&gt;@Around,@Before,@After 등을 통해서 조인포인트를 설정할수있다. 또한 excution을 통해 어떤 메소드를 포인트컷할지 설정도 가능하다.&lt;/p&gt;

&lt;p&gt;위의 설정을 끝내고 실질적인 advice (중복 메서드) 가 실행된다.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/05/17/spring-ioc-17-AOP(4)/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/05/17/spring-ioc-17-AOP(4)/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>git &amp; github 정리</title>
        <description>&lt;h2 id=&quot;왜-add를-사용하는가&quot;&gt;왜 add를 사용하는가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정한 원하는 파일만 저장하기 위해서이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;log--diff&quot;&gt;log &amp;amp; diff&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git log 를 진행하면 역사를 볼수있다. 
- git log - p : 최신 커밋과 이전커밋의 차이점을 볼수있다.
 - +++는 추가된 내용이며, ---는 이전 버전의 내용이다. 
 - git log에는 커밋it가 나와있다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;git diff 커밋id, 커밋id : 커밋들의 차이를 보여준다. 소스코드의 차이점을 보여줌&lt;/li&gt;
  &lt;li&gt;git diff : 현재 내가 작업한(수정한) 내용을 볼수있다. 이전코드와 수정한 코드의 차이를 볼수있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;commit-cancel&quot;&gt;Commit cancel&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- reset : 특정 커밋을 최신상태로 하고싶을때 -&amp;gt; git reset 커밋id --hard
  - 리셋은 공유환경에서 사용하면 안된다. 
  - --hard : 

- revert : 특정 커밋을 취소하고 해당 커밋을 새로운 버전으로 생성한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-add-원리&quot;&gt;git add 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git의 파일의 이름은 index에 담겨있고 파일의 내용은 objects파일에 들어있다.
- index, objects 파일은 .git 폴더안에 들어있다.
- git은 파일의 이름이 다르더라도 내용이 같다면 같은 인덱스를 가진다. 그리고 이 인덱스는 같은 오브젝트를 가르킨다.
- git은 해쉬값 + 몇가지 부가적인 값을 통해서 add 를 진행하고 커밋을 객체를 만든다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-commit-원리&quot;&gt;git commit 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 커밋파일에는 커밋 메시지, tree , 사용자정보, parent 가 들어있다. 
- tree는 우리가 작성한 파일의 이름이 존재한다. 각각의 버전마다 tree의 값이 다르다. 
  - 이를 스냅샷을 찍었다라고 한다. 
- parent는 이전 커밋을 의미한다. 

- 중요정보 parent, tree의 관계가 중요하다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index-파일-지레짐작&quot;&gt;index 파일 지레짐작&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- status의 상태를 어떻게 알까?
- object와 index의 내용이 같으면 status가 같다고 보는것같다. 
- 이는 해쉬값을 통해서 비교하는것 같다. 인덱스, 트리, 그리고 local데이터를 비교하여 다르면 status를 바꾼다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-branch&quot;&gt;git branch&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git branch : 브랜치를 조회할수있는 명령어
- git branch filename : 브랜치 생성
- git checkout filename : 브랜치 이동

- git log --branches --decorate : 모든 브랜치를 볼수있는 명령어
- git log --branches --decorate --graph : 그래프 기능이 추가된다. 
- git log --branches --decorate --graph --oneline : 한눈에 보기 싶다. 

- git log master..exp : 마스터에는 없고 exp에는 존재하는 커밋을 보여줌
- git log exp..master -p : exp에는 없고 마스터에는 존재하는것 그리고 -p를 통해서 상세하게 비교해준다. 

- git diff master..exp : exp에 추가적인 정보가 어떤게 있는지 비교하여 보여준다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-merge&quot;&gt;git Merge&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마스터로 머지하려면 마스터로 checkout해야한다. 
- git merge exp : 현재 브랜치에 exp를 머지한다.
- git merge master : exp의 브랜치를 master로 시점을 맞춰주는 역할을한다.

만약에 병합이 잘되었다면 기존의 exp branch는 삭제 해도된다. 
- git branch - d exp : 브런치를 삭제하는 명령어
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-연습&quot;&gt;git 연습&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git tutorial 을 통해서 연습하자. 

마스터 브랜치가 존재하고 이에 따른 커밋을 3번하였다.

이때 새로운 브런치를 생성한다. 
```
git checkout -b issue53; 
```

이렇게 되면git은 두가지의 브랜치를 갖는다. 그리고 브런치를 커밋하면 브랜치는 새로운 브랜치를 가르킨다. 

이때 또다른 B 브랜치를 생성하고 이를 마스터 브랜치에 머지한다. 

이럴때 FastForward가 발생한다. 
FastForward : B 브랜치를 마스터에 병합할때 마스터가 B 브런치를 가르키게 하는 역할을 한다. 
 - 즉 빨리감기를 한다. 

그리고 마지막 브런치 A(issue53)을 마스터에 병합할때 merge recursion이 발생한다. 

이때 깃은 마스터와 A의 공통의 parent를 찾고 후에 3wayMerge방법을 이용해서 브랜치들을 병합하고 
별도의 커밋을 생성한다. 그리고 새로운 커밋을 마스터가 가르킨다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-stash&quot;&gt;git stash&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 작업이 끝나지 않았을때 다른 브랜치로 이동해서 급하게 일을 수행하는경우 사용한다. 
- 브랜치를 특정 공간에 숨길수있다. 그리고 새로운 업무를 진행하고 다시 숨긴 브랜치를 사용할수있는것이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-branch-의-원리&quot;&gt;git branch 의 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git을 init하면 head 파일이 생성된다. 
- 그리고 커밋을 하면 refs/heads/master 가 생성된다. 이는 가장 최신 커밋을 가르킨다.

- git의 head는 최신 커밋을 가리키고 이는 object파일의 내용을 알수있다. 또한 object,tree,index 등의 해쉬값을 통해서 최신 커밋의 상태또한 알수있다. 
이전커밋은 parent를 통해서 이전 커밋도 알수잇다. 

- 브랜치를 생성하면 ./.git/refs/heads/exp가 생성된다. 이는 일반 텍스트 파일이다. 

- HEAD의 역할을 checkout을 한 최신 커밋을 가르킨다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-conflict&quot;&gt;git conflict&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마스터와 브랜치가 하나의 파일의 같은 라인소스를 수정할때 충돌이 일어난다. 
- 같은 코드의 다른 라인을수정한다면 이는 문제가 되지 않고 git이 recursionMerge한다. 

```
 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
 function(master){
 ========
 function(exp){
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
```

- == 는 코드의 다른 부분을 보여주는 분기이다. 
- 충돌해결은 재주것 해야한다. 리팩토링의 관점에서 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-reset-checkout-원리&quot;&gt;git reset checkout 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git reset --hard 커밋id : HEAD이 커밋ID를 보게 되고 이는 최신커밋ID 바꾸는 행위이다. 
- git은 rest을 하여도 삭제된것은 아니다. resert을 취소할수도 있기 떄문이다. 

- git log --hard ORIG_HEAD : reset을 취소할수있다. 

- git reflog : 각각의 로그를 볼수있다. 

- --hard, --soft, --mixed 개념 알기 
  1. working directory(workgin tree, working copy)  
  2. index(stating area,cache) 
  3. repository
  soft,mixed,hard는 각각 초기화되는 부분이 다르다.   
  soft(3), mixed(2,3), hard(1,2,3)의 범위를 갖는다.    
  
- soft : 레포지토리의 영역만 초기화된다.
- index : add영역(index)의 영역 + 레포지토리 초기화된다.
- hard : local(working)까지 모든 영역을 초기화한다.

- ORIG_HEAD : reset을 취소할때도 hard, soft, mixed를 설정해야한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conflict-원리&quot;&gt;conflict 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 3way merge 를 통해서 오토 커밋이 가능하다. 
  - 3Way merge : base,a,b 셋을 고려해서 병합하는 방법
  - 2way merge : a,b (branch)를 둘을 이용해서 병합하는 방법

  3Way는 4가지 출돌 경우의 수가 존재한다.
    1. a,base가 같은 코드이고 b가 수정했을때 B로 병합된다.
    2. a,base,b가 모두 같은 코드를 가르킬때 같은 데이터로 병합된다.
    3. base와 a,b가 모두 다를때 충돌이 발생한다.
    4. b,base가 같고 a가 코드를 수정했을때 a의 코드로 병합된다. 

    3Way는 모두 다를때만 충돌 나고 ,2way는 같을때 뺴고는 모두 충돌난다. 

- 병합을 전문적으로 하는 kdiff3가 존재한다. intellij, sourtree 등 다양하다. 

- 충돌이 났을때는 base, local, remote 가 존재한다. 
  - base는 common파일이며, local,remote는 같은코드를 접근한 파일이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;remote-repository&quot;&gt;remote repository&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- git init --bare : 저장소로서의 기능만 수능하는 init bare는 불변의 특징을 갖게하는것이다. 

- git remote add 경로 : 현재 디렉터리에 원격저장소 경로를 연결한다
- git push  : 원격 저장소에 데이터를 푸시(보낸다)
  - --set-upstream origin master : 마스터에서 푸시하면 자동으로 오리진 마스터에 푸시하겠다는 뜻
    : 로컬브랜치와 원격브랜치사이의 명시적인 설정 set-upstream 

- fork : fork를 하면 내가 특정 프로젝트를 내컴퓨터에서 사용할수있다. (복제)
  : 원격저장소에 복사된다. 
- git clone : 특정 원격 레포지토리를 다운로드한다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;원격-저장소의-원리&quot;&gt;원격 저장소의 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 로컬 master를 원격 저장소의 마스터에 연결해야한다. 
- remote를 하면 원격저장소를 위한 폴더(파일)이 생긴다. 
- 그리고 push --set-upstream origin master 를 하게 되면 각각 로컬과 원격저장소를 가르키는 파일들이 같은 커밋을 가르키게 된다. 
- 원격의 오리진과 지역의 마스터,HEAD르가 다를때 master를 orgin master에 push 하면 같은 커밋을 가르키게 되는것이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-pull-과-fetch의-차이&quot;&gt;git pull 과 fetch의 차이&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- pull : 원격과 로컬의 데이터가 차이가 없게 다운한다. HEAD, origin/master 가 같은 커밋을 가르킨다. 
  다운받고병합까지 할것이면 pull!!
- fetch : 원격저장소가 로컬저장소를 앞서게 된다. 
  이말은 무엇인가? : 원격저장소와 지역 저장소의 차이를 확인할수있다.    
  git diff등을 통하여 ex) git diff HEAD origin/master   
  그리고 이를 병합할수있다. git merge origin/master 같은 커밋을 가르키도록 병합할수있다.
  소스코드는 다운받지 않지만 차이점을 확인할때 fetch!!!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-tag&quot;&gt;git tag&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;branch와 비슷하지만 다르다. 

releases : 사용자들에게 제공되어도 되는 각각의 버전을 뜻한다. 
tab : 특정 커밋을 사용자가 다운로드하거나 기억할수있도록 하는것

- git tag 1.0.0 커밋id or 브랜치이름-&amp;gt; checkout을 통해서 특정 버전으로 갈수있다. 
- git tag - a 1.1.0 -m &quot;bug fix&quot; : annotated 를 설정할수잇다.  -a
  tag에 상세한 주석을 첨부할수있다.

- 원격 저장소에tag를 올릴수도 있다. git push --tag 
- tag 삭제 방법 : git tag -d 버전 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-tag-원리&quot;&gt;git tag 원리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tag를 생성하면 refs/tags/tag이름 파일이 생성된다.    
즉 tag는 텍스트 파일이다.   

이를 원격저장소 또는 로컬의 git에서 내부적으로 적용되는 방법은 workingtree, index, repository의 원리에 의해서 작동된다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-rebase&quot;&gt;git rebase&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rebase : 소스코드를 병합하는 하나의 방법이다.
  1. merge 병렬적으로 병합하지만 rebase는 임시저장소를 이용해 직렬적으로 병합한다. 
  2. 공통 base를 토대로 브런치를 직렬화하면서 병합한다. 

- git rebase branchName
- git rebase continue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/05/17/git-tip/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/05/17/git-tip/</guid>
        
        <category>git</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>면접 질문 리스트 &amp; 답변</title>
        <description>&lt;p&gt;라이브러리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;독립성을 가진 최소단위의 기능이다. (함수[메서드] 단위)
    &lt;ul&gt;
      &lt;li&gt;재사용 가능한 최소 단위 기능 또는 기능들의 집합이다.&lt;/li&gt;
      &lt;li&gt;기능을 사용하기 위해 다른 기능이 필요하지 않아야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이브러리의 예&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 정렬한다  () or 역 정렬한다().&lt;/li&gt;
  &lt;li&gt;데이터를 하닜기 반환한다. or 반한화면서 삭제한다.&lt;/li&gt;
  &lt;li&gt;날짜에서 요일을 반환한다.() or 날짜에서 시간을 반환한다().&lt;/li&gt;
  &lt;li&gt;숫자를 더한다 or 숫자를 곱한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이브러리 구분&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;표준 라이브러리
    &lt;ul&gt;
      &lt;li&gt;언어가 제공해주는 기본 함수 ##stdio.h , import java.util.* 등의 SDK들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 정의 라이브러리
    &lt;ul&gt;
      &lt;li&gt;표준 라이브러리를 사용하여 만든 라이브러리.&lt;/li&gt;
      &lt;li&gt;기능별로 그룹화 하여 Wrapping 한것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프레임 워크&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Library와 다른 Framework의 집합체이다.
    &lt;ul&gt;
      &lt;li&gt;여러 Library와 여러 Framework가 포함되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;library와 framework의 단점과 장점
단점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;느리다 무겁다. 비용이 많이 듣다.&lt;/li&gt;
  &lt;li&gt;통제가 안된다. (오픈소스는 가능)&lt;/li&gt;
  &lt;li&gt;세팅,학습하는데 오래걸린다.
  ex) juery를 전체 적용했다가 코어부분은 바닐라js 다시 구현하는경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개발이 편하다. 재사용이 가능하다. 개발일정이 단축된다.&lt;/li&gt;
  &lt;li&gt;전문적인 고민과 노하우가 있어서 오류가 적다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속도와 성능이 필요한 서버 개발만 native로 하면된다. 
성능과 개발 생산성을 함께 고려해야한다. 최적화가 필요하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;왜 이렇게 생각하는지 모두 적어보자&lt;/p&gt;

&lt;p&gt;질문&lt;/p&gt;

&lt;h2 id=&quot;rest-api는-무엇인가&quot;&gt;Rest API는 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;API 설계시에 리소스중심이며 HTTP Method를 통해 api를 설계하는것이 restful api입니다.&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;open API를 제공하기 쉽다.&lt;/li&gt;
      &lt;li&gt;멀티 플랫폼 지원이 용이히다.&lt;/li&gt;
      &lt;li&gt;원하는 타입으로 데이터를 주고 받을수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;http 통신 모델에 대해서만 지원한다.&lt;/li&gt;
      &lt;li&gt;분산환경에는 부적합하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;절차지향과-객체지향의-차이점은-무엇이며-장단점은-무엇인가-&quot;&gt;절차지향과 객체지향의 차이점은 무엇이며 장단점은 무엇인가 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;절차지향 : 수행되어야 할 연속적인 계산과 과정을 포함하고 있는 프로그래밍 패러다임입니다.&lt;/li&gt;
  &lt;li&gt;객체지향 : 강한 응집력과 약한 결합력을 위해 현실세계의 객체라는 개념을 이용한 프로그래밍 패러다임입니다.&lt;/li&gt;
  &lt;li&gt;공통점 : 모듈화된 프로그램구현 방법이 사용됩니다.&lt;/li&gt;
  &lt;li&gt;차이점 : 추상화, 다형성, 상속, 캡슐화을 통하여서 강한 응집력과 약한 결합력을 나타낼수있으며 이러한 특징을 통해서 재사용성이 용이합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-설계-5원칙&quot;&gt;객체지향 설계 5원칙&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;SRP(단일 책임 원칙) : 클래스와 메소드는 하나의 역할만 하도록 한다.&lt;/li&gt;
  &lt;li&gt;OCP(개방 폐쇠 원칙) : 자신의 확장은 개방하고, 변경은 (방지)한다.&lt;/li&gt;
  &lt;li&gt;LSP(리스코프 치환 원칙) : 서브타입은 언제나 자신의 상위타입으로 교체할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;ISP(인터페이스 분리 원칙) : 객체는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.&lt;/li&gt;
  &lt;li&gt;DIP(의존 역전 원칙) : 자신보다 변하기 쉬운것에 의존하지 마라
    &lt;ul&gt;
      &lt;li&gt;추상화된것에 구체적인것이 의존해야한다. 이것의 반대가 되면 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;데이터-타입과-변수의-차이는-뭔가요&quot;&gt;데이터 타입과 변수의 차이는 뭔가요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 타입 : 컴퓨터에서 값을 식별하기위한 식별자입니다.
    &lt;ul&gt;
      &lt;li&gt;프로그램을 실행하지 않고도 결정할 수있는 프로그램의 특성으로 정의 됩니다.&lt;/li&gt;
      &lt;li&gt;기본타입과 참조타입으로 나눠집니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변수 : 특정 데이터 타입에서 변할수있는 값저장소 라고 말할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;차이점 :  둘의 차이는 계층이 다르다고 생각합니다. 데이터타입이 더 상위 계층이라고 생각합니다.
    &lt;ul&gt;
      &lt;li&gt;변수의 값은 범위내에서 변할수있는 데이터 이지만 데이터 타입은 임의적으로 변화해서는 안되는 변수를 표현하는 데이터 형식이라고 생각합니다.&lt;/li&gt;
      &lt;li&gt;변수는 데이터 타입에 종속적입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;밸류타입과-레퍼런스-타입이-무엇인가요-대표적인것을-예로-들어&quot;&gt;밸류타입과 레퍼런스 타입이 무엇인가요 (대표적인것을 예로 들어)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;밸류타입 : 메모리 호출시 메모리에 저장되어있는 값을 복사하는 타입 (primitive type) 타입&lt;/li&gt;
  &lt;li&gt;레퍼런스 : 메모리 호출시 메모리에 저장되어있는 주소 값을 복사하는 타입 (배열,클래스,열거,인터페이스) 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문자열은-char형과-string형으로-나눠진-이유는-뭔가요-&quot;&gt;문자열은 char형과 string형으로 나눠진 이유는 뭔가요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;string 형은 string 클래스 이고 참조타입니다.&lt;/li&gt;
  &lt;li&gt;이는 char배열에 여러가지 메소드를 추가한것이 string 클래스입니다.&lt;/li&gt;
  &lt;li&gt;char배열을 라이브러리로 만든것이 string 클래스라고 할수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;힙과-스택-영역에-대해서-설명할수있나요&quot;&gt;힙과 스택 영역에 대해서 설명할수있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JVM : OS의 한정된 메모리를 효율적으로 사용하기 위한 스택기반의 가상머신(메모리관리, GC)입니다.&lt;/li&gt;
  &lt;li&gt;클래스 로더 : JVM 내에서 클래스를 로드하고 링크하는 역할, JVM위에서 사용하지 않는 클래스들은 메모리에서 삭제되며, 런타임에 참조된다.&lt;/li&gt;
  &lt;li&gt;Execution Engine : 변환된 파일을 실행시키는 역할, 자바 바이트 코드를 기계가 실행할 수 있는 형태로 변경된 코드를 실행한다.&lt;/li&gt;
  &lt;li&gt;GC : 힙영역의 메모리해제를 관리하는 기능입니다. 참조되지 않은 객체, 자주 사용되는 객체, 메모리 할당된 객체를 중점으로 GC가 힙영역의 메모리를 관리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스택이-존재하는-이유는-무엇인가요-&quot;&gt;스택이 존재하는 이유는 무엇인가요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;독립적인 메모리공간을 위해서 스택이 존재합니다. 독립적으로 사용될 변수, 되돌아갈 주소 등을 저장하기 위해서 스택이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals-과--연산자의-차이가-무엇인가요&quot;&gt;equals() 과 == 연산자의 차이가 무엇인가요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;equal함수는 데이터값만 같으면 참거짓을 반환하고 ==은 객체(주소값) 와 데이터 값이 같아야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals에서-객체가-같음을-어떻게-비교-할까요-&quot;&gt;equals에서 객체가 같음을 어떻게 비교 할까요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최종적으로는 == 연산자를 통해서 비교하지만 이를 위해서 형변환 및 equals 오버라이딩이 필요합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;new는-왜-생성하나요-&quot;&gt;new는 왜 생성하나요 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;제한되어 있는 메모리를 효율적으로 사용하기 위해서 new를 사용합니다.&lt;/li&gt;
  &lt;li&gt;이는 heap 영역에서 데이터를 관리하여 메모리를 효율적으로 사용할수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;Eden, old Memory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해쉬코드에-대해서-설명하라&quot;&gt;해쉬코드에 대해서 설명하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;해시(임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변화시키는)자료구조를 통해서 도출된 임의의 값을 생성하는 코드가 해시 코드이다. 자바에서는 이를 통해 객체의 값을 비교 한다. 해시는 해시함수, 해시테이블 등으로 구성되며 충돌이 일어나지 않게 구성해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시의-충돌-해결-방법&quot;&gt;해시의 충돌 해결 방법&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;open Address방식
    &lt;ul&gt;
      &lt;li&gt;해시 충돌이 발생하면, 다른 해시버킷에 해당 자료를 삽입하는 방식이다.&lt;/li&gt;
      &lt;li&gt;충돌이 발생하면 다른 버킷을 찾는데 worstCase의 경우에는 충돌을 해결치 못하고 다시 원상태로 되돌아올수도 있다.&lt;/li&gt;
      &lt;li&gt;linear probing : 버킷을 포함하는 해시테이블의 인덱스를 하나씩 늘려 버킷이 비었는지 확인한다.&lt;/li&gt;
      &lt;li&gt;Quadratic probing : 충돌 발생시 i^2으로 공간이 비었는지 확인한다.&lt;/li&gt;
      &lt;li&gt;DoubleHashing Probing : 해시된 결과값을 한번더 해시한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;seperate chaining
    &lt;ul&gt;
      &lt;li&gt;충돌이 발생하면 충돌지점에 리스트 &amp;amp; 트리 자료구조를 이용해서 충돌 데이터를 저장하는 방법입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장단점
    &lt;ul&gt;
      &lt;li&gt;오픈 어드레스 방법은 삭제하기 어렵다는 단점이 존재하고 버킷을 늘리면 배열과 다를바가 없어 효율적이지 않다.&lt;/li&gt;
      &lt;li&gt;체이닝 기법은 상대적으로 효과적인데 리스트로 충돌을 연결하면 연결할때마다 오버헤드를 감수해야하고 검색시 O(N)이된다.&lt;/li&gt;
      &lt;li&gt;체이닝 기법에서 트리를 사용하면 O(logN)으로 검색을 진행할수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;해쉬코드를-이용해서-같은-객체인지-비교하는-방법은-무엇인가요&quot;&gt;해쉬코드를 이용해서 같은 객체인지 비교하는 방법은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;해시코드를 이용해서 리턴값이 같은지 확인하여 같은객체 인지 확인하고 equals 메서드를 통해서 비교값이 같은지 확인합니다. 해시코드와 equals를 오버라이딩을 통해 값을 비교한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;equals-오버라이딩&quot;&gt;.equals() 오버라이딩&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;object 타입을 통해서 equals를 오버라이딩 하여 비교 할수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자바의-메모리-구조&quot;&gt;자바의 메모리 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;.java » javac가 컴파일 » .class(자바 바이트코드) » 클래스로더 &amp;lt;-&amp;gt; 익스쿠션엔진 » JVM&lt;/li&gt;
  &lt;li&gt;메모리는 JVM의 Runtime Data Areas에서 관리한다.&lt;/li&gt;
  &lt;li&gt;크게 staticArea , HeapArea , StackArea로 구분할수있다.&lt;/li&gt;
  &lt;li&gt;Method(static) : 클래스,인터페이스의 런타임상수,멤버변수, 생성자와 메소드를 저장하는 공간이다.&lt;/li&gt;
  &lt;li&gt;Heap : 런타임시 동적으로 메모리를 사용하는 영역 ,GC의 대상이된다.&lt;/li&gt;
  &lt;li&gt;Stack : 스레드마다 하나씩 존재하며, 스레드가 시작될때 할당한다. 자바의 primitive 타입, 메소드정보 , 지역변수, 등의 데이터를 저장한다. 또한 메서드 호출시 스레드정보 또한 stack에 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;string-pool이-무엇인가요&quot;&gt;string pool이 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;literal로 생성한 값이 string pool에 들어갑니다. 힙영역내의 literal로 생성한 string은 이에 들어가고 같은 값이 호출시에 string pool을 참조하여 객체를 리턴합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;멤버변수와-지역변수의-차이와-stack영역에-저장되는-변수는-누구인가요&quot;&gt;멤버변수와 지역변수의 차이와 stack영역에 저장되는 변수는 누구인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;stack에 저장되는 변수는 지역변수입니다. 멤버변수는 클래스의 내부변수이므로 Method Areas에 저장됩니다. 반면 지역변수는 스레드와 관계 있는 영역이므로 독립적인 stack에 저장되고 메모리영역의 차이가 둘의 차이입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스택영역와-힙영역의-변수들은-언제-해제가-되나요&quot;&gt;스택영역와 힙영역의 변수들은 언제 해제가 되나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스택영역의 변수들은 스레드 종료시 즉 해제 됩니다. 특정메소드 호출이 종료되거나 스레드가 종료되며 stack에 할당된 데이터는 해제 됩니다.&lt;/li&gt;
  &lt;li&gt;힙영역의 변수들은 명시적으로 해제 해주거나 GC에 의해서 해제가 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어떤-자료구조가-있는가&quot;&gt;어떤 자료구조가 있는가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열,리스트,스택,큐,덱,해싱, 그래프, 트리 등이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료구조를-선택하는-기준은-무엇인가요&quot;&gt;자료구조를 선택하는 기준은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;효율성입니다. 시간, 공간 복잡도를 고려한 효율적인 자료구조를 선택해야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listsetmap에-대해서-설명할수있나요&quot;&gt;list,set,map에 대해서 설명할수있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;list : 순서가 있는 데이터의 집합이며 중복을 허용합니다.&lt;/li&gt;
  &lt;li&gt;set : 순서가 없는 데이터의 집합이며 중복을 허용하지 않습니다. 키 == 밸류&lt;/li&gt;
  &lt;li&gt;map : 키밸류스토어 구조로 이루어진 데이터의 집합이며 키값은 중복 허용하지 않으며 밸류는 중복을 허용합니다.&lt;/li&gt;
  &lt;li&gt;list,set,map은 데이터를 저장하기위한 자료구조 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;listsetmap-어떤-인터페이스를-구현하고-있나요&quot;&gt;list,set,map 어떤 인터페이스를 구현하고 있나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;list,set은 컬렉션 인터페이스를 구현하고 있고, map은 k,v구조로 이루어진 인터페이스 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;foreach를-사용할수있는-자료구조는-어떠한-인터페이스를-상속받고-있나요&quot;&gt;foreach를 사용할수있는 자료구조는 어떠한 인터페이스를 상속받고 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;collection 구현체들이 foreach를 사용할수있습니다. collection은 iterable interface를 상속받고 있기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;foreach를-사용하기-위한-내부적-메소드는-무엇인가요&quot;&gt;foreach를 사용하기 위한 내부적 메소드는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;foreach는 내부적으로 itertor() 호출하여 이를 통해서 loop를 진행합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator와-iterable의-차이점은-무엇인가요&quot;&gt;iterator와 iterable의 차이점은 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;iterable은 foreach와 iterator를 갖는 인터페이스 입니다.&lt;/li&gt;
  &lt;li&gt;iterator는 collection을 지원하기 위한 인터페이스로서 collection 데이터를 읽어올때 사용된다.&lt;/li&gt;
  &lt;li&gt;차이점 : iterator를 이용하면 collection 탐색시에 요소를 삭제하거나 다음 요소를 인덱스가 있는것처럼 활용할수있다. next,remove등의 메소드를 통해서 하지만 iterable의 foreach를 사용하면 collection의 요소를 삭제하거나 특정 요소를 확인할수있는 방법이없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator를-상속받으면-구현해야-하는-메서드는-무엇인가요&quot;&gt;iterator를 상속받으면 구현해야 하는 메서드는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HasNext를 구현해야합니다. (overriding) 그래야 내부적으로 다음 요소를 확인할수있으므로&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열-size변경이-가능한가요&quot;&gt;배열 size변경이 가능한가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 사이즈 변경은 불가능 합니다. 힙영역에 사이즈만큼 주소값을 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열에-10개의-데이터가-있는데-5개의-배열로-줄이고-싶을떄-어떻게-해야하는가&quot;&gt;배열에 10개의 데이터가 있는데 5개의 배열로 줄이고 싶을떄 어떻게 해야하는가.?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 사이즈를 변경하기 위해서는 재할당하고, 배열의 값을 복사해야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;size가-변경될-경우에는-어떠한-자료구조를-사용하는것이-좋을까요&quot;&gt;Size가 변경될 경우에는 어떠한 자료구조를 사용하는것이 좋을까요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터가 많을때는 링크드리스트가 좋으며 , 적을때는 배열이 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;가변-자료구조는-어떤게-있나요&quot;&gt;가변 자료구조는 어떤게 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링크드리스트, 트리 등 Node의 개념을 사용하는 자료구조가 가변적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입과-none-gerneric-타입의-차이를-설명해주세요&quot;&gt;gerneric타입과 none gerneric 타입의 차이를 설명해주세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;gerneric : 데이터 타입을 제한하지 않고 사용할 수 있게 해주는 매개변수화된 타입입니다.&lt;/li&gt;
  &lt;li&gt;none gerneric : 제너릭을 사용하지 않고 모든 순간 타입을 확인하며 형변환 해야하는 타입&lt;/li&gt;
  &lt;li&gt;차이점 : 코드의 재사용성에 차이가 존재하며, 에러 검출시 차이점이 존재합니다. 제너릭은 컴파일 시점에 넌제너릭은 런타임 시점에 에러를 검출하는 차이점이 존재합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입-종류는-무엇이-있나요&quot;&gt;gerneric타입 종류는 무엇이 있나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수화 타입&lt;/li&gt;
  &lt;li&gt;언바운드 와일드카드 타입&lt;/li&gt;
  &lt;li&gt;바운드 타입 매개변수&lt;/li&gt;
  &lt;li&gt;재귀적 타입 바운드&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gerneric타입--장점은-무엇인가요---object사용하면-되는데&quot;&gt;gerneric타입  장점은 무엇인가요  ? object사용하면 되는데?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;제너릭으로 설정하면 자바가 타입을 확인해 주어 코드상으로 더욱 편한 이점이 존재합니다. 이를 통해 코드의 안전성을 줄수있습니다. object를 사용하면 가능하지만 형변환 할때마다 오버헤드가 존재하므로 제너릭 사용시 이러한 오버헤드를 줄일수있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist와-linkedlist의-차이를-설명하세요&quot;&gt;ArrayList와 linkedList의 차이를 설명하세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;동적으로 사이즈를 할당할수있냐 없냐의 차이입니다. arraylist는 동적으로 배열을 할당할수없습니다. 배열의 사이즈를 늘리고 복사하는 방법인 반면에 linkedList는 인덱스 기반이 아닌 sequence 기반으로 동적하기 때문에 데이터의 추가삭제를 위한 동적 사이즈를 늘리를 것에 효율적입니다. 이는 메모리상에서도 동일합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터를-순차적으로-찾을때-가장-적합한-것은-어느것인가요&quot;&gt;데이터를 순차적으로 찾을때 가장 적합한 것은 어느것인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;순차적으로 찾을때는 ArrayList를 사용하는것이 좋습니다. 왜냐하면 인덱스를 기반으로 빠른 탐색이 가능하기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터를-빈번하게-삭제하거나-추가할때-사용하는-자료구조는-어떤것인가요--왜-&quot;&gt;데이터를 빈번하게 삭제하거나 추가할때 사용하는 자료구조는 어떤것인가요?  왜 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;linkedList 자료구조를 사용해야 합니다. arraylist는 내부적으로 삭제 삽입시 사이즈를 고려해여 데이터를 shit해야합니다. 하지만 linkedList는 지정된 요소의 주소에 주소값을 연결하기 때문에 linkedList가 효율적입니다. 손쉽게 데이터를 추가/삭제 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist에서-데이터를-중간에-삭제하면-어떻게-동작하나요&quot;&gt;ArrayList에서 데이터를 중간에 삭제하면 어떻게 동작하나요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 인덱스를 찾고 그값을 삭제하면 뒤에있는 데이터들을 삭제한곳부터 한칸식 shift합니다. 중간데이터 하나를 삭제하면 뒤의 모든 데이터를 옮겨야합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylist와-list중에-검색속도가-빠른것은-무엇이고-느린것은-무엇인가&quot;&gt;Arraylist와 list중에 검색속도가 빠른것은 무엇이고 느린것은 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;검색속도가 빠른것은 arrayList입니다. 이는 인덱스를 기반으로 O(1)복잡도로 데이터를 찾을수있습니다.&lt;/li&gt;
  &lt;li&gt;느린것은 linkList이고 리스트는 인덱스 기반이 아니라 Node를 통해서 값인지 아닌지를 확인해야 하기때문에 O(n) 시간복잡도가 걸립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linkedlist의-내부적인-동작방법&quot;&gt;linkedlist의 내부적인 동작방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주소를 가르키는 node와 값을 넣는 data로 구성되어있습니다. 데이터가 추가 삭제 되면 node에 새로운 데이터와 연결하거나 삭제합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;map을-사용해야하는경우는-무엇인가요&quot;&gt;map을 사용해야하는경우는 무엇인가요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 데이터를 빠르게 검색하고 싶을때 사용합니다. 데이터를 검색할시 key를 이용해서 검색하면 O(1)에 검색 가능하기 때문입니다. map의 key는 중복되지 않기 떄문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시테이블과-해시맵의-차이는&quot;&gt;해시테이블과 해시맵의 차이는&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공통점 : k,v 구조이며 k 는 중복이 없다. v는 중복가능하다.&lt;/li&gt;
  &lt;li&gt;차이점 :
    &lt;ul&gt;
      &lt;li&gt;hashtable은 동기화 되기 떄문에 thread-safe 하지만 HashMap은 동기화 되지 않기 때문에 thread-safe 하지 않는다. 그렇기에 멀티 쓰레드 환경이 아니아면 Hashtable은 HashMap보다 성능이 떨어집니다.&lt;/li&gt;
      &lt;li&gt;HashTable은 key에 null을 허용하지 않습니다. 하지만 HashMap은 key에 null을 허용합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택의-차이를-설명해주세요&quot;&gt;큐와 스택의 차이를 설명해주세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 선입선출이고, 스택은 후입선출입니다. input에 대비하여 output이 다른 차이가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택의-사용-예를-하나씩-설명하라&quot;&gt;큐와 스택의 사용 예를 하나씩 설명하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 스케줄링 관리시스템, 배치 시스템등&lt;/li&gt;
  &lt;li&gt;스택은 웹/앱 브라우저 방문기록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택은-내부적으로-어떤-자료구조를-사용했나요&quot;&gt;큐와 스택은 내부적으로 어떤 자료구조를 사용했나요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐는 리스트, 스택은 백터를 사용하였는데 결국 내부적으로 콜렉션을 사용하였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;큐와-스택을-직접-구현할때-사용해야하는-자료구조는&quot;&gt;큐와 스택을 직접 구현할때 사용해야하는 자료구조는?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스택은 배열을 통해서 큐는 링크드리스트를 통해서 구현하는게 좋습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;우선순위-큐에-대해서-말하라&quot;&gt;우선순위 큐에 대해서 말하라&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;큐에서 내부적으로 정렬이 되어있는 경우를 뜻합니다. 정렬은 최소힙과 최대힙을 통해서 구현되어있습니다.&lt;/li&gt;
  &lt;li&gt;힙 : 이진트리를 이용하여 root부터 leaf까지 특정 차순으로 정렬되어있는 구조를 힙이라고 합니다. 오름차순된 힙은 최소힙이며 내림차순된 힙은 최대힙입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트리에-대해서-설명하라--다른-자료구조들과-차이점은-무엇인가-&quot;&gt;트리에 대해서 설명하라 ? 다른 자료구조들과 차이점은 무엇인가 ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;트리는 비선형 자료구조입니다.&lt;/li&gt;
  &lt;li&gt;계층구조를 나타내는 자료구조이며 노드 N인 트리는 n-1 간선을 갖는 특징이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어떤경우에-사용하는것이-좋은가&quot;&gt;어떤경우에 사용하는것이 좋은가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;계층화된 데이터 표현할때 사용합니다. 목차, 디렉토리, 카테고리 등&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이진트리를-설명하세요&quot;&gt;이진트리를 설명하세요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;노드의 자식의 수가 2개로 이루어지는 트리를 이진트리라고 합니다. 이진트리는 검색,정렬 할 때 효율적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비트리는-내부적인-노드를-어떤것을-가지고-있는가&quot;&gt;비트리는 내부적인 노드를 어떤것을 가지고 있는가?&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리-에-대해서-설명해주세요&quot;&gt;이진검색트리 에 대해서 설명해주세요&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리와-비트리의-내부적인-차이는-&quot;&gt;이진검색트리와 비트리의 내부적인 차이는 ?&lt;/h2&gt;
&lt;h2 id=&quot;이진검색트리에서-가장-느린-검색이-되는-경우&quot;&gt;이진검색트리에서 가장 느린 검색이 되는 경우&lt;/h2&gt;

&lt;h2 id=&quot;동기비동기-란-무엇인가&quot;&gt;동기/비동기 란 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;critical section(임계영역)에서 반환값을 기대할수 있는 경우를 동기화 라고 표현하고 반대의 경우를 비동기하고 표현합니다.&lt;/li&gt;
  &lt;li&gt;critical section은 독립성을 유지 해야합니다.&lt;/li&gt;
  &lt;li&gt;실행중인 critical section이 존재할때 종료후에 반환값을 기대하면 동기화된것이고 critical section 실행중에 값의 변화가 진행되면(공유) 비동기화라고 표현합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;동기화를-지원하는-자료구조는&quot;&gt;동기화를 지원하는 자료구조는?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;백터,해쉬테이블, synchronizedList(),synchronizedSet(),synchronizedMap() 을 제공한다&lt;/li&gt;
  &lt;li&gt;현재는 ConcurrentHashMap, ConcurrentLinkedListQueue 의 성능이 더 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;동기화를-지원하는-자료구조는-왜--언제-필요할까요&quot;&gt;동기화를 지원하는 자료구조는 왜 , 언제 필요할까요?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;멀티쓰레드 환경에서 즉 쓰레드간 데이터를 공유해야할때 동기화된 (스레드세잎)한 자료구조가 필요합니다. 쓰레드끼리 공유데이터 접근시에 쓰레드세잎하지 않으면 데이터의 값이 예상치 못하게 변경되기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring&quot;&gt;Spring&lt;/h2&gt;
&lt;p&gt;자바진형 프레임워크로 자바 베이직 라이브러리와 웹,앱을 위한 다양한 라이브러리가 제공됩니다. 또한 jdbc를 인터페이스로 다양한 DB를 ORM할수있도록 JPA,security 등 하위 프레임워크를 내포하고있어 개발자의 생산성을 돕습니다.&lt;/p&gt;

&lt;p&gt;그리고 DI,IoC등의 개념을 통해서 객체지향적 프로그램 지향하도록 설계된 프레임워크가 spring입니다.&lt;/p&gt;

&lt;h2 id=&quot;di&quot;&gt;DI&lt;/h2&gt;
&lt;p&gt;dependency Injection 으로 객체지향 원리중 DIP에 해당합니다. 객체내부에 동적으로 객체를 생성하는것이 아닌 객체의 인스턴스를 설정하고 생성자,set,필드 통해서 객체를 생성하는 방식입니다.&lt;/p&gt;

&lt;h2 id=&quot;ioc&quot;&gt;IoC&lt;/h2&gt;
&lt;p&gt;spring에서 Bean을 관리해주는 컨테이너 입니다. IoC에서 빈을 관리하고 애노테이션 스캔을 통해서 DI를 하게 되는데 의존객체가 주체가아닌 IoC 컨테이너에서 빈을 관리하기 때문에 IoC라는 명칭이 붙게 되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;aop&quot;&gt;AoP&lt;/h2&gt;
&lt;p&gt;중복된 코드를 aspect를 이용해서 모듈화 할수있고 이를 특정 위치에 사용할수있는 방법이 AoP입니다. 
  target, advice, PointCut으로 구성되어있습니다.&lt;/p&gt;

&lt;h2 id=&quot;jpa&quot;&gt;JPA&lt;/h2&gt;
&lt;p&gt;spring의 데이터베이스 연동하는 기능이며 객체스타일로 DB를 연동할수있습니다. 또한 영속성이라는 기능을 통해서 DB의 많은 접근을 하지 않아도 되는 이점이 존재하고, DB설정을 java로 설정할수있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;
&lt;p&gt;model, view, controller 를 통해서 구성된 소프트웨어 디자인 패턴입니다. 각 계층을 통해서 명시적으로 업무를 분할 할수있는 장점이 있고 이를 통해서 업무를 분담할수있습니다. 확장성이 용이합니다. 유지보수 비용을 절감할 수 있습니다.&lt;/p&gt;

&lt;p&gt;동작과정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;disPatherServlet에서 요청이 들어옴&lt;/li&gt;
  &lt;li&gt;핸들러매핑(핸들러조회(controller)) 한다.&lt;/li&gt;
  &lt;li&gt;핸들러를 사용할수있는 어댑터가 있는지  조회한다.&lt;/li&gt;
  &lt;li&gt;핸들러 어탭터 실행&lt;/li&gt;
  &lt;li&gt;핸들러 실행(controller가 실행됨)&lt;/li&gt;
  &lt;li&gt;controller 반환값을 핸들러 어탭터에 반환하고 어댑터는 dispatcherServlet에 modelAndView 반환&lt;/li&gt;
  &lt;li&gt;viewResolver 호출&lt;/li&gt;
  &lt;li&gt;viewResolver가 view에 맞는 객체로 변환하여 dispatcherSerlver으로 반환&lt;/li&gt;
  &lt;li&gt;dispatcherSerlver view에 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;security&quot;&gt;Security&lt;/h2&gt;
&lt;p&gt;인증과 허가를 담당하는 하위 프레임워크입니다.&lt;/p&gt;

&lt;h2 id=&quot;쓰레드풀&quot;&gt;쓰레드풀&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;쓰레드풀을 요청시마다 생성할때 단점
    &lt;ol&gt;
      &lt;li&gt;스레드 교환시 컨텍스트 스위칭이 일어나 오버헤드가 발생합니다. 요청이들어올때마다 스레드를 생성하면 비용이 매우 비쌉니다. 또한 서버의 resource를 효율적으로 사용치 못합니다.&lt;/li&gt;
      &lt;li&gt;cpu,memory의 임계점을 넘는 요청이 들어오면 서버가 터질 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;쓰레드풀을 요청시마다 생성할때 장점
    &lt;ol&gt;
      &lt;li&gt;동시 요청을 수행할수있습니다.&lt;/li&gt;
      &lt;li&gt;자원을 모두 소모할수있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드풀 사용 장점
    &lt;ol&gt;
      &lt;li&gt;쓰레드풀은 이런 쓰레드를 보관 및 관리하는 기능입니다. 미리 생성 가능한 쓰레드의 최대치를 관리하며 쓰레드 대기,거절등을 수행할수있습니다. 이를통해 생성및 종료 하는 비용을 줄일수있습니다.(cpu비용절감)&lt;/li&gt;
      &lt;li&gt;쓰레드풀 최대치가 존재함으로 많은 요청이 들어와도 서버가 죽지 않고 기존 요청을 처리할수있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드풀 사용 단점
    &lt;ol&gt;
      &lt;li&gt;스레드풀의 최적사이즈를 알기 어렵습니다. 너무 많으면 서버가 죽고 너무 적으면 서버 응답지연&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssr--csr&quot;&gt;SSR &amp;amp; CSR&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSR : 서버사이드 렌더링으로 서버측에서 최종 HTML 구성하여 보내는 방법을뜻합니다.&lt;/li&gt;
  &lt;li&gt;CSR : 클라이언트 측에서 서버로 부터 받은 데이터를 가지고 클라이언트측에서 동적으로 페이지를 구성하는 방법입니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tip/2021/05/02/javaInterviewQuestion/</link>
        <guid isPermaLink="true">http://localhost:4000/tip/2021/05/02/javaInterviewQuestion/</guid>
        
        <category>interview</category>
        
        
        <category>tip</category>
        
      </item>
    
      <item>
        <title>querydsl</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-study&quot;&gt;spring study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;querydsl-설정&quot;&gt;querydsl 설정&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [build.gradle ]
  plugins{ 
  //querydsl 추가
  id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot;
  }

  //querydsl 추가 시작
  def querydslDir = &quot;$buildDir/generated/querydsl&quot;
  querydsl {
      jpa = true
      querydslSourcesDir = querydslDir
  }
  sourceSets {
      main.java.srcDir querydslDir
  }
  configurations {
      querydsl.extendsFrom compileClasspath
  }
  compileQuerydsl {
      options.annotationProcessorPath = configurations.querydsl
  }
 //querydsl 추가 끝
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;querydsl-기본문법&quot;&gt;querydsl 기본문법&lt;/h2&gt;

&lt;p&gt;querydsl 사용에 있어서 JPAQueryFactory를 DI해야한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Q파일을 가져다가 사용할수있다. Q파일의 alias를 선언하여 JPQL의 alias를 대신할수있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Test
    public void search() throws Exception {
        //given

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;)
                        .and(member.age.eq(10)))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     *
     * member.username.eq(&quot;member1&quot;) // username = 'member1'
     * member.username.ne(&quot;member1&quot;) // username != 'member1'
     * member.username.eq(&quot;member1&quot;).not() // username != 'member1'
     *
     * member.username.isNotNull() // 이름이 is not null
     *
     * member.age.in(10,20) // age in (10,20)
     * member.age.notIn(10,20) // age not in(10,20)
     * member.age.between(10,30) // between 10,30
     *
     * member.age.goe(30) //age &amp;gt;= 30
     * member.age.gt(30) // age &amp;gt; 30
     * member.age.loe(30) // age &amp;lt;= 30
     * member.age.lt(30) // agr &amp;lt; 30
     *
     * member.username.like(&quot;member%&quot;) // like
     * member.username.contains(&quot;member&quot;) // like '%member%'
     * member.username.startWith(&quot;member&quot;) // like 'member%'
     *
     */
    @Test
    public void searchAndParam(){
        List&amp;lt;Member&amp;gt; findMembers = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;),
                        member.age.eq(10))
                .fetch();

        Member findMember = findMembers.get(0);

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     * fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환
     * fetchOne() : 단건 조회
     *  - 결과가 없으면 null
     *  - 결과가 둘이상이면 com.querydsl.core.NonUniqueResultException
     * fetchFirst() : limit(1).fetchOne()
     * fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
     * fetchCount() : count 쿼리로 변경해서 count수 조회
    *
     * @throws Exception
     */
    @Test
    public void fetchResult() throws Exception{

  //        List&amp;lt;Member&amp;gt; fetch = queryFactory
  //                .select(member)
  //                .from(member)
  //                .fetch();
  //
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchOne();
  //        
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchFirst();

  //        QueryResults&amp;lt;Member&amp;gt; result = queryFactory
  //                .select(member)
  //                .from(member)
  //                .offset(0)
  //                .limit(2)
  //                .fetchResults();
  //
  //
  //        assertThat(result.getLimit()).isEqualTo(2);
  //        assertThat(result.getOffset()).isEqualTo(0);
  //        assertThat(result.getTotal()).isEqualTo(4);
  //
  //
  //        for (Member resultResult : result.getResults()) {
  //            System.out.println(&quot;resultResult = &quot; + resultResult);
  //        }

  //        long count = queryFactory
  //                .selectFrom(member)
  //                .fetchCount();


  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;정렬및집합&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Test
    public void sort() throws Exception{
        //given
        em.persist(new Member(null,100));
        em.persist(new Member(&quot;member5&quot;,100));
        em.persist(new Member(&quot;member6&quot;,100));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(100))
                .orderBy(member.age.desc(),
                        member.username.asc().nullsLast())
                .fetch();

        //when

        //then

        Member member5 = result.get(0);
        Member member6 = result.get(1);
        Member memberNull = result.get(2);

        assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;);
        assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;);
        assertThat(memberNull.getUsername()).isNull();
    }


    /**
     * 집합 함수
     * select
     *   COUNT(m),
     *   SUM(m.age),
     *   AVG(m.age),
     *   MAX(m.age),
     *   MIN(m.age)
     * from Member m
     */
    @Test
    public void aggregation() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member.count(),
                        member.age.sum(),
                        member.age.avg(),
                        member.age.min(),
                        member.age.max())
                .from(member)
                .fetch();
        //when

        //then

        Tuple tuple = result.get(0);
        assertThat(tuple.get(member.count())).isEqualTo(4);
        assertThat(tuple.get(member.age.sum())).isEqualTo(100);
        assertThat(tuple.get(member.age.avg())).isEqualTo(25);
        assertThat(tuple.get(member.age.max())).isEqualTo(40);
        assertThat(tuple.get(member.age.min())).isEqualTo(10);
    }

    /**
     * GroupBy 사용
     * 팀의 이름과 각 팀의 평균 연령을 구해라
     *
     * @throws Exception
     */
    @Test
    public void GroupByTest() throws Exception{
        //given
        em.persist(new Team(&quot;teamC&quot;));
        em.persist(new Member(&quot;member5&quot;,50,null));


        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(team.name,member.age.avg())
                .from(member)
                .join(member.team,team)
  //                .LeftJoin(member.team,team)
                .groupBy(team.name)
                .fetch();
        //when
        //then

  //        Tuple teamA = result.get(0);
  //        Tuple teamB = result.get(1);
  //
  //        assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;);
  //        assertThat(teamA.get(member.age.avg())).isEqualTo(15);
  //
  //        assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;);
  //        assertThat(teamB.get(member.age.avg())).isEqualTo(35);

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   /**
     *
     * join() : innerJoin()
     * leftJoin() : left 외부조인
     * rightJoin() : right 외부조인
     * @throws Exception
     */
    @Test
    public void join() throws Exception{
        //given
        QMember qMember = member;
        QTeam qTeam = QTeam.team;

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when

        //then
        assertThat(result)
                .extracting(&quot;username&quot;) // 결과에서 추출
                .containsExactly(&quot;member1&quot;,&quot;member2&quot;); // 포함하고 있는지확인

        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     *
     * from절에 여러 엔티티를 선택해서 세타조인 할수있다.
     * 하지만 세타조인시 외부조인 불가능하다
     *
     * @throws Exception
     */
    @Test
    public void theta_join() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member,team)
                .where(member.username.eq(team.name))
                .fetch();

        //when
        //then
        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     * 외부조인하는 방법
     * on절을 활용해 조인 대상을 필터링 할때, 외부조인이 아니라 내부조인을 사용하면,
     * where절에서 필터링 하는것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링
     * 을 사용할때, 내부조인이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만
     * 이 기능을 사용하자.
     *
     * @throws Exception
     */
    @Test
    public void join_on_fittering() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
 //                .leftJoin(member.team,team).on(team.name.eq(&quot;teamA&quot;))
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when
        //then

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * 연관관계없는 엔티티 외부조인
     * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
     * JPQL: select m,t from member m left join team t on m.username = t.name
     * SQL : select m.*,t.* from Member m left join  Team t on m.username = t.name
     *
     * 서로 연관관계가 없으니 leftJoin()에서 하나의 엔티티만 들어간다.
     */

    @Test
    public void join_on_no_relation() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
                .leftJoin(team).on(member.username.eq(team.name))
                .fetch();
        //when

        //then
        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * fetch join 적용
     *  join(member.team, team).fetchjoin()
     *  위와같은 방식으로 사용하면된다.
     *  join()에 엔티티를 잘 넣어줘야한다. 그래서 같은 영속성 컨텍스트에서 id를 가져옴
     *
     */

    @PersistenceUnit
    EntityManagerFactory emf;

    @Test
    public void fetch_NO_join_test() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();
        //when
        //then

        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).as(&quot;페치조인 미적용&quot;).isFalse();
    }

    @Test
    public void fetchJoin() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team).fetchJoin()
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        //when
        //then
        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).isTrue();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;서브쿼리,concat&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
     * 서브쿼리
     * com.querydsl.jpa.JPAExpressions 사용한다.
     *
     * 서브쿼리는 select, where절에만 사용가능하다.
     *
     *
     * 예제 1) 나이가 가장 많은 회원 조회
     * 예제 2) 나이가 평균 나이 이상인 회원
     * 예제 3) 서브쿼리 여러건 처리, in 사용
     * 예제 4) select절에 서브쿼리 사용
     *
     * JPAExpressions &amp;lt;&amp;lt; static import 가능
     *
     * from절에 서브쿼리 안된다. JPA에서는 이를 해결하는 방안은
     * 1. 서브쿼리를 join으로 변경한다.(가능한 상황도 있고,불가능한 상황도 있다.
     * 2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
     * 3. nativeSQL을 사용한다.
     *
     */
    @Test
    public void subQuery() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);

 //        예제1
        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(
                        select(memberSub.age.max())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result).extracting(&quot;age&quot;)
                .containsExactly(40);
    }

    @Test
    public void subQuery2() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.goe(
                        select(memberSub.age.avg())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(30,40);
    }

    @Test
    public void subQuery3() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.in(
                            select(memberSub.age)
                                .from(memberSub)
                                .where(memberSub.age.gt(10))
                ))
                .fetch();

        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(20,30,40);

        for (Member member1 : result2) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    @Test
    public void subQuery4() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Tuple&amp;gt; result2 = queryFactory
                .select(member.username,
                        select(memberSub.age.avg())
                                .from(memberSub))
                .from(member)
                .fetch();


        for (Tuple tuple : result2) {
  //            System.out.println(&quot;tuple = &quot; + tuple.get(member.username));
  //            System.out.println(&quot;tuple = &quot; + tuple.get(select(memberSub.age.avg())
  //                                .from(memberSub)));
  //            System.out.println(&quot;tuple = &quot; + tuple);

        }
    }

    @Test
    public void concat() throws Exception{
        //given

        Tuple tuple1 = queryFactory
                .select(member.username,Expressions.constant(&quot;A&quot;))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;tuple1 = &quot; + tuple1);



        String result2 = queryFactory
                .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue()))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;result2 = &quot; + result2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 09 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/09/QueryDsl-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/09/QueryDsl-2/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>querydsl</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-study&quot;&gt;spring study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;querydsl-설정&quot;&gt;querydsl 설정&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [build.gradle ]
  plugins{ 
  //querydsl 추가
  id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot;
  }

  //querydsl 추가 시작
  def querydslDir = &quot;$buildDir/generated/querydsl&quot;
  querydsl {
      jpa = true
      querydslSourcesDir = querydslDir
  }
  sourceSets {
      main.java.srcDir querydslDir
  }
  configurations {
      querydsl.extendsFrom compileClasspath
  }
  compileQuerydsl {
      options.annotationProcessorPath = configurations.querydsl
  }
 //querydsl 추가 끝
  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;querydsl-기본문법&quot;&gt;querydsl 기본문법&lt;/h2&gt;

&lt;p&gt;querydsl 사용에 있어서 JPAQueryFactory를 DI해야한다.&lt;/p&gt;

&lt;p&gt;이를 통해 Q파일을 가져다가 사용할수있다. Q파일의 alias를 선언하여 JPQL의 alias를 대신할수있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조회&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Test
    public void search() throws Exception {
        //given

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;)
                        .and(member.age.eq(10)))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     *
     * member.username.eq(&quot;member1&quot;) // username = 'member1'
     * member.username.ne(&quot;member1&quot;) // username != 'member1'
     * member.username.eq(&quot;member1&quot;).not() // username != 'member1'
     *
     * member.username.isNotNull() // 이름이 is not null
     *
     * member.age.in(10,20) // age in (10,20)
     * member.age.notIn(10,20) // age not in(10,20)
     * member.age.between(10,30) // between 10,30
     *
     * member.age.goe(30) //age &amp;gt;= 30
     * member.age.gt(30) // age &amp;gt; 30
     * member.age.loe(30) // age &amp;lt;= 30
     * member.age.lt(30) // agr &amp;lt; 30
     *
     * member.username.like(&quot;member%&quot;) // like
     * member.username.contains(&quot;member&quot;) // like '%member%'
     * member.username.startWith(&quot;member&quot;) // like 'member%'
     *
     */
    @Test
    public void searchAndParam(){
        List&amp;lt;Member&amp;gt; findMembers = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;),
                        member.age.eq(10))
                .fetch();

        Member findMember = findMembers.get(0);

        assertThat(findMember.getUsername()).isEqualTo(&quot;member1&quot;);
    }

    /**
     * fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환
     * fetchOne() : 단건 조회
     *  - 결과가 없으면 null
     *  - 결과가 둘이상이면 com.querydsl.core.NonUniqueResultException
     * fetchFirst() : limit(1).fetchOne()
     * fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
     * fetchCount() : count 쿼리로 변경해서 count수 조회
    *
     * @throws Exception
     */
    @Test
    public void fetchResult() throws Exception{

  //        List&amp;lt;Member&amp;gt; fetch = queryFactory
  //                .select(member)
  //                .from(member)
  //                .fetch();
  //
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchOne();
  //        
  //        Member member = queryFactory
  //                .select(QMember.member)
  //                .from(QMember.member)
  //                .fetchFirst();

  //        QueryResults&amp;lt;Member&amp;gt; result = queryFactory
  //                .select(member)
  //                .from(member)
  //                .offset(0)
  //                .limit(2)
  //                .fetchResults();
  //
  //
  //        assertThat(result.getLimit()).isEqualTo(2);
  //        assertThat(result.getOffset()).isEqualTo(0);
  //        assertThat(result.getTotal()).isEqualTo(4);
  //
  //
  //        for (Member resultResult : result.getResults()) {
  //            System.out.println(&quot;resultResult = &quot; + resultResult);
  //        }

  //        long count = queryFactory
  //                .selectFrom(member)
  //                .fetchCount();


  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;정렬및집합&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Test
    public void sort() throws Exception{
        //given
        em.persist(new Member(null,100));
        em.persist(new Member(&quot;member5&quot;,100));
        em.persist(new Member(&quot;member6&quot;,100));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(100))
                .orderBy(member.age.desc(),
                        member.username.asc().nullsLast())
                .fetch();

        //when

        //then

        Member member5 = result.get(0);
        Member member6 = result.get(1);
        Member memberNull = result.get(2);

        assertThat(member5.getUsername()).isEqualTo(&quot;member5&quot;);
        assertThat(member6.getUsername()).isEqualTo(&quot;member6&quot;);
        assertThat(memberNull.getUsername()).isNull();
    }


    /**
     * 집합 함수
     * select
     *   COUNT(m),
     *   SUM(m.age),
     *   AVG(m.age),
     *   MAX(m.age),
     *   MIN(m.age)
     * from Member m
     */
    @Test
    public void aggregation() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member.count(),
                        member.age.sum(),
                        member.age.avg(),
                        member.age.min(),
                        member.age.max())
                .from(member)
                .fetch();
        //when

        //then

        Tuple tuple = result.get(0);
        assertThat(tuple.get(member.count())).isEqualTo(4);
        assertThat(tuple.get(member.age.sum())).isEqualTo(100);
        assertThat(tuple.get(member.age.avg())).isEqualTo(25);
        assertThat(tuple.get(member.age.max())).isEqualTo(40);
        assertThat(tuple.get(member.age.min())).isEqualTo(10);
    }

    /**
     * GroupBy 사용
     * 팀의 이름과 각 팀의 평균 연령을 구해라
     *
     * @throws Exception
     */
    @Test
    public void GroupByTest() throws Exception{
        //given
        em.persist(new Team(&quot;teamC&quot;));
        em.persist(new Member(&quot;member5&quot;,50,null));


        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(team.name,member.age.avg())
                .from(member)
                .join(member.team,team)
  //                .LeftJoin(member.team,team)
                .groupBy(team.name)
                .fetch();
        //when
        //then

  //        Tuple teamA = result.get(0);
  //        Tuple teamB = result.get(1);
  //
  //        assertThat(teamA.get(team.name)).isEqualTo(&quot;teamA&quot;);
  //        assertThat(teamA.get(member.age.avg())).isEqualTo(15);
  //
  //        assertThat(teamB.get(team.name)).isEqualTo(&quot;teamB&quot;);
  //        assertThat(teamB.get(member.age.avg())).isEqualTo(35);

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   /**
     *
     * join() : innerJoin()
     * leftJoin() : left 외부조인
     * rightJoin() : right 외부조인
     * @throws Exception
     */
    @Test
    public void join() throws Exception{
        //given
        QMember qMember = member;
        QTeam qTeam = QTeam.team;

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when

        //then
        assertThat(result)
                .extracting(&quot;username&quot;) // 결과에서 추출
                .containsExactly(&quot;member1&quot;,&quot;member2&quot;); // 포함하고 있는지확인

        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     *
     * from절에 여러 엔티티를 선택해서 세타조인 할수있다.
     * 하지만 세타조인시 외부조인 불가능하다
     *
     * @throws Exception
     */
    @Test
    public void theta_join() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member,team)
                .where(member.username.eq(team.name))
                .fetch();

        //when
        //then
        for (Member member1 : result) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    /**
     * 외부조인하는 방법
     * on절을 활용해 조인 대상을 필터링 할때, 외부조인이 아니라 내부조인을 사용하면,
     * where절에서 필터링 하는것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링
     * 을 사용할때, 내부조인이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만
     * 이 기능을 사용하자.
     *
     * @throws Exception
     */
    @Test
    public void join_on_fittering() throws Exception{
        //given
        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
 //                .leftJoin(member.team,team).on(team.name.eq(&quot;teamA&quot;))
                .join(member.team,team)
                .where(team.name.eq(&quot;teamA&quot;))
                .fetch();
        //when
        //then

        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * 연관관계없는 엔티티 외부조인
     * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
     * JPQL: select m,t from member m left join team t on m.username = t.name
     * SQL : select m.*,t.* from Member m left join  Team t on m.username = t.name
     *
     * 서로 연관관계가 없으니 leftJoin()에서 하나의 엔티티만 들어간다.
     */

    @Test
    public void join_on_no_relation() throws Exception{
        //given
        em.persist(new Member(&quot;teamA&quot;));
        em.persist(new Member(&quot;teamB&quot;));

        List&amp;lt;Tuple&amp;gt; result = queryFactory
                .select(member,team)
                .from(member)
                .leftJoin(team).on(member.username.eq(team.name))
                .fetch();
        //when

        //then
        for (Tuple tuple : result) {
            System.out.println(&quot;tuple = &quot; + tuple);
        }
    }

    /**
     *
     * fetch join 적용
     *  join(member.team, team).fetchjoin()
     *  위와같은 방식으로 사용하면된다.
     *  join()에 엔티티를 잘 넣어줘야한다. 그래서 같은 영속성 컨텍스트에서 id를 가져옴
     *
     */

    @PersistenceUnit
    EntityManagerFactory emf;

    @Test
    public void fetch_NO_join_test() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();
        //when
        //then

        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).as(&quot;페치조인 미적용&quot;).isFalse();
    }

    @Test
    public void fetchJoin() throws Exception{
        //given
        em.flush();
        em.clear();

        Member findMember = queryFactory
                .select(member)
                .from(member)
                .join(member.team,team).fetchJoin()
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        //when
        //then
        boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());
        assertThat(loaded).isTrue();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;서브쿼리,concat&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
     * 서브쿼리
     * com.querydsl.jpa.JPAExpressions 사용한다.
     *
     * 서브쿼리는 select, where절에만 사용가능하다.
     *
     *
     * 예제 1) 나이가 가장 많은 회원 조회
     * 예제 2) 나이가 평균 나이 이상인 회원
     * 예제 3) 서브쿼리 여러건 처리, in 사용
     * 예제 4) select절에 서브쿼리 사용
     *
     * JPAExpressions &amp;lt;&amp;lt; static import 가능
     *
     * from절에 서브쿼리 안된다. JPA에서는 이를 해결하는 방안은
     * 1. 서브쿼리를 join으로 변경한다.(가능한 상황도 있고,불가능한 상황도 있다.
     * 2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
     * 3. nativeSQL을 사용한다.
     *
     */
    @Test
    public void subQuery() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);

 //        예제1
        List&amp;lt;Member&amp;gt; result = queryFactory
                .select(member)
                .from(member)
                .where(member.age.eq(
                        select(memberSub.age.max())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result).extracting(&quot;age&quot;)
                .containsExactly(40);
    }

    @Test
    public void subQuery2() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.goe(
                        select(memberSub.age.avg())
                                .from(memberSub)
                ))
                .fetch();
        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(30,40);
    }

    @Test
    public void subQuery3() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Member&amp;gt; result2 = queryFactory
                .select(member)
                .from(member)
                .where(member.age.in(
                            select(memberSub.age)
                                .from(memberSub)
                                .where(memberSub.age.gt(10))
                ))
                .fetch();

        assertThat(result2).extracting(&quot;age&quot;)
                .containsExactly(20,30,40);

        for (Member member1 : result2) {
            System.out.println(&quot;member1 = &quot; + member1);
        }
    }

    @Test
    public void subQuery4() throws Exception{
        //given
        QMember memberSub = new QMember(&quot;memberSub&quot;);


        List&amp;lt;Tuple&amp;gt; result2 = queryFactory
                .select(member.username,
                        select(memberSub.age.avg())
                                .from(memberSub))
                .from(member)
                .fetch();


        for (Tuple tuple : result2) {
  //            System.out.println(&quot;tuple = &quot; + tuple.get(member.username));
  //            System.out.println(&quot;tuple = &quot; + tuple.get(select(memberSub.age.avg())
  //                                .from(memberSub)));
  //            System.out.println(&quot;tuple = &quot; + tuple);

        }
    }

    @Test
    public void concat() throws Exception{
        //given

        Tuple tuple1 = queryFactory
                .select(member.username,Expressions.constant(&quot;A&quot;))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;tuple1 = &quot; + tuple1);



        String result2 = queryFactory
                .select(member.username.concat(&quot;_&quot;).concat(member.age.stringValue()))
                .from(member)
                .where(member.username.eq(&quot;member1&quot;))
                .fetchOne();

        System.out.println(&quot;result2 = &quot; + result2);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 08 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/08/QueryDsl-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/08/QueryDsl-1/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-5</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-jpa-study&quot;&gt;spring jpa study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;스프링-데이터-jpa-분석&quot;&gt;스프링 데이터 JPA 분석&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 데이터 JPA가 제공하는 인터페이스의 구현체&lt;/li&gt;
  &lt;li&gt;org.springframework.data.jpa.repository.support.SimpleJpaRepository&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Repository 적용 : JPA 예외를 스프링이 추상화한 예외로 변환
@Transactional 트랜잭션 적용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JPA의 모든 변경은 트랜잭션 안에서 동작&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA는 변경(등록,수정,삭제) 메서드를 트랜잭션 처리&lt;/li&gt;
  &lt;li&gt;서비스 계층에서 트랜잭션을 시작하지 않으면 리파지토리에서 트랜잭션 시작&lt;/li&gt;
  &lt;li&gt;그래서 스프링 데이터 JPA를 사용할 때 트랜잭션이 없어도 데이터 등록, 변경이 가능했음(사실은 트랜잭션이 리포지토리 계층에 걸려있는것임)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@Transactional() 에 관한 자세한 내용은 JPA책 15.4.2 읽기 전용 쿼리 참조&lt;/p&gt;

&lt;h2 id=&quot;persistable-구현&quot;&gt;Persistable 구현&lt;/h2&gt;

&lt;p&gt;&lt;mark&gt;JPA 식별자 생성 전략이 @GenerateValue면 save() 호출 시점에 식별자가 없으므로 새로운 엔티티로 인식해서 정상 동작한다. 그런데 JPA식별자 생성 전략이 @Id만 사용해서 직접 할당이면 이미 식별작ㅂㅅ이 있는 상태로 save()를 호출한다. 따라서 이 경우 merge()가 호출된다.   
  merge()는 우선 DB를 호출해서 값을 확인하고, DB에 값이 없으면 새로운 엔티티로 인지하므로 매우 비효율 적이다. 따라서 Persistable를 사용해서 새로운 엔티티 확인 여부를 직접 구현하는게 효과적이다.   
  참고로 등록시간(@CreateDate)을 조합해서 사용하면 이 필드로 새로운 엔티티여부를 편리하게 확인할 수 있다.&lt;/mark&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  package study.datajpa.entity;
    import lombok.AccessLevel;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.CreatedDate;
    import org.springframework.data.domain.Persistable;
    import org.springframework.data.jpa.domain.support.AuditingEntityListener;
    import javax.persistence.Entity;
    import javax.persistence.EntityListeners;
    import javax.persistence.Id;
    import java.time.LocalDateTime;
             
   @Entity
  @EntityListeners(AuditingEntityListener.class)
  @NoArgsConstructor(access = AccessLevel.PROTECTED)
  public class Item implements Persistable&amp;lt;String&amp;gt; {
      @Id
      private String id;
      @CreatedDate
      private LocalDateTime createdDate;
      public Item(String id) {
          this.id = id;
  }
      @Override
      public String getId() {
  return id; }
      @Override
      public boolean isNew() {
          return createdDate == null;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;나머지-기능&quot;&gt;나머지 기능&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Specifications(명세)&lt;/li&gt;
  &lt;li&gt;Query by Example&lt;/li&gt;
  &lt;li&gt;Projections&lt;/li&gt;
  &lt;li&gt;네이트브 쿼리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 4가지 나머지 기능은 Querydsl을 사용하면 더 호율적이다.&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-5/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-4</title>
        <description>&lt;blockquote&gt;
  &lt;h2 id=&quot;spring-jpa-study&quot;&gt;spring jpa study&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;사용자-정의-리포지토리-구현&quot;&gt;사용자 정의 리포지토리 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 데이터 JPA 리포지토리는 인터페잇만 정의하고 구현체는 스프링이 자동생성&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA가 제공하는 인터페이스를 직접 구현하면 구현해야 하는 기능이 너무 많음&lt;/li&gt;
  &lt;li&gt;다양한 이유로 인터페이스의 메소드를 직접 구현하고 싶다면?
    &lt;ul&gt;
      &lt;li&gt;JPA직접사용(EntityManager)&lt;/li&gt;
      &lt;li&gt;spring JDBC Template 사용&lt;/li&gt;
      &lt;li&gt;MyBatis 사용&lt;/li&gt;
      &lt;li&gt;DB Connection 사용&lt;/li&gt;
      &lt;li&gt;Querydsl 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [사용자 정의 인터페이스]
 public interface MemberRepositoryCustom{
   List&amp;lt;Member&amp;gt; findMemberCustom();
 }

 --------------------------------------------
 [사용자 정의 인터페이스 구현 클래스]
 @RequiredArgsConstructor
 public class MemberRepositoryImpl implements MemberReposityCustom{
   private final EntityManager em;

   @Override
   public List&amp;lt;Member&amp;gt; findMemberCustom(){
     returm em.createQuery(&quot;select m from Member m&quot;)
          .getResultList();
   }
 }

 --------------------------------------------
 [사용자 정의 인터페이스 상속]
 public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; MemberRepositoryCustom{

 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;사용자 정의 구현 클래스&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;규칙 : 리포지토리 인터페이스 이름 + Impl&lt;/li&gt;
  &lt;li&gt;스프링 데이터 JPA가 인식해서 스프링 빈으로 등록&lt;/li&gt;
&lt;/ul&gt;

&lt;makr&gt;주의 ! 항상 사용자 정의 리포지토리가 필요한것은 아니다. 임의의 리포지토리를 만들어도 된다. MemberQueryRepository를 클래스로 생성하고 스프링빈으로 등록하여 직접 사용해도 된다. &amp;lt;/mark&amp;gt;


스프링 데이터 2.x부터는 사용자 정의 구현 클래스에 리포지토리 인터페이스 이름 + Impl을 적용하는 대신에 사용자 정의 인터페이스 명 + Impl 방식도 지원한다. 

```
@RequiredArgsConstructor
public class MemberRepositoryCustomImpl implememts MemberRepositoryCustom{
  private final EntityManager em;

  @Override
  public List&lt;Member&gt; findMemberCustom(){
    return em.createQuery(&quot;select m from Member m&quot;).getResultList();
  }
}
```


## Auditing


엔티티 생성, 변경 할때 변경한 사람과 시간을 추적 하고 싶으면?
  - 등록일
  - 수정일 
  - 등록자
  - 수정자

순수 JPA 사용

```
  [BaseEntity 생성]
  @MappedSuperclass
  @Getter
  public class JpaBaseEntity{
    
    @Column(updatable = false)
    private LocalDateTime createdDate;
    private LocalDateTime updatedDate;

    @PrePersist
    public void prePersist(){
      LocalDateTime now = LocalDateTime.now();
      createdDate = now;
      updatedDate = now;
    }

    @PreUpdate
    public void preUpdate(){
      updatedDate = LocalDateTime.now();
    }
  }
  ---------------------------------------------

  [entity들 baseEntity 상속받음]

  public Member extends JpaBaseEntity{}

  --------------------------------------------

  [test code]
  public void JpaEventBaseEntity() throws Exception {
  //given
      Member member = new Member(&quot;member1&quot;);
      memberRepository.save(member); //@PrePersist
      Thread.sleep(100);
      member.setUsername(&quot;member2&quot;);
      em.flush(); //@PreUpdate
      em.clear();
  //when
      Member findMember = memberRepository.findById(member.getId()).get();
  //then
      System.out.println(&quot;findMember.createdDate = &quot; +
  findMember.getCreatedDate());
      System.out.println(&quot;findMember.updatedDate = &quot; +
  findMember.getUpdatedDate());
  }
```

#### 스프링 데이터 JPA 사용 

스프링 데이터 JPA 사용에 있어서 설정이 필요하다. 

@EnableJpaAuditing &amp;gt;&amp;gt; 스프링 부트 설정 클래스에 적용해야함
@EntityListeners(AuditingEntityListener.class) &amp;gt;&amp;gt; 엔티티에 적용

```
  [스프링 데이터 Auditing적용 - 등록일, 수정일]
  @EntityListeners(AuditingEntityListener.class)
  @MappedSuperclass
  @Getter
  public class BaseTimeEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
  }

  --------------------------------------------

  [스프링 데이터 Auditing적용 - 등록자, 수정자]
  public clas BaseEntity extends BaseTimeEntity {
  
    @CreateBy
    @Column(updatable = false)
    private String createBy;

    @LastModifiedBy
    private String lastModifiedBy;

  --------------------------------------------

  [등록자 수정자를 처리해주는 AuditorAware 스프링 빈 등록]
  @Bean
  public AuditorAware&lt;String&gt; auditorProvider(){
    return () -&amp;gt; Optional.of(UUID.randomUUID().toString());
  }

```

&lt;mark&gt;실무에서는 세션정보나 스프링 시큐리티 로그인 정보에서 ID를 받음&lt;/mark&gt;

@EntityListeners(AuditingEntityListener.class)를 생략하고 글로벌 설정하고 싶다면 orm.xml을 만들어 설정해야한다. 

## Web 확장 - 도메인 클래스 컨버터

```
  [도메인 클래스 컨버터 사용전]
  @RestController
  @RequiredArgsConstructor
  public class MemberController {
      private final MemberRepository memberRepository;
      @GetMapping(&quot;/members/{id}&quot;)
      public String findMember(@PathVariable(&quot;id&quot;) Long id) {
          Member member = memberRepository.findById(id).get();
          return member.getUsername();
      }
  }
  --------------------------------------------
  [도메인 클래스 컨버터 사용후]
  @RestController
  @RequiredArgsConstructor
  public class MemberController {
      private final MemberRepository memberRepository;
      @GetMapping(&quot;/members/{id}&quot;)
      public String findMember(@PathVariable(&quot;id&quot;) Member member) {
          return member.getUsername();
      }
  }

```

주의 : 도메인 클래스 컨버터로 엔티티를 파라미터로 받으면, 이 엔티티는 단순 조회용으로만 사용해야한다.

## web 확장  - 페이징과 정렬

스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC에서 편리하게 사용할 수 있다. 

```
  @GetMapping(&quot;/members&quot;)
    public Page&lt;Member&gt; list(Pageable pageable) {
        Page&lt;Member&gt; page = memberRepository.findAll(pageable);
        return page;
    }
```

파라미터로 Pageable을 받을수 있다. 

Pageable은 인터페이스, 실제는 org.springframework.data.domain.PageRequest 객체 생성

**요청 파라미터**
  - 예) /members?page=0&amp;amp;size=3&amp;amp;sort=id,desc&amp;amp;sort=username,desc
  - page: 현재 페이지, 0부터 시작한다.
  - size : 한 페이지에 노출할 데이터 건수
  - sort: 정렬 조건을 정의한다. 예) 정렬 속성,정렬 속성...(ASC | DESC), 정렬 방향을 변경하고 싶으면 sort 파라미터 추가 ( asc 생략 가능)

**기본 값**
  - spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/ 
  - spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈/

**개별 설정**

```
  @RequestMapping(value = &quot;/members_page&quot;, method = RequestMethod.GET)
    public String list(@PageableDefault(size = 12, sort = “username”,
      ... 
    }
```

**접두사**
  - 페이징 정보가 둘 이상이면 접두사로 구분
  - @Qualifier에 접두사명 추가 &quot;{접두사명}_xxx&quot;
  - 예제 : /members?member_page=0&amp;amp;order_page=1
```
  public String list(
      @Qualifier(&quot;member&quot;) Pageable memberPageable,
      @Qualifier(&quot;order&quot;) Pageable orderPageable, ...
  
```

**Page 내용을 DTO로 변환**
  - 엔티티를 API로 노출하면 다양한 문제가 발생한다. 그래서 엔티티를 꼭 DTO로 변환해서 반환해야한다.
  
```
  [MemberDto]
  @Data
  public class MemberDto {
      private Long id;
      private String username;
      public MemberDto(Member m) {
          this.id = m.getId();
     
           this.username = m.getUsername();
      }
}
  ------------------------------------------------------------
  [Page.map() 사용 ]
  @GetMapping(&quot;/members&quot;)
  public Page&lt;MemberDto&gt; list(Pageable pageable) {
      Page&lt;Member&gt; page = memberRepository.findAll(pageable);
      Page&lt;MemberDto&gt; pageDto = page.map(MemberDto::new);
      return pageDto; 
  }
```

&lt;mark&gt;스프링 데이터는 Page를 0부터 시작한다. 1부터 사용하여면? Pageable,Page를 파라미터와 응답값으로 사용하지 않고 직접 클래스를 만들어서 처리한다. 다른 하나의 방법도 있지만 단점이 존재하므로 사용치 않는다. (인덱스 0부터 사용햐쟈 그냥..)&lt;/mark&gt;
&lt;/MemberDto&gt;&lt;/Member&gt;&lt;/MemberDto&gt;&lt;/Member&gt;&lt;/Member&gt;&lt;/String&gt;&lt;/Member&gt;&lt;/makr&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-4/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쿼리메소드-기능&quot;&gt;쿼리메소드 기능&lt;/h2&gt;

&lt;p&gt;특정한 메소드를 작성하려면 어떻게 작성해야할까? &lt;br /&gt;JpaRepository는 인터페이스인데 새로운 메소드를 작성하려면 구현체 class를 만들면 되는것일까??&lt;br /&gt;새로운 구현체 클래스를 만들게 되면 기존에 find, findAll 등의 메소드 또한 다시 재정의해야한다. &lt;br /&gt;이는 매우 힘든일이다. (왜? 기존 메소드는 스프링이 만들어주니까!!)&lt;/p&gt;

&lt;p&gt;그렇기 때문에 우리는 쿼리메소드 기능을 이용하여서 새로운 특정 메소드를 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;순수 JPA로 만든 findByUsernameAndAgeGreaterThen()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    public List&amp;lt;Member&amp;gt; findByUsernameAndAgeGreaterThan(String username,int age) {
        return em.createQuery(&quot;select m from Member m where m.username = :username and m.age &amp;gt; :age&quot;)
                .setParameter(&quot;username&quot;,username)
                .setParameter(&quot;age&quot;,age)
                .getResultList();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;test를 돌려보면&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
  public void findByUsernameAndAgeGreaterThan() {
      Member m1 = new Member(&quot;AAA&quot;, 10);
      Member m2 = new Member(&quot;AAA&quot;, 20);
      memberJpaRepository.save(m1);
      memberJpaRepository.save(m2);
      List&amp;lt;Member&amp;gt; result =
  memberJpaRepository.findByUsernameAndAgeGreaterThan(&quot;AAA&quot;, 15);
      assertThat(result.get(0).getUsername()).isEqualTo(&quot;AAA&quot;);
      assertThat(result.get(0).getAge()).isEqualTo(20);
      assertThat(result.size()).isEqualTo(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/14a04d89bbc94c46bf2261d1bdebd519/e98effeb-6d68-4556-95db-530cbb49f499.png&quot; alt=&quot;&quot; title=&quot;SpringDataJpa - 3 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 sql이 나가는것을 알수있다. &lt;/p&gt;

&lt;p&gt;MemberRepository interface에서도 이와 같은 동일한 기능을 제공한다.&lt;br /&gt;메소드 이름을 통해서 쿼리를 작성하는 기능을 제공하는데 코드상으로는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
   List&amp;lt;Member&amp;gt; findByUsernameAndAgeGreaterThan(String username,int age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jpql로 작성한 메소드와 동일한 결과를 도출한다. &lt;/p&gt;

&lt;p&gt;메소드 이름을 통한 쿼리작성은 다음과 같은 규칙이 존재한다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조회: find…By, read…By , query…By, get…By&lt;/li&gt;
  &lt;li&gt;COUNT : count….By return ‘long’&lt;/li&gt;
  &lt;li&gt;EXISTS : exists…By return ‘boolean’&lt;/li&gt;
  &lt;li&gt;delete : delete…By return ‘long’&lt;/li&gt;
  &lt;li&gt;DISTINCT : findDistinct, findMemberDistinctBy&lt;/li&gt;
  &lt;li&gt;LIMIT : findFirst3, findFirst, findTop, findTop3&lt;br /&gt;- https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.limit-query-result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스프링 데이터 JPA 공식 사이트에서 자세히 참고 하기 바란다.&lt;br /&gt;(https://docs.spring.io/spring-data/jpa/docs/current/&lt;/p&gt;

&lt;p&gt;reference/html/#jpa.query-methods.query-creation)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;@ 메소드 이름을 통한 쿼리작성은 엔티티의 필드명과 인터페이스 메소드 명이 같아야하는점을 주의하자.&lt;/p&gt;

&lt;h2 id=&quot;jpa-namedquery&quot;&gt;JPA NamedQuery&lt;/h2&gt;

&lt;p&gt; - 실무에서 쓸일이없다. - &lt;/p&gt;

&lt;p&gt;애노테이션으로 쿼리를 등록해놓고 나중에 다시 불러다 쓸수있는 기능이다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@NameQuery(name=&quot;Member.findByUsername&quot;,
          query=&quot;select m from Member m where m.username = :username&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;장점 : 네임드 쿼리는 애플리케이션 로딩시점에 파싱하여 에러를 검증할수있음&lt;/p&gt;

&lt;h2 id=&quot;레포지터리-쿼리직접-쿼리를-정의함&quot;&gt;레포지터리 쿼리(직접 쿼리를 정의함)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
  ...

  @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)
  List&amp;lt;Member&amp;gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;장점 : 애플리케이션 로딩시점에 쿼리를 파싱하여 에러 검증할수있음(이름이 없는 네임드 쿼리라고 볼수있음)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실무에서 자주 쓰인다. -&lt;br /&gt;&lt;mark class=&quot;cdx-marker&quot;&gt;간단한 쿼리는 네임드 쿼리를 사용하고 복잡한 쿼리는 레포지터리 쿼리를 사용한다.&lt;br /&gt;동적 쿼리는 QueryDSL을 사용해라&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;query-값-dto-조회&quot;&gt;@Query, 값, Dto 조회&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
  ...

  @Query(&quot;select m from Member m where m.username = :username and m.age = :age&quot;)
  List&amp;lt;Member&amp;gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age);

  // 간단조회 
  @Query(&quot;select m.username from Member m&quot;)
  List&amp;lt;Member&amp;gt; findUsernameList();

  // dto 조회 (dto가 존재해야한다.)
  @Query(&quot;select new (멤버dto의 경로 입력 해야함)MemberDto(m.id, m.username, t.name) from Member m join m.team.t&quot;)
  List&amp;lt;MemberDto&amp;gt; findMemberDto();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;파라미터-바인딩&quot;&gt;파라미터 바인딩&lt;/h2&gt;

&lt;p&gt;위치기반과 이름기반이 존재하는데 이름기반을 무조건 써야합니다.!!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; {

  // 단건 조건
  @Query(&quot;select m from Member m where m.username = :name&quot;)
  Member findMembers(@Param(&quot;name&quot;) String username);
  
  //컬렉션 파라미터 바인딩
  @Query(&quot;selecet m from Member m where m.username in :names&quot;)
  List&amp;lt;Member&amp;gt; findByNames(@Param(&quot;names&quot;) List&amp;lt;String names);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;반환-타입&quot;&gt;반환 타입&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;List&lt;Member&gt; findByUsername(String name); // 컬렉션&lt;/Member&gt;&lt;/li&gt;
  &lt;li&gt;Member findByUsername(String name); // 단건&lt;/li&gt;
  &lt;li&gt;Optional&lt;Member&gt; findByUsername(String name); // 단건 Optional&lt;/Member&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;조회 결과가 많거나 없으면 ?&lt;/p&gt;

&lt;p&gt;결과 없음 :  빈 컬렉션 반환&lt;/p&gt;

&lt;p&gt;단건조회&lt;/p&gt;

&lt;p&gt;결과없음 : NULL반환&lt;/p&gt;

&lt;p&gt;결과가 2건 이상 : javax.persistence.NonUniqueResultException 예외 발생&lt;/p&gt;

&lt;h2 id=&quot;순수-jpa-페이징과-정렬&quot;&gt;순수 JPA 페이징과 정렬&lt;/h2&gt;

&lt;p&gt;JPA에서 페이징을 어떻게 할 것인가?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;검색조건 : 나이가 10살&lt;/li&gt;
  &lt;li&gt;정렬조건 : 이름으로 내림차순&lt;/li&gt;
  &lt;li&gt;페이징 조건 : 첫번째 페이지, 페이지당 보여줄 데이터는 3건&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public List&amp;lt;Member&amp;gt; findByPage(int age, int offset, int limit){
    return em.createQuery(&quot;select m from Member m where m.age = :age order by m.username desc&quot;)
        .setParameter(&quot;age&quot;, age)
        .setFirstResult(offet)
        .setMaxResult(limit)
        .getResultList();
  }

  public long totalCount(int age){
    returm em.createQurey(&quot;select count(m) from Member m where m.age = :age&quot;, Long.class)
        .setParameter(&quot;age&quot;, age)
        .getSingleResult();
  }


  --------------------------------------------------------
  &amp;lt;TestCode&amp;gt;

  @Test
    public void paging() throws Exception {
    //given
      memberJpaRepository.save(new Member(&quot;member1&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member2&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member3&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member4&quot;, 10));
      memberJpaRepository.save(new Member(&quot;member5&quot;, 10));
      int age = 10;
      int offset = 0;
      int limit = 3;
    //when
      List&amp;lt;Member&amp;gt; members = memberJpaRepository.findByPage(age, offset, limit);
      long totalCount = memberJpaRepository.totalCount(age);
    //페이지 계산 공식 적용...
    // totalPage = totalCount / size ...
    // 마지막 페이지 ... // 최초 페이지 ..
    //then
      assertThat(members.size()).isEqualTo(3);
      assertThat(totalCount).isEqualTo(5);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;순수 JPA로 페이징을 진행하려면 sql(JPQL)로 쿼리를 불러오고 이때 정렬과 검색 조건을 등록한다. 일반적인 쿼리를 생각한다.&lt;/p&gt;

&lt;p&gt;하지만 페이징에서는 sql의 방언을 지원하기 떄문에(JPA) offset,limit 를 통해서 정해진 규칙을 지켜야한다.&lt;/p&gt;

&lt;p&gt;그것은 setFirstResult(),setMamResult()이다.&lt;/p&gt;

&lt;p&gt;테스트코드를 봐보면 페이징만 끊어오고 페이징의 계산은 직접 구현해야함을 볼수있다.&lt;/p&gt;

&lt;h2 id=&quot;스프링-데이터-jpa-페이징과-정렬&quot;&gt;스프링 데이터 JPA 페이징과 정렬&lt;/h2&gt;

&lt;p&gt;결론적으로 말하자면 위의 순수JPA 페이징과 정렬의 구현에서 스프링이 많은걸 도움을 준다. 그래서 개발자는 실질적인 코드생성을 절약 할수있고 빠른 구현이 가능하다. 하지만 spring data가 만능은 아니니 순수JPA 또한 잘 숙지해야한다.&lt;/p&gt;

&lt;p&gt;페이징과 정렬 파라미터&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.springframework.data.domain.Sort : 정렬 기능&lt;/li&gt;
  &lt;li&gt;org.springframework.data.domain.Pageable : 페이징 기능(내부에 sort 포함)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특별한 반환 타입&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.springframework.data.domain.Page : 추가 count 쿼리 결과를 포함하는 페이징&lt;/li&gt;
  &lt;li&gt;org.springframework.data.domain.Slice : 추가 count 쿼리 없이 다음 페이지만 확인 가능(내부적으로 limit+1 조회)&lt;/li&gt;
  &lt;li&gt;List(자바컬렉션):추가 count 쿼리 없이 결과만 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;페이징과 정렬 사용 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Page&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용
 Slice&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용한함
 List&amp;lt;Member&amp;gt; findByUsername(String name, Pageable Pageable); // count 쿼리 사용안함
 List&amp;lt;Member&amp;gt; findByUsername(String name, Sort sort);

 --------------------------------
 [실행코드]

  public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;{
    Page&amp;lt;Member&amp;gt; findByAge(int age, Pageble pageable);
  }


  ----------------------------------
  [Test code]

  //페이징 조건과 정렬 조건 설정
  @Test
  public void page() throws Exception {
  //given
    memberRepository.save(new Member(&quot;member1&quot;, 10));
    memberRepository.save(new Member(&quot;member2&quot;, 10));
    memberRepository.save(new Member(&quot;member3&quot;, 10));
    memberRepository.save(new Member(&quot;member4&quot;, 10));
    memberRepository.save(new Member(&quot;member5&quot;, 10));
  //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
  &quot;username&quot;));
    Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(10, pageRequest);
  //then
    List&amp;lt;Member&amp;gt; content = page.getContent(); //조회된 데이터 
    assertThat(content.size()).isEqualTo(3); //조회된 데이터 수 
    assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수 
    assertThat(page.getNumber()).isEqualTo(0); //페이지 번호 
    assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호 
    assertThat(page.isFirst()).isTrue(); //첫번째 항목인가? 
    assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;두번째 파라미터로 받은 Pageable은 인터페이스다. 따라서 실제 사용할 때는 해당 인터페이스를 구현한 PageRequest 객체를 사용한다.&lt;/p&gt;

&lt;p&gt;PageRequest 생성자의 첫번째 파라미터에는 현재페이지, 두번째 파라미터는 조회할 데이터 수 , 추가적으로 정렬 정보또한 세번째 파라미터로 작성가능하다, 생략 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;mark&gt;페이저블 객체를 사용시에 주의할점이 존재한다.&lt;br /&gt; 예를들면 페치조인하여 데이터를 가져왔을때 계속 추가적인 페치조인의 count값을 들고 온다. 이때 count는 페치조인의 지속적이 여부는 필요없고 count를 할수있는 엔티티의 count만 한다면 최적화가 가능하다.&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;이럴때 페이저블 객체 사용하며 쿼리를 분리해낼수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Query(value = &quot;select m from Member m&quot;. 
        countQuery = &quot;select count(m.username) from Member m&quot;)
  Page&amp;lt;Member&amp;gt; findMemberAllCountBy(Pageable pageable);

  ------------------------------
  [페이지를 유지하면서 엔티티를 DTO로 변환하기] // 엔티티를 어디든 제공하면 안되므로 ... DTO 변환 이유 하시겠죠?

  Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(10,pageRequest);
  page&amp;lt;Member&amp;gt; dtopage = page.map(m -&amp;gt; new MemberDto());

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;벌크성-수정-쿼리&quot;&gt;벌크성 수정 쿼리&lt;/h2&gt;

&lt;p&gt;JPA는 변경감지(dirty check)를 이용해서 update를 날릴수있다. 하지만 모든 어트리뷰트에 값을 변경하려면 쿼리를 날려야하고 이때 벌크성 수정 쿼리를 사용한다.&lt;/p&gt;

&lt;p&gt;순수 JPA를 이용한 벌크성 수정쿼리&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public int bulkAgePlus(int age){
    int resultCount = em.createQuery(&quot;update Member m set m.age = m.age + 1 where m.age &amp;gt;= :age&quot;)
      .setParameter(&quot;age&quot;, age)
      .exexcuteUpate();

    return resultCount;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;스프링 데이터 JPA&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Modifying
  @Query(&quot;update Member m set m.age = m.age +1 where m.age &amp;gt;= :age&quot;)
  int bulkAgePlus(@Param(&quot;age&quot;) int age);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;벌크성 수정, 삭베 쿼리는 @Modifying 어노테이션을 사용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용치 않으면 다음 예외 발생&lt;/li&gt;
  &lt;li&gt;org.hibernate.hql.internal.QueryExeutionRequestException: Not Supported for DML operations&lt;/li&gt;
  &lt;li&gt;벌크성 쿼리를 실행하고 나서 영속성 컨텍스트 초기화: @Modifying(clearAutoMatically = true)
    &lt;ul&gt;
      &lt;li&gt;이 옵션 없이 회원을 findById로 다시 조회하면 영속성 컨텍스트에 과거 값이 남아서 문제가 될수있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;벌크성 쿼리의 영속성 컨텍스트 문제!! 뭔지 기억하지&lt;/p&gt;

&lt;h2 id=&quot;엔티티-그래프&quot;&gt;엔티티 그래프&lt;/h2&gt;

&lt;p&gt;연관된 엔티티들을 SQL 한번에 조회하는 방법 »  페치조인&lt;/p&gt;

&lt;h4 id=&quot;n--1-문제가-무엇이냐&quot;&gt;n + 1 문제가 무엇이냐??&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;지연로딩 사용시 연관된 엔티티를 조회하면 연관된 엔티티 조회 할때마다 조회 쿼리가 생성되어 발생된다.&lt;/li&gt;
  &lt;li&gt;A 엔티티에 연관된 B 엔티티가 100개라면 A 조회시 1번 B 조회시 100번의 쿼리가 발생하고 이를 n+1 문제이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;n--1-문제를-해결하는-방법이-무엇이냐&quot;&gt;n + 1 문제를 해결하는 방법이 무엇이냐??&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;n+1를 해결하기 위해서는 연관된 엔티티 A,B를 한번에 조회해오면 주기적인 쿼리를 날릴일 일이 없어지고 n 번의 문제가 해결된다.&lt;/li&gt;
  &lt;li&gt;JPA에서는 fetch join이라는 기능으로 이를 해결할수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;페치조인은 다음과 같이 사용된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [순수 JPA]
  @Query(&quot;select m from Member m left join fetch m.team&quot;)
  List&amp;lt;Member&amp;gt; findMemberFetchJoin();

  [스프링 데이터 JPA]
  // 공통 메서드 오버라이드
  @Override
  @EntityGraph(attributePaths = {&quot;team&quot;})
  List&amp;lt;Member&amp;gt; findAll();

  //JPQL + 엔티티 그래프
  @EntityGraph(attributePaths = {&quot;team&quot;})
  @Query(&quot;select m from Member m&quot;)
  List&amp;lt;Member&amp;gt; findMemberEntityGraph();

  //메서드 이름으로 쿼리에서 특히 편리하다.
  @EntityGraph(attributePaths = {&quot;team&quot;})
  List&amp;lt;Member&amp;gt; findByUsername(@Param(&quot;username&quot;) String username)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/07/dataJpa-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/07/dataJpa-3/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;b&gt;공통 인터페이스 및 설정&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;MemberReposity는 interface이고 사용자는 반복적인 CRUD 사용에 있어 구현체를 구현하면된다. &lt;br /&gt;하지만 구현체도한 스프링이 도와준다 &lt;br /&gt;어떻게 구현체를 만드는것일까?&lt;/p&gt;

&lt;p&gt;MemberReposity extends JpaRepository&amp;lt;Member, Long&amp;gt;을 사용할때&lt;br /&gt;인터페이스내부의 메소드를 사용할때 스프링이 프록시객체를 생성한다. 그리고 이에 맞춰서 스프링이 구현체를 작성하여 인터페이스 메소드에 주입하는 형식으로 구성되었다. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/8e82bcf2dd77404d8de2a90c6ff8de5a/ad3c6a1e-437d-415b-86c2-be32a4de4dc6.png&quot; alt=&quot;&quot; title=&quot;SpringDataJPA - 2 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;공통 인터페이스 분석&lt;/b&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JpaRepository &amp;gt;&amp;gt; PagingAndSortingRepository &amp;gt;&amp;gt; CrudRepository &amp;gt;&amp;gt; Repository 를상속받는다.&lt;/li&gt;
  &lt;li&gt;해당하는 각 인터페이스 마다 다양한 메소드를 지원한다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  공통 인터페이스 구성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/8e82bcf2dd77404d8de2a90c6ff8de5a/f809cfb6-4f6d-4c07-a785-bdd078af5e50.png&quot; alt=&quot;&quot; title=&quot;SpringDataJPA - 2 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 DB별 공통지원기능이 존재하므로 Common 기능을 제공하는 인터페이스가 따로 존재한다. &lt;/p&gt;

&lt;p&gt;주요 메서드&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.&lt;/li&gt;
  &lt;li&gt;delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntitiManager.remove() 호출&lt;/li&gt;
  &lt;li&gt;findById(ID):엔티티 하나를 조회한다. 내부에서 EntityManager.find() 호출&lt;/li&gt;
  &lt;li&gt;getOne(ID):엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference()호출&lt;/li&gt;
  &lt;li&gt;findAll() : 모든엔티티를 조회한다. 정렬, 페이징 조건을 파라미터로 제공가능&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/05/dataJpa-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/05/dataJpa-2/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>datajpa-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예제 도메인 모델과 동작확인&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/167f86083f244d2a85545359afd5492f/a60bb7d1-3df1-4501-8d01-b5cd7dbbb03f.png&quot; alt=&quot;&quot; title=&quot; SpringDataJpa - 1 image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인은 멤버와 팀이 존재한다. &lt;/p&gt;

&lt;p&gt;멤버와 팀은 일대다 관계이다.&lt;/p&gt;

&lt;p&gt;JPA를 통해서 연관관계를 설정하고 JPA매핑을 진행한다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ERD에서 테이블은 JPA의 객체와 매핑되어야한다&lt;/li&gt;
  &lt;li&gt;JPA 매핑을 위해서 연관관계 설정, 연관관계메소드, 컬럼변수, FK설정 등을 진행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Member와 Team간의 연관관계 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ManyToOne, @OneToMany를 통한 양방향관계설정&lt;/li&gt;
  &lt;li&gt;chageTeam()를 통해서 연관관계 편의 메소드 생성&lt;/li&gt;
  &lt;li&gt;fetch = FetchType.LAZY를 통해 지연로딩 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;mark class=&quot;cdx-marker&quot;&gt;지연로딩, 연관관계 편의메소드, 관계설정등의 개념은 JPA기본편 참조&lt;/mark&gt;&lt;/p&gt;

&lt;p&gt;Member Entity &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {&quot;id&quot;, &quot;username&quot;, &quot;age&quot;})
public class Member {

    @Id @GeneratedValue
    @Column(name = &quot;member_id&quot;)
    private Long id;
    private String usernaem;
    private int age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;team_id&quot;)
    private Team team;


    public Member(String username) {
        this.usernaem = username;
        this.age = 0;
    }

    public Member(String username,int age) {
        this.usernaem = username;
        this.age = age;
    }

    public Member(String usernaem, int age,Team team) {
        this.usernaem = usernaem;
        this.age = age;
        if(team != null){
            changeTeam(team);
        }
    }

    public void changeTeam(Team team){
        this.team = team;
        team.getMembers().add(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Team Entity&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {&quot;id&quot;,&quot;name&quot;})
public class Team {

    @Id @GeneratedValue
    @Column(name = &quot;team_id&quot;)
    private Long id;
    private String name;

    @OneToMany(mappedBy = &quot;team&quot;)
    List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();

    public Team(String name){
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MemberJpaRepository 직접 만들어 CRUD를 생성하였다. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Repository
public class MemberJpaRepository {

    @PersistenceContext
    private EntityManager em;

    public Member save(Member member){
        em.persist(member);
        return member;
    }

    public void delete(Member member){
        em.remove(member);
    }

    public List&amp;lt;Member&amp;gt; findAll(){
        return em.createQuery(&quot;select m from Member m&quot;,Member.class)
                .getResultList();
    }

    public Optional&amp;lt;Member&amp;gt; findById(Long id){
        Member member = em.find(Member.class,id);
        return Optional.ofNullable(member);
    }

    public long count(){
        return em.createQuery(&quot;select count(m) from Member m&quot;, Long.class)
                .getSingleResult();
    }

    public Member find(Long id){
        return em.find(Member.class,id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MemberJpaRepositoryTest&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@SpringBootTest
@Transactional
@Rollback(false)
class MemberJpaRepositoryTest {

    @Autowired
    MemberJpaRepository memberJpaRepository;

    @Test
    public void testMember() throws Exception{
        //given
        Member member = new Member(&quot;MemberA&quot;);
        Member savedMember = memberJpaRepository.save(member);
        Member findMember = memberJpaRepository.find(savedMember.getId());

        //when

        Assertions.assertThat(findMember.getId()).isEqualTo(member.getId());
        Assertions.assertThat(findMember.getUsernaem()).isEqualTo(member.getUsernaem());

        /**
         * 영속성 컨텍스트에서 1차 캐시에 의한 동일 객체임을 확인
         */
        Assertions.assertThat(findMember).isEqualTo(member);
        //then
    }

    @Test
    public void basicCRUD() {
        Member member1 = new Member(&quot;member1&quot;);
        Member member2 = new Member(&quot;member2&quot;);
        memberJpaRepository.save(member1);
        memberJpaRepository.save(member2);

        //단건 조회 검증
        Member findMember1 = memberJpaRepository.findById(member1.getId()).get();
        Member findMember2 = memberJpaRepository.findById(member2.getId()).get();
        Assertions.assertThat(findMember1).isEqualTo(member1);
        Assertions.assertThat(findMember2).isEqualTo(member2);

        //리스트 조회 검증
        List&amp;lt;Member&amp;gt; all = memberJpaRepository.findAll();
        Assertions.assertThat(all.size()).isEqualTo(2);

        //카운트 검증
        long count = memberJpaRepository.count();
        Assertions.assertThat(count).isEqualTo(2);

        //삭제 검증
        memberJpaRepository.delete(member1);
        memberJpaRepository.delete(member2);

        long deletedCount = memberJpaRepository.count();
        Assertions.assertThat(deletedCount).isEqualTo(0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;간단한 CRUD를 검증하였다. &lt;/p&gt;

&lt;p&gt;springDataJpa study를 위한 간단한 예제를 만들어보았고 앞으로 MemberRepository interface가 어떻게 설정되어있는지 그리고 interface를 분석해보려한다.&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/03/05/dataJpa-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/03/05/dataJpa-1/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-9</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;객체지향-쿼리-언어&quot;&gt;객체지향 쿼리 언어&lt;/h2&gt;

&lt;h3 id=&quot;jpql&quot;&gt;JPQL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EntityManager.find() 가장 단순한 조회 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;jpa를 사용하면 엔티티 객체를 중심으로 개발&lt;/li&gt;
  &lt;li&gt;문제는 검색쿼리&lt;/li&gt;
  &lt;li&gt;검색을 할때도 테이블이 아닌 엔티티 객체를 대상으로 검색&lt;/li&gt;
  &lt;li&gt;모든 DB데이터를 객체로 변환해서 검색하는것은 불가능&lt;/li&gt;
  &lt;li&gt;애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요&lt;/li&gt;
  &lt;li&gt;객체를 대상으로 쿼리 =&amp;gt; JPQL&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  String jpql = &quot;selece m from Member m where m.name like '%hello%'&quot;;

  List&amp;lt;Member&amp;gt; result = emd. createQuery(jpql, Member.class).getResultList();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;QueryDSL은 사용하는것이 좋다. 하지만 criteriaJPA 사용하지마라&lt;/li&gt;
  &lt;li&gt;QueryDSL장점
    &lt;ul&gt;
      &lt;li&gt;문자가 아닌 자바코드로 JPQL을 작성할 수 있음&lt;/li&gt;
      &lt;li&gt;JPQL 빌더 역할&lt;/li&gt;
      &lt;li&gt;컴파일 시점에 문법 오류를 찾을 수 있음&lt;/li&gt;
      &lt;li&gt;동적 쿼리 작성 편리함&lt;/li&gt;
      &lt;li&gt;단순하고 쉬움&lt;/li&gt;
      &lt;li&gt;실무사용 권장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기본문법과-기능&quot;&gt;기본문법과 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는것이 아니라 엔티티 객체를 대상으로 쿼리한다.&lt;/li&gt;
  &lt;li&gt;JPQL은 SQL을 추상화해서 특정데이터ㅔ이스 SQL에 의존하지 않는다.(방언을 지원하므로 )&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JPQL은 결국 SQL로 변환된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DML 사용가능(select - where,groupby,having,orderby 등등)&lt;/li&gt;
  &lt;li&gt;TypeQuery : 반환타입이 명확할 때 사용
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  TypeQuery&amp;lt;Member&amp;gt; query =
      em.createQuery(&quot;select m from Member m&quot;,Member.class);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;Query : 반환 타입이 명확하지 않을 때 사용
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Query query = 
    em.createQuery(&quot;select m.usernaem, m.age from Member m&quot;);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결과 조회 API
    &lt;ul&gt;
      &lt;li&gt;query.getResultList(): 결과가 하나 이상일때, 리스트반환
        &lt;ul&gt;
          &lt;li&gt;결과가 없으면 빈 리스트 반환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;query.getSingleResult() : 결과가 정확히 하나, 단일 객체 반환
        &lt;ul&gt;
          &lt;li&gt;결과가없으면 : javax.persistence.NoResultException&lt;/li&gt;
          &lt;li&gt;둘이상이면 : javax.persistence.NonUniqueExcetion&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파라미터 바인딩 - 이름,위치 있는데 이름만 사용할것
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select m from Member m where m.username = :username
query.setParameter(&quot;username&quot;,usernameParam);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝션
    &lt;ul&gt;
      &lt;li&gt;엔티티 프로젝션&lt;/li&gt;
      &lt;li&gt;임베디드 타입 프로젝션&lt;/li&gt;
      &lt;li&gt;스탈라 타입 프로젝션&lt;/li&gt;
      &lt;li&gt;프로젝션 여러값조회
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objectp[] 타입으로 조회
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이징API
    &lt;ul&gt;
      &lt;li&gt;JPA는 페이징을 추상화함&lt;/li&gt;
      &lt;li&gt;setFirstResult(int startPosition) : 조회시작 위치&lt;/li&gt;
      &lt;li&gt;setMaxResult(int maxResult):조회할 데이터수
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m order by m.name desc&quot;;
List&amp;lt;Member&amp;gt; resultList = em.createQuery(jpql, Member.class)
  .setFirstResult(10);
  .setMaxResult(20)
  .getResultList();
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인
    &lt;ul&gt;
      &lt;li&gt;내부조인 : select m from Member m [INNER] join m.team t&lt;/li&gt;
      &lt;li&gt;외부조인 : select m from Member m left [outer] join m.team t&lt;/li&gt;
      &lt;li&gt;세타조인 : selece count(m) from Member m, Team t where m.username = t.name&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;[]는 생략가능&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;조인 - on 사용가능
        &lt;ul&gt;
          &lt;li&gt;조인 대상 필터링
```
-jqpl-
select m.t from Member m left join m.team t on t.name = ‘A’&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;-sql-
select m.&lt;em&gt;, t.&lt;/em&gt; from Member m left join team t on m.team_ID=t.id and t.name = ‘A’&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 연관관계 없는 엔티티 외부 조인 가능
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;-jqpl-
select m,t from Member m left join Team t on m.username = t.name&lt;/p&gt;

        &lt;p&gt;-sql-
select m.&lt;em&gt;, t.&lt;/em&gt; from Member m left join Team t on m.username = t.name
```&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;서브쿼리 사용가능
        &lt;ul&gt;
          &lt;li&gt;exists, all, any,some, in 등 서브쿼리 지원함수 사용가능
``` 
//팀a의 소속인 회원(팀a가 존재하는지 확인후 회원확인)
select m from Member m where exist (select t from m.team t where t.name = ‘팀a’)&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;//전체상품 각각의 재고보다 주문량이 많은 주문들
select o from Order o where o.orderAmount &amp;gt; ALL (select p.stockAmount from Product p)&lt;/p&gt;

        &lt;p&gt;//어떤 팀이든 팀에 소속된 회원
select m from Membeer m where m.team = any(select t from Team t)
```&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;서브쿼리의 한계
            &lt;ul&gt;
              &lt;li&gt;JPA는 where,having 절에서만 서브쿼리 사용가능&lt;/li&gt;
              &lt;li&gt;select절도 가능(하이버네이트지원)&lt;/li&gt;
              &lt;li&gt;From절의 서브쿼리는 현재 JPQL에서 불가능
                &lt;ul&gt;
                  &lt;li&gt;조인으로 풀수있으면 풀어서 해결&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조건식 사용가능
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; select
  case when m.age &amp;lt;=10 then '학생요금'
       when m.age &amp;gt;=60 then '경로요금'
       else '일반요금'
  end
from Member m

select
  case t.name
       when 'teamA' then '인센110'
       when 'teamB' then '인센120'
       else '인센105'
  end
from Team t
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;coalesce : 하나씩 조회해서 null이 아니면 반환
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select  coalesce(m.username,'이름없는 회원')from Member m
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;nullif : 두 값이 같으면 null 반환, 다르면 첫번째 값 반환
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select  NULLIF(m.username,'관리자')from Member m
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;페치조인--실무에서-정말정말-중요함-&quot;&gt;페치조인 ( 실무에서 정말정말 중요함 )&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL 조인 종류 X&lt;/li&gt;
  &lt;li&gt;JPQL에서 성능 최적화를 위해 제공하는 기능
  ##### * 연관된 엔티티나 컬렉션을 sql 한번에 함께 조회 하는 기능&lt;/li&gt;
  &lt;li&gt;join fetch 명령어 사용&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;페치 조인 ::= [ left [ outer ]&lt;/td&gt;
          &lt;td&gt;inner ] join fetch 조인경로&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;회원을 조회하면서 연관된 팀도 함께 조회
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m join fetch m.team&quot;
List&amp;lt;Member&amp;gt; members = em.createQuery(jpql,Member.calss).getResultList();

for(Member member : members){
  System.out.println(&quot;username = &quot; = member.getUsername() + &quot;, &quot; + &quot;teamName = &quot; + member.getTeam().name());
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;컬렉션 페치 조인 사용코드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select t from Team t join fetch t.members where t.name = '팀A'&quot; List&amp;lt;Team&amp;gt; teams = em.createQuery(jpql, Team.class).getResultList();

for(Team team : teams) {
System.out.println(&quot;teamname = &quot; + team.getName() + &quot;, team = &quot; + team); for (Member member : team.getMembers()) {
//페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함
System.out.println(“-&amp;gt; username = &quot; + member.getUsername()+ &quot;, member = &quot; + member); }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;위와 같은 컬렉션 페치 조인은 중복된 결과를 가져온다.&lt;/li&gt;
      &lt;li&gt;SQL에 DISTINCT를 추가하지만 데이터가 다르므로 SQL 결과 에서 중복제거 실패&lt;/li&gt;
      &lt;li&gt;JPQL의 distinct 애플리케이션에서 중복 제거 시도 - 2가지 기능제공
        &lt;ul&gt;
          &lt;li&gt;sql에 distinct를 추가&lt;/li&gt;
          &lt;li&gt;애플리케이션에서 엔티티 중복제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페치 조인과 일반 조인의 차이
        &lt;ul&gt;
          &lt;li&gt;JPQL은 결과를 반환할 때 연관관계 고려X&lt;/li&gt;
          &lt;li&gt;단지 select 절에 지정한 엔티티만 조회할 뿐&lt;/li&gt;
          &lt;li&gt;여기서는 팀 에네티티만 조회하고, 회원 엔티티는 조회X&lt;/li&gt;
          &lt;li&gt;페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시로딩)&lt;/li&gt;
          &lt;li&gt;페치조인은 객체 그래프를 SQL 한번에 조회하는 개념&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페치 조인 대상에는 별칭을 줄 수 없다.&lt;/li&gt;
      &lt;li&gt;둘이상의 컬렉션은 페치 조인 할 수 없다.&lt;/li&gt;
      &lt;li&gt;컬렉션을 페치 조인하면 페이징AP를 사용할 수 없다.
        &lt;ul&gt;
          &lt;li&gt;일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능&lt;/li&gt;
          &lt;li&gt;하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우위험)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;연관된 엔티티들을 sql 한번으로 조회-성능최적화&lt;/li&gt;
      &lt;li&gt;엔티티직접 적용하는 글로벌 로딩 전략보다 우선함
        &lt;ul&gt;
          &lt;li&gt;@OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실무에서 글로벌 로딩 전략은 모두 지연로딩&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;최적화가 필요한 곳은 페치 조인 적용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;페치조인 정리
        &lt;ul&gt;
          &lt;li&gt;모든 것을 페치 조인으로 해결할 수 는 없음&lt;/li&gt;
          &lt;li&gt;페치조인은 객체 그래프를 유지할 때 사용하면 효과적&lt;/li&gt;
          &lt;li&gt;여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;경로-표현식&quot;&gt;경로 표현식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상태 필드 : 단순히 값을 저장히기 위한 필드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(경로 탐색의 끝, 탐색 X)
select m.username, m.age from Member m
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;연관필드 : 연관관계를 위한 필드
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;단일값 연관경로 : 묵시적 내부 조인 발생, 탐색 O
select m.team from Team t
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;연관필드는 사용치 말고 이를 명시적인 join을 사용해라&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select m from Member m join m.team t
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;###### why???&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;n+1의 문제 발생가능하므로&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;경로 표현식 예제
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select o.member.team from Order o -&amp;gt; 성공

select t.members from Team -&amp;gt; 성공

select t.members.username from Team t -&amp;gt; 실패

select m.username from Team t join t.members m -&amp;gt; 성공
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;실무조언
    &lt;ul&gt;
      &lt;li&gt;가급적 묵시적 조인 대신에 명시적 조인 사용&lt;/li&gt;
      &lt;li&gt;조인은 SQL튜닝에 중요 포인트&lt;/li&gt;
      &lt;li&gt;묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다형성-쿼리&quot;&gt;다형성 쿼리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;조횧 대상을 특정 자식으로 한정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select i from Item i
where type(i) IN (BOOK,Movie)
-------

-jpql-
select i from Item i 
where treat(i as Book).auther = 'kim'
-sql-
select i.* from Item i 
where i.DTYPE = 'B' and i.author = 'kim'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;엔티티-직접-사용&quot;&gt;엔티티 직접 사용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본키 값을 사용
    &lt;h3 id=&quot;named-query&quot;&gt;Named query&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;미리 정의해서 이름을 부여해두고 사용하는 jpql&lt;/li&gt;
  &lt;li&gt;정척쿼리&lt;/li&gt;
  &lt;li&gt;어노테이션,xml에 정의&lt;/li&gt;
  &lt;li&gt;애플리 케이션 로딩 시점에 초기화 후 재사용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 로딩 시점에 쿼리를 검증&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;=&amp;gt; named query의 장점
    &lt;ul&gt;
      &lt;li&gt;로딩시점에 쿼리를 검증하므로 애러를 막을수있음&lt;/li&gt;
      &lt;li&gt;로딩시점에 쿼리를 파싱하므로 빠름
        &lt;h3 id=&quot;벌크-연산&quot;&gt;벌크 연산&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿼리한번으로 여러 테이블 로우 변경(엔티티)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String jpql = &quot;select m from Member m where m.age = 20&quot;

int resultCount = em.createQuery(jpql,INTEGER.class).executeUpdate();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;벌크연산주의
    &lt;ul&gt;
      &lt;li&gt;벌크 연산은 영속성 컨테스트를 무시하고 데이터 베이스에 직접 쿼리
        &lt;ul&gt;
          &lt;li&gt;벌크연산을 먼저수행한다.&lt;/li&gt;
          &lt;li&gt;벌크 연산 수행후 영속성 컨텍스트 초기화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why?? 초기화 해야하는가?
        &lt;ul&gt;
          &lt;li&gt;DB상에 직접쿼리를 날리므로 그전에 persist(entity)한 값들이 1차캐시에 남아있다. 컨텍스트를 초기화 하지않고 조회하면 그전에 1차캐시의 값들을 가져오기 때문에&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/31/jpa-concept-9/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/31/jpa-concept-9/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-8</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;데이터-타입-분류&quot;&gt;데이터 타입 분류&lt;/h2&gt;

&lt;h3 id=&quot;기본값-타입&quot;&gt;기본값 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;엔티티 타입
    &lt;ul&gt;
      &lt;li&gt;@Entity로 정의하는 객체&lt;/li&gt;
      &lt;li&gt;데이터가 변해도 식별자로 지속해서 추적 가능&lt;/li&gt;
      &lt;li&gt;예) 회원 엔티티의 키나 나이값을 변경해도 식별자로 인식 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값 타입
    &lt;ul&gt;
      &lt;li&gt;int, Integer,String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체&lt;/li&gt;
      &lt;li&gt;식별자가 없고 갑만 있으므로 변경시 추적 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본값타입 : int ,string 자바 기본타입&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션 값 타입 : 자바 컬렉션에 기본값타입을 넣은것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 값 타입 특징
    &lt;ul&gt;
      &lt;li&gt;생명주기를 엔티티의 의존&lt;/li&gt;
      &lt;li&gt;값 타입은 공유하면 X&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;임베디드-타입&quot;&gt;임베디드 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;임베디드 타입 : 커스텀한 값타입 (새로운 값타입을 직접 정의할 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;member.class&amp;gt;
    @Embedded
    private Period workPeriod;

    // 주소
    @Embedded
    private Address homeAddress;

    ---------------------
    &amp;lt;Period.class&amp;gt;
    @Embeddable // 값타입이라고 알려주는 애노테이션
    public class Period {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;재사용이 가능하다&lt;/li&gt;
      &lt;li&gt;높은 응집도&lt;/li&gt;
      &lt;li&gt;Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음.&lt;/li&gt;
      &lt;li&gt;임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;임베디드 타입은 엔티티의 값일 뿐이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컬럼 명이 중복됨( 한 엔티티에서 같은 값 타입을 사용하려면?)
    &lt;ul&gt;
      &lt;li&gt;@AttributeOverrides를 사용하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;값타입과-불변-객체&quot;&gt;값타입과 불변 객체&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;임베디드 타입을 사용할시에 여러가지 튜플이 존재할수있고 이를 하나의 어트리뷰트를 가르킬수있다. 
객체(jpa)상에서 회원1과 회원2가 같은 Address를 가리키는것!&lt;/li&gt;
  &lt;li&gt;이때 임베디드 타입은 객체 타입이므로 회원1의 Address 변경시 회원2또한 변경된다.
    &lt;ul&gt;
      &lt;li&gt;객체타입은 주소값을 넘기는 참조값이므로 (값을 복사하는 기본값타입이 아님)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이러한 부작용(side effect)이 발생가능 하고 이를 추적하기 매우 까다로움&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;그러므로 이를 미연에 방지하는 코드가 좋은 코드이다. 이를 방지하기 위해서는&lt;/li&gt;
  &lt;li&gt;객체를 불변객체로만드는것과 값(인스턴스)를 복사해서 사용하는것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Address address = new Address(&quot;city&quot;,&quot;street&quot;,&quot;10000&quot;);
  Member member = new Member();
  member.setName(&quot;aaa&quot;);
  member.setHomeAddress(address);
  em.persist(member);

  Address newAddress = new Address(&quot;city&quot;,&quot;street&quot;,&quot;10000&quot;);
  Member member2 = new Member();
  member2.setName(&quot;bbb&quot;);
  member2.setHomeAddress(newAddress);
  em.persist(member2);

  //member.getHomeAddress().setCity(&quot;newCity&quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위의 코드와 같이 각각의 멤버에 새로운 인스턴스를 설정해서 사이트이팩트를 방지해야한다.&lt;/p&gt;

&lt;h3 id=&quot;값타입-컬렉션&quot;&gt;값타입 컬렉션&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;값 타입을 하나 이상 저장할 때 사용&lt;/li&gt;
  &lt;li&gt;@ElementCollection, @CollectionTable사용&lt;/li&gt;
  &lt;li&gt;데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션을 저장하기 위한 별도의 테이블이 필요함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;값타입 컬렉션의 제약사항
    &lt;ul&gt;
      &lt;li&gt;값타입은 엔티티와 다르게 식별자 개념이 없다.&lt;/li&gt;
      &lt;li&gt;값은 변경하면 추적이 어렵다.&lt;/li&gt;
      &lt;li&gt;값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제 하고, 값타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값타입 컬렉션 대안
    &lt;ul&gt;
      &lt;li&gt;실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/30/jpa-concept-8/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/30/jpa-concept-8/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-7</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
  &lt;h2 id=&quot;프록시&quot;&gt;프록시&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li&gt;즉시로딩과 지연로딩&lt;/li&gt;
    &lt;li&gt;지연로딩 활용&lt;/li&gt;
    &lt;li&gt;영속성 전이 : cascade&lt;/li&gt;
    &lt;li&gt;고아 객체&lt;/li&gt;
    &lt;li&gt;영속성 전이 + 고아객체, 생명주기&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;프록시와-연관관계&quot;&gt;프록시와 연관관계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Member를 조회할때 Team도 조회 해야할까?
member를 통해서 team까지 연계 되는 비즈니스 로직이라면 효율적이나 &lt;br /&gt;
member만 필요한 비즈니스 로직이라면 비효율적이다. &lt;br /&gt;
=&amp;gt; 이를 위해서 jpa에서는 지연로딩과 프록시를 통해서 케어를한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프록시 기초&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;em.find() : DB를 통해서 실제 엔티티 객체 조회&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;em.getReference() : DB 조회를 미루는 가짜(프록시) 엔티티 객체 조회&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시의 특징 1
        &lt;ul&gt;
          &lt;li&gt;실제 클래스를 상속 받어서 만들어짐&lt;/li&gt;
          &lt;li&gt;실제 클래스와 겉 모양이 같다.&lt;/li&gt;
          &lt;li&gt;사용하는 입장에서는 진짜 객체인지 프롯기 객체인지 구분하지 않고 사용하면 됨(이론상)&lt;/li&gt;
          &lt;li&gt;프록시 객체는 실제 객체의 참조(target)를 보관&lt;/li&gt;
          &lt;li&gt;프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드호출&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시 호출순서
        &lt;ol&gt;
          &lt;li&gt;getName()&lt;/li&gt;
          &lt;li&gt;초기화 요청( 영속성 컨텍스트)&lt;/li&gt;
          &lt;li&gt;DB조회&lt;/li&gt;
          &lt;li&gt;실제 Entity의 메소드 호출함&lt;/li&gt;
          &lt;li&gt;4번의 값을 target.getName()으로 반환함 (실제객체의 참조를 보관)&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시의 특징(주의)
        &lt;ul&gt;
          &lt;li&gt;프록시 객체는 처음 사용할 때 한번만 초기화&lt;/li&gt;
          &lt;li&gt;프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능&lt;/li&gt;
          &lt;li&gt;프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교실패, instance of 사용)&lt;/li&gt;
          &lt;li&gt;영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환&lt;/li&gt;
          &lt;li&gt;영속성 컨텐스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화 하며 문제 발생(하이버네이트는 org.hibernate.LazyinitializationException 예외를 터트림)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프록시 확인
        &lt;ul&gt;
          &lt;li&gt;프록시 인스턴스의 초기화 여부 확인
            &lt;ul&gt;
              &lt;li&gt;emf.PersistenceUnitUitl.isLoaded(Object entity)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;프록시 클래스 확인 방법
            &lt;ul&gt;
              &lt;li&gt;entity.getclass()&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;강제 초기화
            &lt;ul&gt;
              &lt;li&gt;Hibernate.initialize(entity);&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;즉시로딩과-지연로딩&quot;&gt;즉시로딩과 지연로딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Member를 조회할때 Team도 조회 해야할까?
member를 통해서 team까지 연계 되는 비즈니스 로직이라면 효율적이나 &lt;br /&gt;
member만 필요한 비즈니스 로직이라면 비효율적이다. &lt;br /&gt;
=&amp;gt; 이를 위해서 jpa에서는 지연로딩과 프록시를 통해서 케어를한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 지연 로딩 및 즉시로딩 사용법
  @ManyToOne(fetch = FetchType.LAZY)  //FetchType.EAGAR
  @JoinColumn(name = &quot;TEAM_ID&quot;)
  private Team team;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;지연로딩 내부 순서
    &lt;ul&gt;
      &lt;li&gt;LAZY로 되어있는 entity 조회&lt;/li&gt;
      &lt;li&gt;그리고 관련된 team은 프록시객체 생성되어있다.&lt;/li&gt;
      &lt;li&gt;실질적인 team의 메소드를 호출할때 초기화가 진행되어 쿼리를 날린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실무에서는 즉시로딩 주의
    &lt;ul&gt;
      &lt;li&gt;가급적 지연 로딩만 사용(특히 실무에서)&lt;/li&gt;
      &lt;li&gt;즉시로딩을 적용하면 예상하지 못하는 sql 발생&lt;/li&gt;
      &lt;li&gt;즉시로딩은 JPQL에서 N+1 문제를 일으킨다.&lt;/li&gt;
      &lt;li&gt;무조건 LAZY로 사용해라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지연로딩 활용 - 실무
    &lt;ul&gt;
      &lt;li&gt;모든 연관관계에 지연로딩을 사용해라!&lt;/li&gt;
      &lt;li&gt;실무에서 즉시로딩을 사용하지 마라!&lt;/li&gt;
      &lt;li&gt;JPQL fetch조인이나, 엔티티 그래프 기능을 사용해라!&lt;/li&gt;
      &lt;li&gt;즉시로딩은 상상하지 못한 쿼리가 나간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;영속성-전이--cascade--orhanremoval--true&quot;&gt;영속성 전이 : CASCADE &amp;amp; orhanRemoval = true&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때&lt;/li&gt;
  &lt;li&gt;저장,삽입,삭제 모두 가능
  ```
  @OneToMany(mappedBy = “parent”,cascade = CascadeType.ALL,orphanRemoval = true)
  private List&lt;Child&gt; childList = new ArrayList&amp;lt;&amp;gt;();&lt;/Child&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;————— 트랜잭션 부분 ——-
    Child child1 = new Child();
    Child child2 = new Child();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent parent = new Parent();
parent.addChild(child1);
parent.addChild(child2);

em.persist(parent);
//em.persist(child1);
//em.persist(child2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영속성 전이는 연관관계를 매핑하는것과 아무 관련이 없음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;엔티티를 영속화 할때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;고아객체(orphanRemoval)
    &lt;ul&gt;
      &lt;li&gt;부모엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cascade와 고아객체 모두 주의할점
    &lt;ul&gt;
      &lt;li&gt;참조한느곳이 하나일 때 사용해야 함&lt;/li&gt;
      &lt;li&gt;특정 엔티티가 개인 소유할 떄 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/30/jpa-concept-7/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/30/jpa-concept-7/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-6</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;상속관계-매핑&quot;&gt;상속관계 매핑&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;관계형 데이터베이스는 상속 관계 X&lt;/li&gt;
  &lt;li&gt;슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;슈퍼타입 서브타입 논리모델을 실제 물리 모델로 구현하는 방법
    &lt;ul&gt;
      &lt;li&gt;각각 테이블로 변환 -&amp;gt; 조인 전략 ( 가장 정규화된 방식 )&lt;/li&gt;
      &lt;li&gt;통합 테이블로 변환 -&amp;gt; 단일 테이블 전략&lt;/li&gt;
      &lt;li&gt;서브타입 테이블로 변환 -&amp;gt; 구현 클래스마다 테이블 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인전략(장점)
    &lt;ul&gt;
      &lt;li&gt;테이블 정규화&lt;/li&gt;
      &lt;li&gt;외래 키 참조 무결성 제약 조건 활용가능&lt;/li&gt;
      &lt;li&gt;저장공간 효율화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조인전략(단점)
    &lt;ul&gt;
      &lt;li&gt;조회시 조인을 많이 사용, 성능저하&lt;/li&gt;
      &lt;li&gt;조회 쿼리가 복잡함&lt;/li&gt;
      &lt;li&gt;데이터 저장시 insert sql2번 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단일테이블전략(장점)
    &lt;ul&gt;
      &lt;li&gt;조인이 필요 없으므로 일반적으로 조회 성능이 빠름&lt;/li&gt;
      &lt;li&gt;조회 쿼리가 단순함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단일테이블전략(단점)
    &lt;ul&gt;
      &lt;li&gt;자식 엔티티가 매핑한 컬럼은 모두 null허용&lt;/li&gt;
      &lt;li&gt;단일 테이블에 모든 것을 저장하므로 테이블이 커질수 있고 상환에따라서 조회 성능이 오히려 느려질수있다.(임계점을 넘어야한다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현 클래스마다 테이블전략 -&amp;gt; 사용치 마라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##### 어떤전략을 사용해야하나?
    이부분에서는 DB설계자와 잘 협의하여야한다. 기본적으로는 join전략을 사용하는게 좋다. &lt;br /&gt;
    추후 비즈니스 로직이 추가될 것을 생각하면!! &lt;br /&gt;
    하지만 간단한 테이블이고 추후 더 발전 가능성이 없다고 생각하면 단일테이블전략으로 가라 !!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실무에서 상속 관계를 쓰느냐??
경우에 따라 다르다. &lt;br /&gt;
데이터가 많아지면 테이블이 단순해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mappedsuperclass&quot;&gt;@MappedSuperclass&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;공통 매핑 정보가 존재할때 속성만 상속해서 사용하고 싶을때 ( 디비는 각각 다르다 ) 객체에서만 속성을 묶는것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계 매핑 X&lt;/li&gt;
  &lt;li&gt;엔티티 X, 테이블과 매핑X&lt;/li&gt;
  &lt;li&gt;부모클래스를 상속 받는 자식 클래스에 매핑 정보만 제공&lt;/li&gt;
  &lt;li&gt;조회,검색 불가(em.find(BaseEntity)불가)&lt;/li&gt;
  &lt;li&gt;직접 생성해서 사용할 일이 없으므로 추상 클래스 권장&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/29/jpa-concept-6/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/29/jpa-concept-6/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-5</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;연관관계-매핑시-고려사항-3가지&quot;&gt;연관관계 매핑시 고려사항 3가지&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중성
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;다대일 : @ManyToOne
관계형 테이블에서는 다(many)쪽에 fk가 들어가줘야한다. &lt;br /&gt;
그리고 객체에서는 참조를 할때는 외래키를 기준으로 참조를 넣는다.(@ManyToOne) &lt;br /&gt;
다대일의 반대는 일대다&lt;/p&gt;

        &lt;p&gt;how to 양방향 from 단방향?? &lt;br /&gt;
연관관계의 주인의 반대편에 연관관계의 주인인(외래키) 참조할수있도록 리스트(컬랙션)을 넣어주면 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;일대다 : @OneToMany
일방향에서 연관관계주인이 되겠다는 의미이다. (권장하지는 않는다.)&lt;/p&gt;

        &lt;p&gt;일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 &lt;br /&gt;
테이블 일대다 관계는 항상 다(N)쪽에 외래 키가 있음 &lt;br /&gt;
객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조 &lt;br /&gt;
@JoinColumn을 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;정리
엔티티가 관리하는 외래 키가 다른 테이블에 있음 &lt;br /&gt;
연관관계를 관리를 위해 추가로 update sql실행됨  &lt;br /&gt;
일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자   &lt;br /&gt;
일대다 양방향도 존재가능하다 다(N)에서 읽기전용으로 @joinColumn(insertable = false,update=false)를 사용하자.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;일대일 : @OneToOne
일대일 관계는 그 반대도 일대일 &lt;br /&gt;
주 테이블이나 대상 테이블 중에 외래키 선택 가능 &lt;br /&gt;
외래 키에 데이터베이스 유니크 제약조건 추가&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;주테이블에 외래키
주 객체가 대상 객체의 참조를 가지는 것 처럼  주테이블에 외래키를 두고 대상 테이블을 찾음 &lt;br /&gt;
객체지향 개발자 선호  &lt;br /&gt;
JPA매핑편리 &lt;br /&gt;
장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 &lt;br /&gt;
단점 : 값이 없으면 외래키에 null 허용&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;대상 테이블에 외래 키
대상 테이블에 외래 키가 존재 &lt;br /&gt;
전통적인 데이터베이스 개발자 선호  &lt;br /&gt;
장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;다대다 : @ManyToMany&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;다대다는 실무에서 절대 쓰지 않는다.(엔티티를 추가 생성한다.)
 why?? &lt;br /&gt;
 JPA에서 두 테이블을 @ManyToMany하게 되면 추가적인 테이블이 하나 더 생성된다.  &lt;br /&gt;
 이때 생성된 테이블에 추가적인 데이터를 넣지 못한다.  &lt;br /&gt;
 그래서 이를 잘 안쓰고 onetomany, manytoone으로 나눠서 다시 설정한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단방향, 양방향
    &lt;ul&gt;
      &lt;li&gt;테이블
        &lt;ul&gt;
          &lt;li&gt;외래키 하나로 양쪽 조인 가능&lt;/li&gt;
          &lt;li&gt;사실 방향이라는 개념이 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체
        &lt;ul&gt;
          &lt;li&gt;참조용 필드가 있는 쪽으로만 참조가능&lt;/li&gt;
          &lt;li&gt;한쪽만 참조하면 단방향&lt;/li&gt;
          &lt;li&gt;양쪽이 서로 참조하면 양방향&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;연관관계의 주인
        &lt;ul&gt;
          &lt;li&gt;테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음&lt;/li&gt;
          &lt;li&gt;객체 양방향 관계는 a-&amp;gt;b, b-&amp;gt;a 처럼 참조가 2군데&lt;/li&gt;
          &lt;li&gt;객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래키를 관리할 곳을 지정해야함&lt;/li&gt;
          &lt;li&gt;연관관계의 주인 : 외래키를 관리하는 참조&lt;/li&gt;
          &lt;li&gt;주인의 반대편 : 외래키에 영향을 주지 않음, 단순조회만 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/29/jpa-concept-5/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/29/jpa-concept-5/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;연관관계-매핑-기초&quot;&gt;연관관계 매핑 기초&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;객체와 테이블 연관관계의 차이를 이해&lt;/li&gt;
  &lt;li&gt;객체의 참조와 테이블의 외래키를 매핑&lt;/li&gt;
  &lt;li&gt;용어 이해
    &lt;ul&gt;
      &lt;li&gt;방향 : 단방향, 양방향&lt;/li&gt;
      &lt;li&gt;다중성 : 다대일, 일대다, 일대일, 다대다&lt;/li&gt;
      &lt;li&gt;연관관계의 주인 : 객체 양방향 연관관계는 관리 주인이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 단방향 연관매핑&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @ManyToOne
    @JoinColumn(name = &quot;TEAM_ID&quot;) 
    private Team team;
  =========================
    Team team = new Team();
    team.setName(&quot;TeamA&quot;);
    em.persist(team);

    // 연관관계설정
    Member member = new Member();
    member.setName(&quot;memeber1&quot;);
    member.setTeam(team);
    em.persist(member);

    // 연관관계 설정시 그래프 탐색
    Member findMember = em.find(Member.class,member.getId());

    Team findTeam = findMember.getTeam();
    System.out.println(&quot;findTeam = &quot; + findTeam.getName());

    // 새로운 팀 B
    Team teamB = new Team();
    member.setName(&quot;teamB&quot;);
    em.persist(teamB);0

    // 회원1에 새로운 팀 B설정
    member.setTeam(teamB);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 다대일 연관관계는 @ManyToOne 애노테이션으로 설정 가능하다.
* @JoinColumn을 설정하면 jpa가 name을 확인하고 fk로 설정해준다. 타입을 Team인 이유는 객체스럽게 사용하기 위해서 이다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;### 양방향 연관관계와 연관관계의 주인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체는 참조라는것을 사용하고 테이블은 조인을사용한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;둘의 차이점을 명확하게 알아야한다. 왜? 필요한지 알아야한다.&lt;/p&gt;

    &lt;p&gt;양방향 객체 연관관계 : Member는 Team의 fk를 가지고 있어 참조 가능하다. Team이 Member를 참조하려면 List members라는 것을 가지고 있어야 참조(탐색) 가능하다.&lt;/p&gt;

    &lt;p&gt;테이블 연관관계 : Member와 team은 각각 pk를 가지고 있으면 member는 fk를 가지고 있다. 이를 통해 조인하여 서로 탐색이(조회가) 가능하다.
  ```
  [Team.java]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// mappedBy는 Member의 Team타입의 team에 연결되어있다는 뜻
   @OneToMany(mappedBy = “team”)
   private List&lt;Member&gt; members = new ArrayList&amp;lt;&amp;gt;();
  ===================================&lt;/Member&gt;&lt;/p&gt;

&lt;p&gt;[JpaMain.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Team team = new Team();
team.setName(&quot;TeamA&quot;);
// team.getMembers().add(member);// mappedBy 의해서 주인이 아니다.
em.persist(team);

// 연관관계설정
Member member = new Member();
member.setName(&quot;memeber1&quot;);
// member.changeTeam(team); // 멤버에 팀을 추가
em.persist(member);

team.addMember(member); // 팀에 멤버를 추가
// &amp;lt;양방향 객체 jpa 참조할시 둘중에 한곳에서만 하는게 났다. &amp;gt;

// 양쪽으로 데이터를 넣어야한다. 왜? 한쪽으로 넣으면 commit 날리기 전에
// 멤버에 팀을 넣거나 팀에 멤버를 넣을수없으므로
// 그렇다면 어떻게 해야하나? 양방향 편의 메소드를 생성하라

// em.flush();
// em.clear();

// 연관관계 설정시 그래프 탐색
Member findMember = em.find(Member.class,member.getId());
List&amp;lt;Member&amp;gt; members = findMember.getTeam().getMembers();

System.out.println(&quot;================&quot;);
for(Member m : members){
    System.out.println(&quot;m = &quot; + m.getName());
// System.out.println(&quot;team name = &quot; + m.getTeam().getName());
}
System.out.println(&quot;================&quot;);
// 가장 많이 하는 양방향 실수 to.string,loombok,json 생성라이브러리
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컨트롤러에서 엔티티를 json으로 반환하면 에러가 생길수 있다.
    &lt;ul&gt;
      &lt;li&gt;이를 방지하는것은 엔티티를 json으로 반환하지 마라 » DTO이용해라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연관관계의 주인은 외래키의 위치를 기준으로 정해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 연관관계 매핑 시작&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;jpashop을 프로젝트에 연관관계 설정을 해본다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;양방향 연관관계를 설정하는 이유?&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;조금더 편한 개발을 위해서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/24/jpa-concept-4/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/24/jpa-concept-4/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-3</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;앤티티-매핑&quot;&gt;앤티티 매핑&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;객체와 테이블 매핑 : @Entity, @Table&lt;/li&gt;
  &lt;li&gt;필드와 컬럼 매핑 : @Column&lt;/li&gt;
  &lt;li&gt;기본키 매핑 : @Id&lt;/li&gt;
  &lt;li&gt;연관관계 매핑 : @ManyToOne, @JoinColumn&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체와-테이블-매핑&quot;&gt;객체와 테이블 매핑&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@Entity 
    * jpa가 관리하는 엔티티
    &lt;ul&gt;
      &lt;li&gt;기본 생성자 필수&lt;/li&gt;
      &lt;li&gt;final 클래스, enum,interface, inner 클래스 사용 x&lt;/li&gt;
      &lt;li&gt;저장할 필드에 final 사용 x&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터베이스 스키마 자동생성
    &lt;ul&gt;
      &lt;li&gt;DDL을 애플리케이션 실행 시점에 자동생섯ㅇ&lt;/li&gt;
      &lt;li&gt;테이블 중심 -&amp;gt; 객체중심&lt;/li&gt;
      &lt;li&gt;개발하다 sql가서 DDL 실행할 일이없어진다.&lt;/li&gt;
      &lt;li&gt;스키마 자동생성은 개발단계에서만 사용해야한다.&lt;/li&gt;
      &lt;li&gt;persistence.xml 에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt;&lt;/code&gt; 옵션을 키면 된다.&lt;/li&gt;
      &lt;li&gt;제약조건도 설정가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;필드와 컬럼 매핑
    &lt;ul&gt;
      &lt;li&gt;매핑 어노테이션
        &lt;ul&gt;
          &lt;li&gt;@Column : 컬럼매핑
            &lt;ul&gt;
              &lt;li&gt;name : 필드와 매핑할 테이블의 칼럼 이름&lt;/li&gt;
              &lt;li&gt;insertable, updatable : 등록 ,변경 가능 여부&lt;/li&gt;
              &lt;li&gt;nullable : false라고 할시 not null의 의미이다.&lt;/li&gt;
              &lt;li&gt;unique : 중복을 방지함 &lt;하지만 잘쓰지=&quot;&quot; 않는다.=&quot;&quot; 이름이=&quot;&quot; 자동생성=&quot;&quot; 이므로=&quot;&quot;&gt;&lt;/하지만&gt;&lt;/li&gt;
              &lt;li&gt;columnDefinition : DB컬럼 정보를 직접줄수있다.ex) varchar(100) default ‘EMPTY’&lt;/li&gt;
              &lt;li&gt;length : 문자길이 제약조건, string 타입에만 사용한다.&lt;/li&gt;
              &lt;li&gt;precision,scale : BigEdcimal 타입에서 사용한다. precision은 소수점을 포함한 전체 자릿수를 ,scale은 소수의 자릿수다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;@Enumerated : enum type
            &lt;ul&gt;
              &lt;li&gt;EnumType.ORDINAL : enum순서를 DB에 저장 « 왠만하면 쓰지마라&lt;/li&gt;
              &lt;li&gt;EnumType.STRING : enum 이름을 DB에 저장&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;@Temporal : 시간&lt;/li&gt;
          &lt;li&gt;@Lob : varchar를 넘어선 대용량의 데이터&lt;/li&gt;
          &lt;li&gt;Transient : 메모리에 임시로 실행할때 without DB&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본키 매핑
    &lt;ul&gt;
      &lt;li&gt;identity
        &lt;ul&gt;
          &lt;li&gt;identity 전략에서 DB에 들어가봐야 id값을 알수있다.&lt;/li&gt;
          &lt;li&gt;영속컨테스트를 사용하기 위해서는 Id값이 있어야한다.&lt;/li&gt;
          &lt;li&gt;indentity 전략에서만 .persist(entity)에서 insert쿼리를 날린다. commit()에서가 아니라 why?? -&amp;gt; 영속 컨테스트 사용하기 위해서&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SEQUENCE
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @Entity
  @SequenceGenerator(
  name = “MEMBER_SEQ_GENERATOR&quot;,
  sequenceName = “MEMBER_SEQ&quot;, //매핑할 데이터베이스 시퀀스 이름
  initialValue = 1, allocationSize = 1)
  public class Member {
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE,generator = &quot;MEMBER_SEQ_GENERATOR&quot;)
  private Long id
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;위와같은 코드에서 시퀀스를 설정 할 수 있다.&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;initialValue : DDL을 생성할 때 처음 1 시작하는 수를 지정한다.&lt;/li&gt;
          &lt;li&gt;allocationSize : 시퀀스 한번 호출에 증가하는수(성능 최적화에 사용됨)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;권장하는 식별자 전략
    &lt;ul&gt;
      &lt;li&gt;기본키 제약조건 : null아님, 유일, 변하면 안된다.&lt;/li&gt;
      &lt;li&gt;권장 : Long형 + 대체키 + 키 생성 전략 사용(시퀀스등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;엔티티설계와 매핑
    &lt;ul&gt;
      &lt;li&gt;UML을 참고로 jpa 매핑을 진행한다.&lt;/li&gt;
      &lt;li&gt;하지만 DB(UML)는 데이터(테이블)중심 설계이므로 객체 그래프 탐색이 불가능하다.&lt;/li&gt;
      &lt;li&gt;이는 객체적인 코딩이 안되는것이며 a테이블에서 b테이블의 관계를 설정시 많은 타입과 설정이 필요하다는 것임 =&amp;gt; 객체스럽지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Entity
   @Table(name = &quot;ORDERS&quot;) // ORDER는 DB에서 예약어로 걸린상황이 많음
   public class Order {

      @Id @GeneratedValue()
      @Column(name = &quot;ORDER_ID&quot;)
      private Long id;

      @Column(name = &quot;MEMBER_ID&quot;)
      private Long memberId;

      private LocalDateTime orderDate;

      @Enumerated(EnumType.STRING)
      private OrderStatus status;

      public Long getId() {
         return id;
      }
      .
      .

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Order table의 예시&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   @Entity
   public class OrderItem {

      @Id @GeneratedValue()
      @Column(name = &quot;ORDER_ITEM_ID&quot;)
      private Long id;

      @Column(name = &quot;ORDER_ID&quot;)
      private Long orderId;

      @Column(name = &quot;ITEM_ID&quot;)
      private Long itemId;

      private int orderPrice;
      private int count;

      public Long getId() {
         return id;
      }
      .
      .

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;OrderItem table의 예시&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/23/jpa-concept-3/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/23/jpa-concept-3/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-2</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;영속성-관리&quot;&gt;영속성 관리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;jpa 영속 컨텍스트(jpa의 실제 내부 동작)
    &lt;ul&gt;
      &lt;li&gt;jpa를 이해하는데 가장 중요한 용어&lt;/li&gt;
      &lt;li&gt;엔티티를 영구 저장하는 환경이라는 뜻&lt;/li&gt;
      &lt;li&gt;EntityManager.persist(entity) » 엔티티를 영속 컨텍스트에 저장하는것이다. DB저장 아님&lt;/li&gt;
      &lt;li&gt;1차캐시에 올라가는 상황이 영속 상태가 되는것이다. (저장,조회(1차캐시에 없을때))&lt;/li&gt;
    &lt;/ul&gt;

    &lt;ol&gt;
      &lt;li&gt;엔티티는 생명주기가 존재한다.
        &lt;ul&gt;
          &lt;li&gt;비영속 : 객체만 생성한 상태(jpa와 관계가 없는 상태)&lt;/li&gt;
          &lt;li&gt;영속 : 맴버객체를 생성한다음 entitymanager생성후 .persist(member) 하면 객체가 영속 상태가 된다 . &lt;u&gt; 아직 DB에 저장되지 않은 상태 이고 추후에 커밋되면 DB에 저장된다. &lt;/u&gt;&lt;/li&gt;
          &lt;li&gt;준영속 : 영속성 컨테스트에서 객체를 분리하여는 기능 ex)em.detach(member);,&lt;/li&gt;
          &lt;li&gt;삭제 : 객체를 삭제한 상태(삭제) 등록된 DB에서 완벽하게 삭제하는 기능 ex)em.remove(객체);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;영속성 컨텍스트의 이점 (필요 이유)
        &lt;ul&gt;
          &lt;li&gt;엔티티조회, 1차 캐시 : .persist() 수행하면 영속 컨텍스트에 1차캐시가 생김   그리고 조회시 DB를 먼저 접근하지 않고 1차캐시를 먼저 접근하여 pk(@Id)확인후 없으면 DB확인한다. &lt;u&gt;1차캐시의 나름의 문제점?이라고 한다면 entitymanager는 트랜잭션 단위로 진행되기에 짧은 순간 존재한다.&lt;/u&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;영속 엔티티의 동일성 보장
        &lt;ul&gt;
          &lt;li&gt;1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;엔티티 등록(트랜잭션을 지원하는 쓰기 지연)
        &lt;ul&gt;
          &lt;li&gt;여러개의 .persist()함수를 수행하여도 이것을 함수 수행마다 바로 쿼리를 날리지 않고 이를 지연하고 있다가 커밋이 나오면 한번에 쿼리를 작성한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;엔티티 수정
        &lt;ul&gt;
          &lt;li&gt;객체의 함수로 엔티티의 값을 수정한다.&lt;/li&gt;
          &lt;li&gt;수정하였다면 .persist()를 통해서 다시 쿼리를 날려야할것같지만 아니다.&lt;/li&gt;
          &lt;li&gt;1차캐시안에는 엔티티값과 스냅샷이 존재하는데 이것이 플래시(커밋) 하였을때 변경되면 체크하여 업데이트 쿼리를 생성해줌. 누가?? Jpa가 정확히는 영속 컨테스트가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;엔티티 삭제
        &lt;ul&gt;
          &lt;li&gt;id를 찾는다. » Member memberA = em.find(Member.class,”memberA”);&lt;/li&gt;
          &lt;li&gt;그리고 삭제 쿼리를 날린다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;플러시
    &lt;ul&gt;
      &lt;li&gt;영속 컨테스트의 쿼리를 날려주는것&lt;/li&gt;
      &lt;li&gt;번경감지(dirty checking), 수정된 엔티티 쓰기지연 sql저장소에 등록, 쓰기지연 sql저장소의 쿼리를 DB에 저장&lt;/li&gt;
      &lt;li&gt;어떻게 플러시를 하냐 ? (flush는 데이터베이스에 변경내용을 동기화 되는것이지 1차캐시가 사라지는것은 아니다.)
        &lt;ul&gt;
          &lt;li&gt;em.flush() - 직접호출(강체호출)&lt;/li&gt;
          &lt;li&gt;트랜잭션 커밋 - 플러시 자동 호출&lt;/li&gt;
          &lt;li&gt;jpql쿼리 실행  - 플러시 자동 호출&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;준영속
    &lt;ul&gt;
      &lt;li&gt;영속 -&amp;gt; 준영속&lt;/li&gt;
      &lt;li&gt;준영속 상태에서는 dirty checking등, 1차캐시의 이점을 사용하지 못한다.&lt;/li&gt;
      &lt;li&gt;실행하는 방법.
        &lt;ul&gt;
          &lt;li&gt;em.detach(entity)&lt;/li&gt;
          &lt;li&gt;em.clear() : 1차캐시를 통으로 지움&lt;/li&gt;
          &lt;li&gt;em.close() : 영속 컨테스트 종료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;EntityManagerFactory&lt;/li&gt;
      &lt;li&gt;EntityManager&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체와 관계형 데이터 베이스 매핑하기(설계적인 부분)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 22 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/22/jpa-concept-2/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/22/jpa-concept-2/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>jpa-concept-1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;spring jpa study&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;sql의-문제점&quot;&gt;sql의 문제점&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상속을 사용하듯이 sql을 사용할수가 없다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  String memberId = &quot;100&quot;;
  Member member1 = memberDAO.getMember(memberId);
  Member member2 = memberDAO.getMember(memberId);
  member1 == member2; //다르다. class MemberDAO {
  public Member getMember(String memberId) {
  String sql = &quot;SELECT * FROM MEMBER WHERE MEMBER_ID = ?&quot;;
  ...
  //JDBC API, SQL 실행
  return new Member(...);
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;다음과 같은 상황에서 sql을 사용하게 된다면 쿼리는 동일하나 반환하는 member의 값이 다르다  &lt;br /&gt;
그런데 아래와 같이 자바컬렉션에서와 같이 조회 가능하다면 좋겠다는 생각이 들고  &lt;br /&gt;
이를 해결하기 위해서 나온것이 jpa이다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String memberId = &quot;100&quot;;
Member member1 = list.get(memberId);
Member member2 = list.get(memberId);
member1 == member2; //같다.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;객체답게 모델링 할수록 매핑 작업만늘어난다. » sql과 객체지향의 문제점&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;jpa&quot;&gt;JPA?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;java 진형의 orm이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jpa는 jdbcapi를 사용하여 DB접근을 하는데 패러다임의 불일치를 해결해준다.&lt;/p&gt;

&lt;p&gt;jpa는 인터페이스의 모음이다.&lt;/p&gt;

&lt;h2 id=&quot;why-jpa를-사용하는가&quot;&gt;why? jpa를 사용하는가.??&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;생산성적인 측면에서 저장,조회, 수정, 삭제 등이 만들어진다. 쿼리가 만들어진다._&lt;/li&gt;
  &lt;li&gt;유지 보수측면에서는 필드변경시 모든 sql수정해야하지만 jpa사용하게 되면 필드만 수정하면된다.&lt;/li&gt;
  &lt;li&gt;데이터베이스의 구조를 생각치 않아도 DB의 구조를 생각해서 (조인및 insert를 알아서)패러다임을 만들어준다.&lt;/li&gt;
  &lt;li&gt;jpa의 연관관계,객체 그래프탐색을 자바에서 사용하듯 사용할수있다. 또한 신뢰할수있는 엔티티를 보장한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동일한 엔티티의 조회에서 트랜잭션을 보장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;성능 최적화 기능&lt;/li&gt;
  &lt;li&gt;1차 캐시와 동일성 보장&lt;/li&gt;
  &lt;li&gt;트랜잭션을 지원하는 쓰기 지연&lt;/li&gt;
  &lt;li&gt;지연로딩&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 21 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/spring/2021/01/21/jpa-concept-1/</link>
        <guid isPermaLink="true">http://localhost:4000/spring/2021/01/21/jpa-concept-1/</guid>
        
        <category>framework</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>3106</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;A진법 수 N을 입력 받아 B진법 수로 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;N에 사용되는 값은 0 ~ 9, A ~ Z이다.&lt;/p&gt;

&lt;p&gt;(2 &amp;lt;= A, B &amp;lt;= 36) ( 0&amp;lt;= N&amp;lt;= 263-1 )&lt;/p&gt;

&lt;p&gt;입력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 11010 8   
2 10110 10  
10 2543 16
16 ABC 8
0

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;32
22
9EF
5274
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;10 to 각진법 및 각진법 to 10을 조건으로 나누는것이 아니라 함수로 나누자(하나를 반환형을 인트형으로 하여)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;convert 함수에 0x30과 0x37을 더하여 만들어주는 방법으로 해결하였다. 이를 기억하자. 그리고 10 to 2,8,16은 k로 나눠주는 2,8,16 to 10은 문자열을 10진수로 바꾸는 것을 잘 기억하자.!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

char convert(int n){
	if(n &amp;lt; 10)
		return n+0x30;
	else 
		return n+0x37;
}

void intto(unsigned long long n, int b){
	char arr[1000] = {0,};
	int i= 0 ; 
	while(1){
		if(n&amp;lt;b){
			arr[i] = convert(n);
			break;
		}
		arr[i] = convert(n%b);
		n /= b;
		i++;
	}
	for(; i&amp;gt;=0; i--)
		cout &amp;lt;&amp;lt; arr[i];
	cout &amp;lt;&amp;lt;&quot;\n&quot;;
}

int invert(char n){
	if( '0' &amp;lt;= n &amp;amp;&amp;amp; '9'&amp;gt;=n)
		return n-0x30;
	else if ('A'&amp;lt;=n &amp;amp;&amp;amp; 'Z'&amp;gt;=n)
		return n-0x37;

	return 0;
}

unsigned long long toint(char n[] , int a){
	unsigned long long decimal = 0, tmp;
	int len;

	len = strlen(n);

	for(int i = len - 1; i&amp;gt;=0; i--){
		tmp = invert(n[i]);
		for(int j = 0; j&amp;lt;(len-i-1); j++)
			tmp *=a;

		decimal +=tmp;
	}
	return decimal;
}


int main(){

	int a,b;
	char n[100] = {0,};

	while(1){
		cin &amp;gt;&amp;gt; a;
		if(!a) break;

		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; b;

		intto(toint(n,a),b);
	}

	// in(n);
	// solv(str,n,k);
	// pr(n,k);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 02 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/02/jongol-3106/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/02/jongol-3106/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1901</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;소수(prime number)란 2이상의 수로써 1과 자기 자신 외에는 약수를 갖지 않는 수를 의미한다.&lt;/p&gt;

&lt;p&gt;임의의 M값에 대하여 M에 가장 가까운 소수를 구하는 프로그램을 아래 조건에 따라 작성한다.&lt;/p&gt;

&lt;p&gt;입력예시(각각) &lt;br /&gt;
2  &lt;br /&gt;
8  &lt;br /&gt;
15&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7 
13 17

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;isPrime을 가지고 배열에 저장하지 않고 동시에 출력하기.. 어떻게 할건가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;소수를 구하는것은 쉽다 그런데 배열을 사용하지 않고 두개의 값을 어떻게 나타낼지 고민하였고 끝내 실패하였는데 소수를 기준으로 동시에 i를 더해주고 빼주면 동시에 나아갈수있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

int arr[100][100];
int aa[100];

bool isPrime(int n){
    if(n &amp;lt; 2) return false;
    for(int i = 2; i&amp;lt;=n /i ; i++){
        if(n % i ==0) return false;
    }
    return true;
}

void pr(int n,int k){
	if(aa[k] != 0) cout &amp;lt;&amp;lt;aa[k];
	else cout &amp;lt;&amp;lt;0;
}

void solv(int n){
    if(isPrime(n)){
        cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt;endl;
        return;
    }

    int f=0;
    for(int i = 1 ; !f; i++){
        if(isPrime(n-i)){
            cout &amp;lt;&amp;lt; n-i &amp;lt;&amp;lt; &quot; &quot;;
            f++;
        }
        if(isPrime(n+i)){
            cout &amp;lt;&amp;lt; n+i;
            f++;
        }
    }
    cout &amp;lt;&amp;lt; &quot;\n&quot;;
}


void in(int n){
	for(int i = 1 ; i&amp;lt;=n; i++){
		cin &amp;gt;&amp;gt; aa[i];
	}
}

int main(){

	int n,m,k,res;
	cin &amp;gt;&amp;gt; n;

	// in(n);
	while(n&amp;gt;0){
		cin &amp;gt;&amp;gt; m;
		solv(m);
		n--;

	}
	// pr(n,k);
	return 0;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 02 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/02/jongol-1901/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/02/jongol-1901/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>2071</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;파스칼 삼각형이란 아래 &lt;표1&gt; 과 같은 자신의 왼쪽 위의 좌표와 오른쪽 위의 좌표 값을 더해서 값을 계속 갱신해 나가는 형태의 삼각형을 말한다.&lt;/표1&gt;&lt;/p&gt;

&lt;p&gt;아래와 같은 파스칼 삼각형의 높이 n과 종류 m을 입력 받은 후 다음과 같은 형태의 파스칼 삼각형을 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;입력예시(각각) &lt;br /&gt;
5 1 &lt;br /&gt;
6 3&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
1 1
1 2 1
1 3 3 1
1 4 6 4 1

----------
1
5 1
10 4 1
10 6 3 1
5 4 3 2 1
1 1 1 1 1 1

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for문을 어떻게 사용할것이냐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;기존의 파스칼 삼각형을 생각해낼수있었다. 하지만 이를 90도 회전하는것은 생각하지 못하였다.   &lt;br /&gt;
  어떻게 접근하였나면 1행을 3열로 작성하려고 접근하였고 각행은 j가 i까지 이므로 횟수를 주어 x,y가 아닌 y,x로 작성된것을 볼수있다. 기억하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i = 0; i&amp;lt;n; i++){
	for(int j = 0; j&amp;lt;i; j++){
		if( i == j || i ==0) arr[i][j] = 1;
		else arr[i][j] = arr[i-1][j-1] + arr[i-1][j];
	}
}

-----------------

for(int i = 0; i&amp;lt;n; i++){
	x = i;
	y = n-1;
	for(int j = 0 ; j&amp;lt;i; j++){
		cout&amp;lt;&amp;lt; arr[y][x];
		x--;
		y--;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-2071/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-2071/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1707</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;정사각형의 크기를 입력 받은 후 시계 방향으로 돌면서 다음과 같은 형태로 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&amp;lt; 처리조건 &amp;gt;&lt;/p&gt;

&lt;p&gt;(1) 가장 왼쪽 위의 좌표부터 차례로 숫자를 대입 시킨다.&lt;/p&gt;

&lt;p&gt;(2) 오른쪽으로 채워 나가다가 끝이면 다시 아래 → 왼쪽 → 위 →오른쪽의 순으로 모두 채워질 때까지 반복한다.&lt;/p&gt;

&lt;p&gt;입력예시(각각) &lt;br /&gt;
5&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;재귀이용하였다. 어떻게 하였냐?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;한방향으로 재귀를 돌리었다. 달팽이는 4방향이 존재하므로 네방향으로 재귀를돌리였고 삼각형달팽이를 푸니 풀렸다.. 짜맀했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

int n;
int tmp ;
int x=0,y=0,a,num,br,c=0;
int arr[100][100];

void Print(void){
	for(int i = 0 ; i &amp;lt;n ; ++i){
		for(int j = 0; j&amp;lt;n; j++){
			cout &amp;lt;&amp;lt; arr[i][j] &amp;lt;&amp;lt; &quot; &quot;;
		}
		cout &amp;lt;&amp;lt;endl;
	}
}

int re(int x, int y, int a, int num, int br)
{
	if( x &amp;lt; n &amp;amp;&amp;amp; x&amp;gt;=0 &amp;amp;&amp;amp; y&amp;lt;n &amp;amp;&amp;amp; y&amp;gt;=0 &amp;amp;&amp;amp; arr[x][y]==-1){
		arr[x][y] = a;
		if(num==1)
			re(x,++y,++a,num,0);
		if(num==2)
			re(++x,y,++a,num,0);
		if(num==3)
			re(x,--y,++a,num,0);
		if(num==4)
			re(--x,y,++a,num,0);
	} 
	else 
	{
		if(br&amp;gt;0) return 0;
		else if(num == 1) 
			re(++x,--y,a,2,br+1);
		else if(num == 2) 
			re(--x,--y,a,3,br+1);
		else if(num == 3) 
			re(--x,++y,a,4,br+1);
		else if(num == 4) 
			re(++x,++y,a,1,br+1);
	}
	return 0;
}

void Input(void){
	cin &amp;gt;&amp;gt; n ;
	tmp = n;
	for(int i = 0; i&amp;lt;n; ++i){
		for(int j = 0; j&amp;lt;n;++j){
			arr[i][j] = -1;
		}
	}
}

int main(){


	Input();
	re(0,0,1,1,0);
	Print();
	return 0;
}




&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-1707/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-1707/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1495</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;정사각형의 크기를 입력 받은 후 대각선으로 지그재그 형태인 다음과 같은 형태로 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&amp;lt; 처리조건&amp;gt;&lt;/p&gt;

&lt;p&gt;(1) 가장 왼쪽 위의 좌표부터 차례로 숫자를 대입시킨다.&lt;/p&gt;

&lt;p&gt;(2) 대각선을 기준으로 계속 지그재그 모양으로 채워져야 하며 숫자는 1씩 증가하는 형태로 채워나가야 한다.&lt;/p&gt;

&lt;p&gt;입력예시(각각) &lt;br /&gt;
3&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 3 4 
2 5 8 
6 7 9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for문을 어떻게 사용할것이냐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;지그제그를 드디어 풀었다. 물론 내힘으로 푼건 아니다… ㅠㅠ  &lt;br /&gt;
 c변수를 통해서 n번의 대각선에 접근하는게 포인트 같다. 포문으로 풀때는 c변수를 유동적으로 사용하여 이중포문이지만 i~n으로 접근한다.&lt;/p&gt;

&lt;p&gt;재귀로 풀때는 한칸내려올때, 대각선위로 올라갈때, 내려갈때, 위로 한칸위로 올라갈때를 유의해서 풀어야한다. 좌표를 이용해서 움직일땐 대각선이 중요하고 이를 보조해줄 세부 조건이 필요하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

int arr[100][100];

void Print(int n){
	for(int i = 0 ; i &amp;lt;n ; ++i){
		for(int j = 0; j&amp;lt;n; j++){
			cout &amp;lt;&amp;lt; arr[i][j]&amp;lt;&amp;lt; &quot; &quot;;
		}
		cout &amp;lt;&amp;lt;endl;
	}
}

void zigzeg(int n){
	int x = 0, y = 0,i,j,a=1,c=1;
	for(i = 0; i&amp;lt;n; i++){
		for(j = 0 ; j&amp;lt;c; j++)
			arr[x++][y--] = a++;
		y++;

		if(i==n-1) break;
		if(i&amp;gt;=n/2) {x--;y++;c--;}
		else c++;

		for(j =0; j&amp;lt;c; j++)
			arr[x--][y++] = a++;
		x++;
		if(i&amp;gt;=n/2) {x++;y--;c--;}
		else c++;
	}
}

int re(int n, int x, int y,int ct){
	if(cnt &amp;gt; n*n) return 0;
	if(arr[x][y]==0 &amp;amp;&amp;amp; x&amp;lt;n &amp;amp;&amp;amp; y&amp;lt;n &amp;amp;&amp;amp; x&amp;gt;=0 &amp;amp;&amp;amp; y&amp;gt;=0 &amp;amp;&amp;amp; cnt&amp;lt;=n*n){
		if(ct == 1){
			arr[x][y] = cnt++;
			re(n,++x,--y,ct);
		}
		if(ct == 2){
			arr[x][y] = cnt++;
			re(n,--x,++y,ct);
		}
	} else {
		if( ct == 1){
			if(cnt&amp;lt;=(n*n)/2){
				re(n,x,++y,2);
			} else re(n,++x,y+2,2);
		} else{
			if(cnt&amp;lt;=(n*n)/2){
				re(n,--x,y,1);
			} else re(n,x+2,--y,1);
		}
	}
	return 0;
}

void Input(int n){
	cin &amp;gt;&amp;gt; n ;
}

int main(){

	int n;
	cin &amp;gt;&amp;gt; n;
	// Input(n);
	zigzeg(n);
	Print(n);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-1495/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-1495/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1874</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;삼각형의 높이 N을 입력받아서 아래와 같이 문자 ‘A’부터 차례대로 왼쪽 대각선으로 채워서 삼각형 모양을 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&amp;lt; 처리조건 &amp;gt;&lt;/p&gt;

&lt;p&gt;(1) 오른쪽 위부터 왼쪽 아래쪽으로 이동하면서 문자 ‘A’부터 차례대로 채워나간다.&lt;/p&gt;

&lt;p&gt;(2) N번 행까지 채워지면 다시 오른쪽 둘째 행부터 왼쪽 아래로 채워나간다.&lt;/p&gt;

&lt;p&gt;(3) 삼각형이 모두 채워질 때까지 반복하면서 채워 나간다. (문자 ‘Z’다음에는 ‘A’부터 다시 시작한다.)&lt;/p&gt;

&lt;p&gt;입력예시 &lt;br /&gt;
5&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    A    
   BF   
  CGJ   
 DHKM   
EILNO
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for문을 어떻게 사용할것이냐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;

&lt;p&gt;2차원 char 배열에 어떻게 채울지 정확하게 구상해야한다. &lt;br /&gt;
포문을 이용하여 공백을 포함해서 구현하였고 포문에 변수 2개 이상들어간다는 생각도 할수있어야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;

#define endl '\n'
using namespace std;

int n,m;
char arr[100][100];

void Print(){
	for(int i = 1 ; i &amp;lt;=n ; ++i){
		for(int j = 1; j&amp;lt;=n; j++){
			if(arr[i][j]=='\0'){
				cout &amp;lt;&amp;lt; &quot; &quot;;
			}
			cout &amp;lt;&amp;lt; arr[i][j];
		}
		cout &amp;lt;&amp;lt;endl;
	}
}

void fill_string(){
	int i, j, k;
	char alpha = 'A';
	for(i = 1; i&amp;lt;=n; i++){
		for( j = i, k = n; j&amp;lt;=n ; j++, k--){
			arr[j][k] = alpha++;
			if(alpha &amp;gt; 'Z')
				alpha = 'A';
		}
	}
}

void Input(){
	cin &amp;gt;&amp;gt; n ;
}

int main(){

	Input();
	fill_string();
	Print();

	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-1338/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-1338/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1337</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;삼각형의 높이 N을 입력받아서 아래와 같이 문자 ‘A’부터 차례대로 왼쪽 대각선으로 채워서 삼각형 모양을 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&amp;lt; 처리조건 &amp;gt;&lt;/p&gt;

&lt;p&gt;(1) 오른쪽 위부터 왼쪽 아래쪽으로 이동하면서 문자 ‘A’부터 차례대로 채워나간다.&lt;/p&gt;

&lt;p&gt;(2) N번 행까지 채워지면 다시 오른쪽 둘째 행부터 왼쪽 아래로 채워나간다.&lt;/p&gt;

&lt;p&gt;(3) 삼각형이 모두 채워질 때까지 반복하면서 채워 나간다. (문자 ‘Z’다음에는 ‘A’부터 다시 시작한다.)&lt;/p&gt;

&lt;p&gt;입력예시 &lt;br /&gt;
6&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0
4 1
3 5 2
2 0 6 3
1 9 8 7 4
0 9 8 7 6 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for문을 어떻게 사용할것이냐&lt;/li&gt;
  &lt;li&gt;재귀를 이용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;포문을 이용하는 방법및 재귀를 이용하는 방법은 동일하다. 좌표를 어떻게 움직일것인지 생각하고 이를 이차원 배열로 구현해야한다. &lt;br /&gt;
  우선 한방향으로만 간다는 점이다. 3개의 조건이면 풀수있으며 기저조건은 배열내부에 존재할때이다. 이를 위해서 배열을 초기화하는 작업도 필요하다. &lt;br /&gt;
  한방향으로 가는것과 이를 벗엇났을때의 다른 방향으로 가는 방법으로 풀수있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

int n;
int tmp ;
int x=0,y=0,a,num,br,c=0;
int arr[100][100];

void Print(void){
	for(int i = 0 ; i &amp;lt;tmp ; ++i){
		for(int j = 0; j&amp;lt;=i; j++){
			cout &amp;lt;&amp;lt; arr[i][j];
		}
		cout &amp;lt;&amp;lt;endl;
	}
}




int re(int x, int y, int a, int num, int br)
{
	if( x &amp;lt; n &amp;amp;&amp;amp; x&amp;gt;=0 &amp;amp;&amp;amp; y&amp;lt;n &amp;amp;&amp;amp; y&amp;gt;=0 &amp;amp;&amp;amp; arr[x][y]==-1){
		arr[x][y] = a % 10;
		if(num==1)
			re(++x,++y,++a,num,0);
		if(num== 2)
			re(x,--y,++a,num,0);
		if(num==3)
			re(--x,y,++a,num,0);
	} 
	else 
	{
		if(br&amp;gt;0) return 0;
		else if(num == 1) 
			re(x-1,y-2,a,2,br+1);
		else if(num == 2) 
			re(x-1,y+1,a,3,br+1);
		else if(num == 3) 
			re(x+2,y+1,a,1,br+1);
	}
	return 0;
}
void mainfo(){
	int m = 0;
	while(arr[x][y] == -1){
		
		for(;x&amp;lt;n; x++){
		if(arr[x][y]!=-1) break;
		arr[x][y++] = (c++) % 10;
		}
		x--;
		y-=2;
		if(arr[x][y]!=-1) break;
		
		for(;y&amp;gt;=m; y--){
			if(arr[x][y]!=-1) break;
			arr[x][y] = (c++) % 10;
		}
		x--;
		y++;
		if(arr[x][y]!=-1) break;
		
		for(; x&amp;gt;m; x--){
			if(arr[x][y]!=-1)
				break;
			arr[x][y]=(c++)%10;
   		 }
		x+=2;
		y++;
	}
}

void Input(void){
	cin &amp;gt;&amp;gt; n ;
	tmp = n;
	for(int i = 0; i&amp;lt;n; ++i){
		for(int j = 0; j&amp;lt;=i;++j){
			arr[i][j] = -1;
		}
	}
}

int main(){


	Input();
	//re(0,0,0,1,0);
	mainfo();
	Print();
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-1337/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-1337/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>1331</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;problem solving&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;
&lt;p&gt;마름모의 한 변의 길이 N을 입력 받아 아래와 같이 문자 마름모를 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&amp;lt; 처리조건 &amp;gt;&lt;/p&gt;

&lt;p&gt;(1) 첫 번째 행의 중앙부터 출발하여 시계 반대 방향으로 ‘A’ 부터 차례대로 채워나간다. (‘Z’다음에는 다시 ‘A’가 된다.)&lt;/p&gt;

&lt;p&gt;(2) 바깥 부분이 다 채워지면 두 번째 행 중앙부터 다시 같은 작업을 반복한다.&lt;/p&gt;

&lt;p&gt;(3) 같은 방법으로 마름모를 다 채워지도록 하여 출력한다.&lt;/p&gt;

&lt;p&gt;입력예시 &lt;br /&gt;
5&lt;/p&gt;

&lt;p&gt;출력예시&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      A
    B M L
  C N U T K
D O V Y X S J
  E P W R I
    F Q H
      G
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;질문&quot;&gt;질문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for문을 어떻게 사용할것이냐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;
&lt;p&gt;접근법은 n주어졌을때 어떻게 배열을 설정할지와 포문과 x,y좌표를 통해 구현하였다. &lt;br /&gt;
 좌표들을 증감시켜주는 방식으로 좌표를 움직였으며 이를 통해서 마름모를 구할수있다. &lt;br /&gt;
 나는 재귀를 통해서 구하려다 내부 마름모구해지지 않았는데 내부마름모는 y좌표를 잘 이용하였다면 구할수있었다.&lt;/p&gt;

&lt;p&gt;추후에 재귀로 다시 구현해보자&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;string&amp;gt;
#define endl '\n'
using namespace std;

char arr[100][100];

char make_num(){
    static int a=0;   
    char b;
    b=((a++)%26)+'A';
    return b; 
}

void Print(int n){
	for(int i = 0 ; i &amp;lt;2*n ; ++i){
		for(int j = 0; j&amp;lt;2*n; j++){
			if(arr[i][j]=='\0'){
				cout&amp;lt;&amp;lt;&quot;  &quot;;			
			}
			else cout &amp;lt;&amp;lt; arr[i][j]&amp;lt;&amp;lt; &quot; &quot;;
		}
		cout &amp;lt;&amp;lt;endl;
	}
}

void square(int n){
	int x = 0, y= n-1, c1 = 1, c2 = n,i;

	for(i = 0; i&amp;lt;n; i++){
		while(x&amp;lt;c2) arr[x++][y--] = make_num();
		y+=2;

		while(x&amp;lt;(2*c2)-c1) arr[x++][y++] = make_num();
		x-=2;

		while(y&amp;lt;(2*c2)-c1) arr[x--][y++] = make_num();
		y-=2;

		while(y&amp;gt;=c2) arr[x--][y--] = make_num();
		x++;
		c1++;
	}
}


void Input(int n){
	cin &amp;gt;&amp;gt; n ;
	for(int i = 0 ; i &amp;lt;=2*n ; ++i){
		for(int j = 0; j&amp;lt;=2*n; j++){
			arr[i][j] = -1;
		}
	}
}

int main(){

	int n;
	cin &amp;gt;&amp;gt; n;
	// Input(n);
	square(n);
	Print(n);
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 01 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/ps/2020/12/01/jongol-1331/</link>
        <guid isPermaLink="true">http://localhost:4000/ps/2020/12/01/jongol-1331/</guid>
        
        <category>jongol</category>
        
        
        <category>PS</category>
        
      </item>
    
      <item>
        <title>Ch.16-4-Bit Mask</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;164-문제-졸업학기문제idgraduation난이도중&quot;&gt;16.4 문제: 졸업학기(문제ID:GRADUATION,난이도:중)&lt;/h1&gt;

&lt;h2 id=&quot;책에-제시된-풀이&quot;&gt;책에 제시된 풀이&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이문제를 푸는 한가지 자연스러운 방법은 각 학기를 한조각으로 쪼개는 것입니다.
    &lt;blockquote&gt;
      &lt;p&gt;graduate(semester,taken) = 현재학기가 semester이고, 지금까지 들은 과목의 집합이 taken일때, 앞으로 다녀야 하는 최소학기의 수는?&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;graduate()를 완전 탐색으로 구현하는 방법은 각 학기마다 들을 수 있는 모든 과목의 조합들을 하나하나 시도해 보는 것입니다.&lt;/li&gt;
  &lt;li&gt;이번 학기에 개설되면서 선수 과목을 모두 들은 과목들중, L개 이하의 모든 조합을 시도하는것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;아래코드에서 눈여겨 봐야 할 포인트&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;어떤 과목의 선수과목을 이미 전부 들었는지를 확인하는 작업이 아주 간단합니다.
      &lt;ul&gt;
        &lt;li&gt;taken과 prerequisite[i]의 교집합이 prerequisite[i]와 같은지만 확인하면 됩니다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;canTake에서 아직 선수 과목을 다 듣지 않아 들을 수 없는 과목들을 미리 걸러 냅니다.
      &lt;ul&gt;
        &lt;li&gt;결과적으로 이번 학기에 들을 수 있는 과모감ㄴ이 canTake에 남기 때문에, 이 집합의 부분 집합을 순회하기만하면 됩니다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;이미 들은 과목의 수나 이번 학기에 들은 과목의 수를 세기 위해 비트의 수를 세는 함수 bitCount()를 사용했습니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;canTake의 모든 부분집합을 순회하려면 최대2^C_i의 시간이 걸립니다.&lt;/li&gt;
  &lt;li&gt;전체 M&lt;em&gt;2^N 개의 부분 문제가 있으므로 프로그램의 전체 시간 복잡도는 O(M&lt;/em&gt;2^(N+C))가 됩니다.&lt;/li&gt;
  &lt;li&gt;입력의 최대치를 대입해보면 이 값은 대략 4천만으로, 충분히 시간내에 계산할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;

using namespace std;
const int MAXN = 12;
const int INF = 987654321;
int n, k , m , l;

// prerequisite[i] = i번째 과목의 선수과목의 집합
int prerequisite[MAXN];
// classes[i] = i번째 학기에 개설되는 과목의 집합
int classes[10];
int cache[10][1&amp;lt;&amp;lt;MAXN];

// n의 이진수 표현에서 켜진 비트의 수를 반환한다.
int bitcount(int n){
  if(n == 0) return 0;
  return n%2 + bitcount(n/2);
}
// 이번학기가 semester이고, 지금까지 들은 과목의 집합이 taken일때
// k개 이상의 과목을 모두 들으려면 몇 학기 더 있어야 하는가?
// 불가능한 경우 INF를 반환한다.
int graduate(int semester, int taken){
  // 기저사례: k개 이상의 과목을 이미 들은경우
  if(bitcount(taken) &amp;gt; = k) return 0;
  // 기저사례: m학기가 전부 지난 경우
  if(semester == m) return INF;
  // 메모이제이션
  int&amp;amp; ret = cache[semester][taken];
  if(ret != -1)return ret;
  ret =  INF;
  // 이번 학기에 들을 수 있는 과목중 아직 듣지 않은 과목들을 찾는다.
  int canTake = (classes[semester] &amp;amp; ~taken);
  for(int i = 0; i&amp;lt;n ; ++i)
    if((canTake &amp;amp; (1 &amp;lt;&amp;lt; i)) &amp;amp;&amp;amp; (taken &amp;amp; prerequisite[i]) != prerequisite[i])
    canTake &amp;amp;= ~(1&amp;lt;&amp;lt;i);
  for(int take = canTake; take &amp;gt; 0 ; take = ((take - 1) &amp;amp; canTake)){
    if(bitcount(take) &amp;gt; l ) continue;
    ret = min(ret, graduate(semester+1, taken | take) + 1);
  }
  ret = min(ret, graduate(semester+1,taken));
  return ret;
}

int main(){
  int tc;
  cin &amp;gt;&amp;gt; tc;
  while(tc--){
    int cnt, tmp;
    memset(cache, -1, sizeof(cache));
    memset(prerequisite, 0, sizeof(prerequisite));
    memset(classes,0, sizeof(classes));
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l;
    for(int i = 0; i&amp;lt;n ; ++i){
      cin &amp;gt;&amp;gt; cnt;
      for(int j = 0; j&amp;lt;cnt ; ++j){
        cin &amp;gt;&amp;gt; tmp;
        prerequisite[i] |= (1&amp;lt;&amp;lt;tmp);
      }
    }
    int _cnt;
    for(int i = 0; i&amp;lt;m; ++i){
      cin &amp;gt;&amp;gt; _cnt;
      for(int j = 0; j &amp;lt; _cnt; ++j){
        cin &amp;gt;&amp;gt;tmp;
        classes[i] |= (1&amp;lt;&amp;lt; tmp)'
      }
    }
    int ret = graduate(0,0);
    if(ret == INF)cout &amp;lt;&amp;lt;&quot;IMPOSSIBLE&quot;&amp;lt;&amp;lt;endl;
    else cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt;endl;
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 17 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/2020/10/17/jmb-16-4/</link>
        <guid isPermaLink="true">http://localhost:4000/book/2020/10/17/jmb-16-4/</guid>
        
        <category>JMB</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>Ch.16-3-Bit Mask</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;지수-시간-동적-계획법&quot;&gt;지수 시간 동적 계획법&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 절에서는 배열 대신 정수로 집합을 표현하면 이것을 곧장 배열의 인덱스로 쓸 수 있다는 점을 이용합니다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;따라서 메모이제이션의 구현 또한 간단해집니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;에라토스테네스의-체&quot;&gt;에라토스테네스의 체&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;에라토스테네스의 체는 굉장히 빠르게 동작하기 때문에, 수행 범위를 늘릴 때 부담이 되는것은 수행시간보다는 메모리였습니다.&lt;/li&gt;
  &lt;li&gt;체를 구현할 때는 범위 내의 각 정수가 지워졌는지 여부를 저장해야 하는데, 14.2 절에서 이것을 불린 값 배열을 이용해 표현했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고로, bool x = true; 라고 선언된 boolean은 1bit를 표현하지만 메모리는 1바이트를 잡아먹습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;32 비트 정수가 표현할 수 있는 범위 내의 모든 수에 대해 체를 수행한다고 합시다.&lt;/li&gt;
  &lt;li&gt;불린 값 배열을 이요하면 4기가 바이트(2^32 byte)의 메모리를 써야 합니다.&lt;/li&gt;
  &lt;li&gt;짝수를 제외해 2기가바이트로 줄일 수도 있지만, 여전히 적지 않은 양입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이때 비트마스크를 사용하면 메모리 사용량을 8분의 1로 다시 줄일 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MAX_N개의 원소를 닺는 불린 값 배열을 다음과 같은 배열로 대체합시다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unsigned char sieve[(MAX_N + 7) / 8];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이 배열은[MAX_N/8] 바이트만을 써서 MAX_N개의 원소를 갖는 불린 값 배열을 구현합니다.&lt;/li&gt;
  &lt;li&gt;이때 k번 원소가 참인지를 알기 위해서는 k/8번째 원소의 k%8번째 비트가 켜져있는지를 확인하면 됩니다.&lt;/li&gt;
  &lt;li&gt;이들이 비트 연산을 이용해 나눗셈과 나머지 연산을 구현하는 것을 눈여겨봅시다.&lt;/li&gt;
  &lt;li&gt;정수를 오른쪽으로 3비트 시프트하는것은 8로 나눈는 것과 같고, 7과 AND연산하는것은 8로 나눈 나머지를 구하는것과 같기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unsigned char x = 0;
x : 0x00 ==&amp;gt; 0000 0000 (2진수로 총 8개의 비트)
하나의 바이트에 숫자 8개에 대한 on/off 즉, bool로 사용할 수 있다.
- 7이 소수인지 확인하는 방법은 아래와 같다.
- return sieve[ 7 &amp;gt;&amp;gt; 3 ] &amp;amp; (1&amp;lt;&amp;lt; (7 &amp;amp; 7)));
    -&amp;gt;   sieve[   0    ] &amp;amp; (1000 0000(2진수)) =&amp;gt; 결국 , sieve[0] 값 중 7번째에 해당하는 비트 1
    써져있으면 1을 리턴, 0이 써져 있으면 0을 리턴하게 된다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int n;
unsigned char sieve[(MAX_N + 7)/ 8 ];
//k가 소수인지 확인한다.

inline bool isPrime(int k) {
  return sieve[k &amp;gt;&amp;gt; 3] &amp;amp; (1 &amp;lt;&amp;lt; (k &amp;amp; 7))'
}
// k가 소수가 아니라고 표시한다.
inline void setComposite(int k){
  sieve[ k &amp;gt;&amp;gt; 3]  &amp;amp;= ~( 1&amp;lt;&amp;lt; (k &amp;amp; 7));
}
// 비트마스크를 사용하는 에라토스테네스의 체의 구현
// 이 함수를 수행하고 난 뒤, isPrime()을 이용해서 각 수가 소수인지 알 수 있다.
void eratosthenes(){
  memset(sieve, 255, sizeof(sieve));
  setComposite(0);
  setComposite(1);
  int sqrtn = int(sqrt(n));
  for( int  i = 2; i&amp;lt;sqrtn; i++)
    // 이 수가 아직 지워지지 않았다면
    if(isPrime(i))
      // i의 배수 j들에 대해 isPrime[j] = false로 둔다.
      // i*i 미만의 배수는 이미 지워졌으므로 신경쓰지 않는다.
      for(int j = i*i; j&amp;lt;=n; j+=i)
        setComposite(j);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;15퍼즐-상태-표현하기&quot;&gt;15퍼즐 상태 표현하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;비트마스크를 이용하여 표현해야 하는 값의 범위가 작을 때는, 2비트씩, 3비트씩 묵어서 배열로 쓸 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;15퍼즐의 상태는 0부터 15까지의 숫자가 들어있는 4x4크기의 배열로 표현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;각 숫자는 4비트로 표현할 수 있고, 15개의 숫자가 있기 때문에 비트마스크를 사용하면 이 배열 전체를 64비트 정수 하나로 표현할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef unsigned long long uint64;
// mask의 index 위치에 쓰인 값을 반환한다.
int get(uint64 mask, int index){
return (mask &amp;gt;&amp;gt; (index &amp;lt;&amp;lt; 2)) &amp;amp; 15;
}
// mask의 index 위치를 value로 바꾼 결과를 반환한다.
uint64 set(uint64 mask, int index, uint64 value){
return mask &amp;amp; ~(15LL &amp;lt;&amp;lt; (index &amp;lt;&amp;lt;2) | (value &amp;lt;&amp;lt; ( index &amp;lt;&amp;lt; 2 ));
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;get함수 (index = 10 라고 한다면)
return (mask &amp;gt;&amp;gt; (index &amp;lt;&amp;lt; 2 )) &amp;amp; 15;
        mask &amp;gt;&amp;gt; (10을 왼쪽으로 2번 shift하면 40이 된다.)
        mask를 오른쪽으로 40칸 shift한 결과의 1111(15)와 AND연산
        0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
        0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   (번째 숫자)

- mask의 최상위 비트를 40번 우측으로 shift하고 1111과 AND연산 한다면, 10번째 index의 값을 가젝 되어 get의 역할을 수행한다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;o1-우선순위-큐&quot;&gt;O(1) 우선순위 큐&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;우선순위 큐는 원소 중에서 우선순위가 가장 높은 원소를 빠르게 찾아낼 수 있는 자료구조입니다.&lt;/li&gt;
  &lt;li&gt;이 우선순위 큐에 자료를 추가하거나 삭제하는 작업은 N개의 원소가 있을 때 O(logN)의 시간이 걸립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;그런데 우선순위가 특정 범위로 제한되어 있을경우 비트마스크를 이용하면 모든 작업을 O(1)에 할 수 있는 우선순위 큐를 만들 수 있습니다.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;예를 들어 우리가 큐에 넣는 원소의 우선순위가 1이상 140이하의 정수하고 합시다.&lt;/li&gt;
    &lt;li&gt;각 우선순위를 갖는 원소들을 담는 140개의 큐를 만들고, 각 큐에 원소가 있는지 여부를 비트마스크로 표현합시다.&lt;/li&gt;
    &lt;li&gt;140 개의 불린값을 64비트 정수 세개에 저장하면 첫 번째 비트를 찾는 연산을 이용해 모든큐를 뒤질 필요 없이 가장 우선순위가 높은 원소가 어디에 있는지를 쉽게 찾을 수 있습니다.&lt;/li&gt;
    &lt;li&gt;이와 같은 우선순위 큐는 실제로 리눅스 커널의 프로세스 관리를 위해 사용된 적이 있습니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;queue&amp;lt;int&amp;gt; pq[140];

//  140개의 불린 값 -&amp;gt; 64*3 = 192, uint64를 통해 index 사용가능
uint64 x[3]; // 140개의 불린 값을 64비트 정수 세 개에 저장
// .... .... 1000 0000 으로 표시되어 있는경우, 8번째 우선순위를 갖는 녀석이 on 되어 있다고 확인할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;예제--극대-안정-집합&quot;&gt;예제 : 극대 안정 집합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;N(N&amp;lt;=20)개의 화학물질을 운반해야 한다고 하자.&lt;/li&gt;
  &lt;li&gt;각 화학 물질은 무해하지만, 같이 두었을 때 서로 반응해 폭발하는 물질들이 있습니다.&lt;/li&gt;
  &lt;li&gt;이때 한 상자에 넣어도 폭발하지 않는 물질의 집합을 안정적이라고 부릅시다.&lt;/li&gt;
  &lt;li&gt;물질이 하나만 있는 집합은 항상 안정적입니다.&lt;/li&gt;
  &lt;li&gt;때문에 안정된 집합은 여러개가 있을 수 있는데, 그중 물질을 하나라도 추가하면 폭발이 일어나는 집합들을 극대 안정 집합이라고 부릅니다.&lt;/li&gt;
  &lt;li&gt;극대 안정 집합 또한 여러개가 있을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;예를들어 4개의 화학물질 a,b,c,d가 있는데 a와 b를 같은 상자에 넣거나, c와 d를 같은 상자에 넣으면 폭발한다고 합니다.
    &lt;ul&gt;
      &lt;li&gt;그러면 다음과 같은 4개의 극대 안정 집합이 있을 겁니다.&lt;/li&gt;
      &lt;li&gt;{a,c}, {a,d}, {b,c}, {b,d}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 화학 물질의 정보가 주어질 때 극대 안정 집합의 수를 세는 코드를 작성해 봅시다.&lt;/li&gt;
  &lt;li&gt;아래 코드 중 어떤 안정 집합에 다른 원소 add를 넣을 수 있는지를 isStable()를 다시 호출하는 대신 explodes[add] &amp;amp; set이 0인지만 확인하는 것을 눈여겨 보세요.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int n;
int explodes[MAXN];
bool isStable(int set){
for(int i = 0; i&amp;lt;n ;i ++)
  if((set &amp;amp; (1&amp;lt;&amp;lt;i))&amp;amp;&amp;amp; (set &amp;amp; explodes[i]))
    return false;
return true;
}
int countStableSet(){
int ret = 0;
for(int set = 1; set &amp;lt; (1&amp;lt;&amp;lt;n); ++set){
  if(!isStable(set)) continue;
  bool canExtend = false;
  for(int addd = 0; add &amp;lt;n; ++add)
    if((set &amp;amp; (1 &amp;lt;&amp;lt;add )) &amp;amp;&amp;amp; (explodes[add] &amp;amp; set == 0)){
      canExtend = true;
      break;
    }
  if(!canExtend)
    ++ret;
}
return ret;
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 17 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/2020/10/17/jmb-16-3/</link>
        <guid isPermaLink="true">http://localhost:4000/book/2020/10/17/jmb-16-3/</guid>
        
        <category>JMB</category>
        
        
        <category>book</category>
        
      </item>
    
      <item>
        <title>Ch.16-2-Bit Mask</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;비트마스크를-이용한-집합의-구현&quot;&gt;비트마스크를 이용한 집합의 구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;비트 마스크의 가장 중요한 사용 사례는 집합을 구현하는 것입니다.
    &lt;ul&gt;
      &lt;li&gt;이 표현에서 N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예를들어 {1,4,5,6,7,9}을 표현하는 정수는 754임을 다음과 같이 알수있습니다.&lt;/li&gt;
  &lt;li&gt;2^1+2^4+2^5+2^6+2^7+2^9 = 10 1111 0010 = 754&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;피자집-예제&quot;&gt;피자집 예제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;고객들이 원하는 토핑을 골라 주문할 수 있는 피자집의 주문 시스템을 만든다고 합시다.&lt;/li&gt;
  &lt;li&gt;이 피자집에는 0부터 19까지의 번호를 갖는 스무가지 토핑이 있고, 주문시 토핑을 넣기/넣지않기를 선택할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공집합과-꽉-찬-집합-구하기&quot;&gt;공집합과 꽉 찬 집합 구하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;토핑을 올리지 않은 피자는 상수 0으로 나타냅니다.&lt;/li&gt;
  &lt;li&gt;‘전부 다’피자는 아래와 같이 표현할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int fullPizza = (1&amp;lt;&amp;lt;20) -1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;1«20은 이진수로 1뒤에 20개의 0이 있는 정수인데, 여기서 1을 빼면 20개의 비트가 모두 켜진 숫자를 얻을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;원소-추가&quot;&gt;원소 추가&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;집합의 가장 기초적인 연산은 원소를 추가하고 삭제하는 것입니다.&lt;/li&gt;
  &lt;li&gt;토핑중 하나인 페퍼로니(p)(0&amp;lt;=p&amp;lt;20)은 아래와 같이 추가할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;topping |= (1 &amp;lt;&amp;lt;p);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;원소의-포함-여부-확인&quot;&gt;원소의 포함 여부 확인&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(toppings &amp;amp; (1&amp;lt;&amp;lt;p)) cout &amp;lt;&amp;lt;&quot;pepperoni is in&quot;&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&amp;amp;연산의 결과값이 0 또는 1 « p라는 점에 유의하세요.&lt;/li&gt;
  &lt;li&gt;대부분의 논리 연산처럼 원소가 포함되어 있는경우 1, 혹은 true를 반환한다고 생각하면 아래와 같은 코드를 작성하는 실수를 범함니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//제대로 동작하지 않음!
if((toppings &amp;amp; (1&amp;lt;&amp;lt;p)) == 1 ) cout &amp;lt;&amp;lt;&quot;pepperoni is in &quot; &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;원소의-삭제&quot;&gt;원소의 삭제&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;toppings -= (1&amp;lt;&amp;lt;p);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;만약 페퍼로니가 없는데 위와같은 코드를 쓰면 큰일납니다.&lt;/li&gt;
  &lt;li&gt;토핑이 없을때도 정상적으로 동작하는 방법은 다음돠 같은 코드를 사용하는 것입니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;toppings &amp;amp;= ~(1&amp;lt;&amp;lt;p);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;원소의-토글&quot;&gt;원소의 토글&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;토글은 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜는 것이며 XOR이 이와 같은 일을 합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;toppings ^= (1&amp;lt;&amp;lt;p);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;두-집합에-대해-연산하기&quot;&gt;두 집합에 대해 연산하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;토핑 집합 a 와 b에 대하여
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int added = (a | b);        // a와 b의 합집합
int intersection = (a &amp;amp; b); // a와 b의 교집합
int removed = (a &amp;amp; ~b);     // a에서 b를 뺀 차집합
int toggled = (a ^ b);      // a와 b중 하나에만 포함된 원소들의 집합
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;집합의-크기-구하기&quot;&gt;집합의 크기 구하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가장 간단한 방버은 각 비트를 순회하면서 켜저있는 비트를 직접 세는 것입니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int bitCount(int x){
  if(x == 0) return 0;
  return x % 2 + bitCount(x / 2);
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 프로그래밍 환경에서 이와 관련된 내장 명령어를 제공합니다.&lt;/li&gt;
  &lt;li&gt;다음 목록은 32 비트 부호 없는 정수 toppings에 켜진 비트의 수를 구하는 코드를 각 언어 혹은 컴파일러 별로 보여줍니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc/g++ __builtin_popcount(toppings)
Visual C++ __popcnt(toppings)
java Integer.bitCount(toppings)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;최소-원소-찾기&quot;&gt;최소 원소 찾기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이 연산은 “이 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇개인가?”와 같은 의미입니다.&lt;/li&gt;
  &lt;li&gt;켜져 있는 최하위 비트 미틔 비트들은 전부 0일테니, 이 연산은 켜져 있는 최하위 비트의 번호를 반환하게 됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc/g++ __builtin_ctz(toppings)
Visual C++ _BitScanForward(&amp;amp;index, toppings)
java Integer.numberOfTrailingZeros(toppings)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 보수를 이용한 방법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int firstTopping = ( toppings &amp;amp; -toppings);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;이것은 대두분의 컴퓨터가 음수를 표현하기 위해 2의보수를 사용한다는 점을 이용합니다.&lt;/li&gt;
      &lt;li&gt;2의 보수를 사용하는 시스템에서는 음수 -toppings를 표현하기 위해서는 toppings에 NOT연산을 적용후 1을 더하여 2의보수를 만들어냅니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;최소원소-지우기&quot;&gt;최소원소 지우기&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;topping &amp;amp;= ( toppings -1 );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;toppings-1의 이진수 표현은 toppings에서 켜져 있는 최하위 비트를 끄고 그 밑의 비트들은 전부 켠 컷입니다.&lt;/li&gt;
  &lt;li&gt;따라서 두 값을 비트별 AND 연산하면 최하위 비트와 그 이하의 비트들을 전부 0이 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모든-부분-집합-순회하기&quot;&gt;모든 부분 집합 순회하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;또 하나 아주 유용한 팁은 주어진 집합의 모든 부분 집합을 순회 하는 것입니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int subset = pizza; subset; subset = ((subset -1) &amp;amp; pizza){
  //subset은 pizza의 부분집합
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;subset에서 1을 빼면 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜지게 됩니다.&lt;/li&gt;
  &lt;li&gt;이 결과와 pizza의 교집합을 구하면 그중 pizza에 속하지 않는 비트들은 모두 꺼지게 됩니다.&lt;/li&gt;
  &lt;li&gt;for문은 subset = 0인 시점에서 종료하므로 공집합은 방문하지 않는다는 점을 깜박하지 않도록 합시다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 17 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/book/2020/10/17/jmb-16-2/</link>
        <guid isPermaLink="true">http://localhost:4000/book/2020/10/17/jmb-16-2/</guid>
        
        <category>JMB</category>
        
        
        <category>book</category>
        
      </item>
    
  </channel>
</rss>

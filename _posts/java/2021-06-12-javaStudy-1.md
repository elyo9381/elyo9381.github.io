---
layout: post
title: javaStudy-1
subtitle: "study, java"
categories: book
tags: java
comments: true
---
> 자바 스터디 



# 목표
  - 자바 소스파일(.java)을 JVM으로 실행하는 과정이해하기

# 학습할 것 
  - JVM 이란 무엇인가
  - 컴파일 하는 방법
  - 실행하는 방법
  - 바이트코드란 무엇인가.
  - JIT 컴파일이란 무엇이며 어떻게 동작하는지
  - JVM 구성요소
  - JDK와 JRE의 차이




----
JVM이란 무엇인가.
====


  **정의**   

 자바 컴파일러는 .java 파일을 .class파일로 변환한다. 하지만 바이트코드는 기계어가 아니기 때문에 OS에서 실행되지 못한다.   
 바이트코드가 os에서 실행되도록 도움을 주는 녀석이 JVM이다.
    
 JVM은 바이트코드를 해석해 os에서 실행할수있도록 도와주는 가상머신이다.


----
바이트코드
====
  
  **정의**
  
  자바 파일을 컴파일하여 생성되는 .class 파일을 바이트 코드라고 한다. 

  바이트코드는 JVM이 이해하고 OS에 관계없이 실행될수있는 장점이 존재한다. 


----
컴파일 하는 방법
====

  **정의**

  - 고수준의 소스코드를 저수준의 코드로 변환하는 작업
  - 어떠한 소스코드를 기계어로 변환하는 작업

  **방법**

  javac 를 통해서 컴파일 할수있다.

  1. 자바파일을 생성한다.
  2. CLI 환경에서 자바를 설치한다.
  3. javac HelloWorld.java : 명령어를 수행한다.
  
  - -d : class을 생성할 root 디렉터리를 지정
  - -sourcepath : compile하기 위해 필요로 하는 참조할 source file 위치를 지정
  - -g : 디버깅 정보를 생성
  - -verbose : 컴파일와 링커가 현재 어느 소스파일이 컴파일 되고 있고, 어느 파일에 링크되고 있는지 정보 출력
  - -target : 지정된 java 버전의 JVM에서 작동되도록 .class 파일을 생성


----
JIT컴파일러란 무엇이며 어떻게 동작하는가?
====

**정의**

프로그램을 실제 실행하는 시점에 기계어로 번역하는 compile기법

**동작 과정**

JIT compiler는 실행 시점에서 인터프리터 방식으로 기계어 코드를 생성하면서 그 코드를 `캐싱`하여, 같은 함수가 여러번 불릴때 매번 기계어 코드 생성을 방지한다.

즉, java compiler가 java 프로그램 코드를 -> 바이트코드로 변환한 다음 -> 실제 바이트코드를 실행하는 시점에서 JVM이 JIT 컴파일을 통해 바이트코드를 기계어로 번역한다.

  
**Interpreter와 JIT Compiler 비교**

  - Interpreter
    자바 바이트코드를 한줄씩 실행, 여러번 실행하는 환경에선 다소 느림
  - JIT Compiler
    인터프리터의 단점을 보완, 전제 바이트코드를 컴파일, 캐시사용으로 한번 컴파일 하면 다음에는 빠르게 수행너무 불편한데 안그러냐 ? 

> sourceCode.java -> Compiler -> ByteCode -> JIT Compiler -> Native machineCode  


----
JVM 구성요소
====

> ## 1. class Loader

 **정의**
   - runTime시점에 .class에서 바이트코드를 읽고 메모리에 저장

 **클래스로더**
   - was에 웹앱이 올라간 경우 상위 클래스 class loader로 class를 -> 메모리에 올려 놓으면 설사 class가 잘못됐다 하더라도 프로그램을 종료하지 않고선 정보를 지우는 방법이 따로 없다.    
   
        만약, 번경된 클래스가 적용되게 하려면?

        user Define class Loader (ex. TomCat ClassLoader 구조) 가 필요하다.

        상위 class loader에서 읽어들인 클래스일수록, 나중에 클래스를 변경하기가 어렵다.

 **class Loader가 bytecode를 읽는 두가지 경우**
   - new bytecode가 실행될때
   - 바이트코드가 클래스를 정적으로 참조 할때

    자바 코드를 컴파일 하고 실행시키기 위해 항상 메인 메서드를 생성하는데, 이때 메인 메서드는 스태틱 메서드로 클래스 로더가 가장먼저 로드한다.


  **클래스 로더가 클래스를 읽는 절차**
   1. 클래스가 이미 로드되어있는지 확인
   2. 로드되지 않는 경우 부모 클래스 로더에 클래스를 로드하도록 요청
   3. 부모 클래스 로더가 클래스를 로드할 수 없는 경우 자식? 클래스 로드에 로드        

   
    클래스로더는 계층적, 끝까지 도달 했을때 class를 찾지 못한다면 classNotFoundException으로 RunTimeException이 발생됨

  **클래스 로더 구성**
    - loading : class를 읽어오는 과정
    - link : reference를 연결하는 과정
    - initialization : static 값들을 초기화 및 변수에 할당



----
> ## 2. Runtime Data Area (JVM Memory)

**정의**

  - JVM이 프로그램을 수행하기 위해 운영체제로부터 필요한 만큼 할당 받는 메모리 공간 
  - 자바가 실행될때 사용되는 Data를 적재하는 영역
  - Runtime Data Area라고 불림

**Data 적재영역 구성**
  - static Area
    - 하나의 .java파일은 field, constructor, method로 구성된다. 필드에 부분에서 선언된변수와 정적 멤버 변수의 데이터를 저장
    - static 영역의 데이터는 프로그램 시작부터 종료될때 까지 메모이레 남아있음, 즉 전역변수가 프로그램이 종료될때 까지 어디서든 사요ㅗㅇ이 가능한 이유이다.
    - 모든 쓰레드가 공유하는 메모리 영역
    - `하나의 JVM당 하나의 Method Area가 존재하며 자원을 공유한다.`

  - stack Area
    - 모든 지역변수 데이터 값 저장
    - 메소드 호출 후 메모리에 할당되고 종료되면 메모리에서 해제 됨
    - thread 당 영역이 존재하기 때문에 thread-safe하다.

  - Heap Area
    - 모든 객체를 저장하는곳
    - 힙에 생성된 객체는 주소를 가지고 있으며 유지하고 있음, 객체가 해제되는 경우는 GC에 의해서 해제됨
    - 쓰레드 세잎 하지 않기 때문에 주의를 요함

  - PC Registers
    - 쓰레드가 생성될때마다 생기는 공간
    - 함수의 주소를 가지고 있다가 다시 되돌아올때 사용됨

  - Native Methd Stack
    - 자바외 언어로 작성된 코드를 위한 메모리 영역
----

> ## 3.Execution Engin

**정의**

  - load된 class의 바이크코드를 실행하는 런타임 모듈
  - 클래스로더를 통해 JVM내에 런타임 데이터 영역에 배치된 바이트코드를 execution engine에의해 실행

**구성**
  - interpreter
    - 바이트코드를 더 빨리 해석하지만 느리게 실행한다.
    - 단점은 하나의 메서드가 여러번 호출 될 떄마다 새로운 해석이 필요하다.
  - JIT compiler
    - interpreter의 단점을 보완
    - 반복된 코드를 찾으면 전체 바이트코드를 컴파일 하고 네이트브 코드로 변경하는 JIT compiler를 사용한다.
  - GC(Garbage Collector)
    - 참조되지 않는 객체를 모아서 제거한다.
    - GC를 호출하여 수동으로 할 수 있지만 실행이 보장되지는 않는다.


----

JDK JRE의 차이
====

JDK 는 JRE에 추가로 자바프로그램을 개발하는데 필요한 컴파일러, 디버거와 같은 명령어 개발 도구를 추가한 것이다.

JRE는 자바 프로그램을 실행하기  위한 라이브러리, 자바 가상 기계, 기타 컴포넌트들을 제공한다.






---
layout: post
title: 리팩터링 리뷰 - 6
subtitle: "spring, security"
categories: spring
tags: security
comments: true
---
> repactoring

----
데이터 조직화
====

## 1. 변수쪼개기

  역할 하나당 변수하나이다. 

  역할 둘 이상인 변수가 있다면 쪼개야한다. 여러용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문이다.

  1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
  2. 가능하면 이때 불변으로 선언한다.
  3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름을 바꾼다.
  4. 두번째 대입시 변수를 원래 이름으로 다시 선언한다.
  5. 테스트한다. 
  6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.

  - 같은 역할에 여러 번의 할당은 필요할 때도 있다. 
    - 루프변수
    - 수집변수
  
## 2. 필드 이름 바꾸기

  어떤 개발자는 이런말을 했다고한다. 

  `데이터 테이블 없이 흐름도만 보여주면 혼란스럽다. 하지만 데이터 테이블을 보여주면 흐름도는 필요없을 것이다. `

  1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요없다.
  2. 레코드가 캡슐화됮 않았다면 우선 레코드를 캡슐화 한다. 
  3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.
  4. 테스트한다.
  5. 생성자의 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언바꾸기로 변경한다.
  6. 접근자들의 이름도 바꿔준다.

  - 데이터구조를 불변으로 만들수있는 프로그래밍은 데이터구조의 값을 복제해 새로운 이름으로 선언한다.

## 3. 파생 변수를 질의 함수로 바꾸기

  가변데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속한다. 

  그래서 가변데이터의 유효 범위를 가능한 좁혀야 한다고 힘주어 주장한다. 

  해결방법으로는 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거 하는 것이다. 
  
  1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다. 
  2. 해당 변수의 값을 계산해주는 함수를 만든다.
  3. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
  4. 테스트한다.
  5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
  6. 테스트한다.
  7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.


## 4. 참조를 값으로 바꾸기

  객체 내부를 수정하던 것을, "값 객체" 통째 하나로 바꾸끼

  - 참조로 다루는 경우 : 내부 객체는 그대로 둔채 그 객체의 속성만 변경
  - 갑으로 다루는 경우 : 새로운 속성을 담으 ㄴ객체로 기존 내부 객체를 통째로 대체
  
  - 값객체(불변) : setter 없이 constructor만으로 



## 5. 값을 참조로 바꾸기 

  - 왜 반대되는 방향으로 가는것일까?
    - 데이터를 갱신해야 할 때, 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 일관성이 깨진다.

  - 저장소 
    - '값 객체'들은 담아둘(예를 들면) hashmap

## 6. 매직 리터럴 사용하기 

  - 상수값을 사용해서 명료하게 만들어라 


---- 
조건부 로직 간소화
====

  - 조건부 로직은 프로그램의 크게 기여한다. 
  - 조건부 분해하기, 중복 조건식 통합하기, 중첩 조건문을 보호구문으로 바꾸기, 조건부로직 다형성으로 바꾸기

## 1. 조건문 분해하기
  
  조건부로직은 프로그램에 많은 영향을 끼치지만 이해하기 어려운 부분에 속한다. 

  이러한 조건부 로직을 코드블럭 단위로 의도를 살린 이름의 함수 호출로 바꿔주는 리팩터링이 필요하다. 

  - 더 나은 이름 : "조건문 함수화하기"
    - 조건,분기 모두 함수로 추출해버려 가독성 높이기 

  - "무슨일이 일어나는지는 이야기해주지만 '왜' 일어나느지는 제대로 말해주지 않을때가 많은 것이 문제다.

  - 조건문이 특이(특수한 상황)이면 -재사용성이 없을때- 이는 주관적인 판단으로 진행한다. (명확하다면 함수화 하지 않아도 된다. )
  
## 2. 조건식 통합하기

  - 간단한 여러 조건문을 하나의 복잡한 조건문으로 통합하기 
  - '조건문 분해하기'의 반대가 아님. 오히려 '사전단계'에 가까울 있음
  - "부수효과"에 유의 (부수효과 : 코드를 수정하면서 발생하는 에러)
  
## 3. 중첩 조건문을 보호 구문으로 바꾸기

  - 보호 구문 : 한쪽만 정상이라면 비정산 조건을 if에서 감사한 다음, 조건이 참이면 함수에서 빠져나온다. 
  - 보호구문을 진행하는 의도는 의미의 부각이다. (if-else)보다 if의 한줄이 가독성이 명확하기 때문이다. 


## 4. 조건부 로직을 다형성으로 바꾸기

  - switch 대신 오버라이드 된 subclass에 각자 다른 동작 구현


## 5. 특이 케이스 추가하기

  - 문제 
    - '미확인 고객'의 경우 특수처리가 되어야 한다.
      - 이름, 요금, 납부이력 등이 '기본값' 처리 되어야함
    - 문제는 이 '미확인 고객'의 정보를 참조하는 곳이 여러 곳에 분산 되어 있다.

  - 해결책 
    - UnknownCustomer라는 특이 클래스로 처리해서 해결(일종의 다형성)
    - (이후 수정이 필요없을 경우) '기본값'을 갖는 literal object로 처리 
    - 변환함수에 통과시켜, 예외(unknown)가 '기본값'을 갖도록 만듬
  - 결과
    - 조건문이 없어지고 '하나의 동작'으로 해결
 

## 6. 어서션 추가하기 

  - 가정이 코드에 항상 명시적으로 기술되어 있지 않아 알고리즘을 보고 연역해서 알아내야 할 때
  
  - 어서션의 장점 : 에러 검출이 용이하다 && 또한 다른 개발자에게 코드의 수정없이 알려줄수있어 소통측면에서 뛰어나다 

  - 어서션을 남발하는것도 위험

## 7. 제어 플래그를 탈출문으로 바꾸기

  - 제어 플래그 : 코드의 동작을 변경하는데 사용되는 변수




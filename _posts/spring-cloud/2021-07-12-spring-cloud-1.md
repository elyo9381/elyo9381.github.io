---
layout: post
title: spring cloud study - 1
subtitle: "spring, cloud"
categories: spring
tags: cloud
comments: true
---
> spring study


# 스프링 클라우드 

  실무에서는 하나의 서버로 관리하기 힘들다. 

  데이터 처리관점 및 다양한 관점에서 클라우드 또는 네트워크를 구성해야한다.


  - HA : 고 가용성
  - Resilience : 복원력

## 1. 웹서비스 확장 전략 


  - 실무 개발 유형
    - 솔루션 : db 접근제어, 암호화, 사용자(비즈니스 관점) ex) b2b 시스템을 대체적으로 말한다.  
    - SI : 회사의 특정 기능을 수정하는 개발이다.
    - 서비스 : 내부적으로 기능을 개발하고 사용자에게 전달하는 관점, 항상 서비스 되어야함 

  - 스프링이 꼭 필요한것은 아니다. 각 상황에 맞게(기업의) 확장 전략을 선택해야한다. 

## 2. 클라우드가 필요한 서비스? 

    두가지 경우로 나눠 볼수있다. 
    
  - 스케일업을 통한 서비스 확장
    - scale-up : 컴퓨터의 자원을 늘리는 확장
    - 무중단을 위해서는 높은 자원보다 끊기지 않는 상황이 필요하다.
  - 스케일 아웃을 통한 서비스 확장 
    - scale-out : 컴퓨터의 자원은 동일하고 여러대의 컴퓨터를 사용하는 방법
    - 장애 대응에 효율적이다. 

## 3. 서버 부하 분산 네트워크

  - 서버 : 무언가를 제공하는 대상 
  - 부하 : Load => 많은 요청이 들어온(요구된) 상황
  - 분산 : 스케일아웃(분산) 나눠서 하는것(흩어짐)
    - 통계값과 평균값의 차이인 편차를 제곱하여 얻은 값들의 산술 평균
  - 네트워크 : 통신 설비를 갖춘 컴퓨터를 이용해 서로 연결시켜주는 조직이나 체계

## 4. DNS 서버 실습

  - spring boot 웹서버 예제를 만들어 간단하게 controller를 만들어봅니다.
   
  ```
  @GetMapping("/")
  public String hello(){
      return " hi~~~~ man ";
  }
  ```

  다음과 같은 컨트롤러를 통해서 웹서버의 응답을 받을수있습니다.   

  그리고 local은 localhost:8080~~ 를 통해서 응답받을수 있는데,   
  이를 다른 DNS를 지정하고 싶다면    


  ```
  sudo vim /etc/hosts 
  ```

  파일을 수정하면된다.  


## 5. DNS 매핑 및 웹서버 연동 

  WellKnown port 가 주어진다. 

  하지만 이는 권한과 연결된다. 

  클라이언트는 80포트로 웹서버에 들어오면 웹서버는 8080포트로 스프링부트와 연결된다. 
  
  웹서버와 api(스프링부트)의 권한이 다르기 때문에 포트가 다르다. 

  우리가 만든 API서버는 루트 권한을 주지 않아도 보안이슈없이 사용할수있게 된다. 

  - DNS와 HTTPS
    - 최근 대형 서비스들은 https를 사용하는데 인증서를 구매해야한다. 
    - wild 카드 인증서 *.도메인.com 이라면 dot이 2개일때만 지원가능하다. 
    - 그래서 test-a.domain.com // dev-a.domain.com등으로 사용하는 팁이있다.


## 6. virtual IP 와 DNS

  - 무중단을 위해서 사용하는것이 virtual IP를 사용한다. (VIP라도 명하기도 함)
  - vip는 로드밸런싱의 역할을 수행한다. 

  1. 외부에서 여러가지 요청이 올수 있습니다. 
  2. 여러가지 요청이 들어왔을시 이를 나눠줄수있는 (분산) 방법은 DNS의 방법이 있습니다. 
  3. DNS을 기준으로 분산처리를 할수있는데 이또한 엄청난 요청이 온다면? 
  4. virtual IP 를 설정하고 하여 각 기능을 수행하는 API로 요청을 전달하여 분산할수있습니다. 
  5. 이렇게 되면 요청을 분산하는 서버가 존재하고 논리적으로 이를 다른 포트에 연결해주는(API)에 전송할수있습니다. 
  6. 


## 7. 읽기 요청 부하 분산

  - 외부의 여러가지 요청 또한 세분화 할 수 있습니다. 
  - 읽기, 쓰기 등등 여러가지 존재합니다. 


  - 같은 요청이 반복적으로 들어온다면 ? 
    - 동일한 요청을 처리하는 방법은 cache입니다. 
    - 캐시 : 요청을 중복되지 않게 저장하고 만약에 동일한 요청이 오면 DB에 접근하지 않고 저장한 내용을 보여주는것

  - 로드밸런싱을 통한 여러대의 API가 존재한다면 ? 캐시의 내용이 공유되지 않아서 분산이 잘되지 않을수 있습니다. 
    - 데이터의 정합성을 보장하지 못함
  - 위와같은 경우는 캐시서버를 따로 두는 해법이 존재한다. (레디스, 멤캐쉬 등)
  
  - 로컬캐시는 정적인 이미지나 특정 api에 대한 요청을 수행하고 다른것은 별도의 캐시서버를 두는게 일반적입니다. 

  - 읽기 요청 부하 분산의 가장 중요한 점은 DB에 어떻게 적은 접근을 할까? 입니다. 
  
## 8. 클러스터링과 레플리카

  - 7.챕터의 노력에도 불구하고 물리적인 DB에 접근(요청)이 많아 문제가 존재합니다. 

  - 그렇다면 DB를 스케일아웃합니다. 이를 HA라고 합니다. 즉 레플리카(복제)를 하는겁니다. 
  
  - 다른 방법인 클러스터링은 마스터노드와 네트워크 노드를 

  

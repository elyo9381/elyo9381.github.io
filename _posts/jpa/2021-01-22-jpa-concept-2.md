---
layout: post
title: jpa-concept-2
subtitle: "spring, framework, jpa"
categories: spring
tags: framework
comments: true
---
> spring jpa study

## 영속성 관리 

 * jpa 영속 컨텍스트(jpa의 실제 내부 동작)
    - jpa를 이해하는데 가장 중요한 용어
    - 엔티티를 영구 저장하는 환경이라는 뜻
    - EntityManager.persist(entity) >> 엔티티를 영속 컨텍스트에 저장하는것이다. DB저장 아님
    - 1차캐시에 올라가는 상황이 영속 상태가 되는것이다. (저장,조회(1차캐시에 없을때))

    1. 엔티티는 생명주기가 존재한다. 
       -  비영속 : 객체만 생성한 상태(jpa와 관계가 없는 상태)
       -  영속 : 맴버객체를 생성한다음 entitymanager생성후 .persist(member) 하면 객체가 영속 상태가 된다 . <u> 아직 DB에 저장되지 않은 상태 이고 추후에 커밋되면 DB에 저장된다. </u>
       -  준영속 : 영속성 컨테스트에서 객체를 분리하여는 기능 ex)em.detach(member);, 
       -  삭제 : 객체를 삭제한 상태(삭제) 등록된 DB에서 완벽하게 삭제하는 기능 ex)em.remove(객체);


    2. 영속성 컨텍스트의 이점 (필요 이유)
       -  엔티티조회, 1차 캐시 : .persist() 수행하면 영속 컨텍스트에 1차캐시가 생김   그리고 조회시 DB를 먼저 접근하지 않고 1차캐시를 먼저 접근하여 pk(@Id)확인후 없으면 DB확인한다. <u>1차캐시의 나름의 문제점?이라고 한다면 entitymanager는 트랜잭션 단위로 진행되기에 짧은 순간 존재한다.</u> 

    3. 영속 엔티티의 동일성 보장
       - 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
  
    4. 엔티티 등록(트랜잭션을 지원하는 쓰기 지연)
       - 여러개의 .persist()함수를 수행하여도 이것을 함수 수행마다 바로 쿼리를 날리지 않고 이를 지연하고 있다가 커밋이 나오면 한번에 쿼리를 작성한다. 

    5. 엔티티 수정
       - 객체의 함수로 엔티티의 값을 수정한다.
       - 수정하였다면 .persist()를 통해서 다시 쿼리를 날려야할것같지만 아니다. 
       - 1차캐시안에는 엔티티값과 스냅샷이 존재하는데 이것이 플래시(커밋) 하였을때 변경되면 체크하여 업데이트 쿼리를 생성해줌. 누가?? Jpa가 정확히는 영속 컨테스트가 
    6. 엔티티 삭제
       - id를 찾는다. >> Member memberA = em.find(Member.class,"memberA"); 
       - 그리고 삭제 쿼리를 날린다. 



 * 플러시
   * 영속 컨테스트의 쿼리를 날려주는것
   * 번경감지(dirty checking), 수정된 엔티티 쓰기지연 sql저장소에 등록, 쓰기지연 sql저장소의 쿼리를 DB에 저장 
   * 어떻게 플러시를 하냐 ? (flush는 데이터베이스에 변경내용을 동기화 되는것이지 1차캐시가 사라지는것은 아니다.)
     * em.flush() - 직접호출(강체호출)
     * 트랜잭션 커밋 - 플러시 자동 호출
     * jpql쿼리 실행  - 플러시 자동 호출

 * 준영속
   * 영속 -> 준영속
   * 준영속 상태에서는 dirty checking등, 1차캐시의 이점을 사용하지 못한다. 
   * 실행하는 방법.
     * em.detach(entity)
     * em.clear() : 1차캐시를 통으로 지움
     * em.close() : 영속 컨테스트 종료


   * EntityManagerFactory
   * EntityManager

 * 객체와 관계형 데이터 베이스 매핑하기(설계적인 부분)
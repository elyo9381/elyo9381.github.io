---
layout: post
title: Ch.16-3-Bit Mask
subtitle: "JMB, bitmask"
categories: book
tags: JMB
comments: true
---
> 알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)

## 지수 시간 동적 계획법
> 이 절에서는 배열 대신 정수로 집합을 표현하면 이것을 곧장 배열의 인덱스로 쓸 수 있다는 점을 이용합니다.
> * 따라서 메모이제이션의 구현 또한 간단해집니다.

## 에라토스테네스의 체
* 에라토스테네스의 체는 굉장히 빠르게 동작하기 때문에, 수행 범위를 늘릴 때 부담이 되는것은 수행시간보다는 메모리였습니다.
* 체를 구현할 때는 범위 내의 각 정수가 지워졌는지 여부를 저장해야 하는데, 14.2 절에서 이것을 불린 값 배열을 이용해 표현했습니다.

> 참고로, bool x = true; 라고 선언된 boolean은 1bit를 표현하지만 메모리는 1바이트를 잡아먹습니다.

* 32 비트 정수가 표현할 수 있는 범위 내의 모든 수에 대해 체를 수행한다고 합시다.
* 불린 값 배열을 이요하면 4기가 바이트(2^32 byte)의 메모리를 써야 합니다.
* 짝수를 제외해 2기가바이트로 줄일 수도 있지만, 여전히 적지 않은 양입니다.

> 이때 비트마스크를 사용하면 메모리 사용량을 8분의 1로 다시 줄일 수 있습니다.

* MAX_N개의 원소를 닺는 불린 값 배열을 다음과 같은 배열로 대체합시다.

```
unsigned char sieve[(MAX_N + 7) / 8];
```
* 이 배열은[MAX_N/8] 바이트만을 써서 MAX_N개의 원소를 갖는 불린 값 배열을 구현합니다.
* 이때 k번 원소가 참인지를 알기 위해서는 k/8번째 원소의 k%8번째 비트가 켜져있는지를 확인하면 됩니다.
* 이들이 비트 연산을 이용해 나눗셈과 나머지 연산을 구현하는 것을 눈여겨봅시다.
* 정수를 오른쪽으로 3비트 시프트하는것은 8로 나눈는 것과 같고, 7과 AND연산하는것은 8로 나눈 나머지를 구하는것과 같기 때문입니다.

```
unsigned char x = 0;
x : 0x00 ==> 0000 0000 (2진수로 총 8개의 비트)
하나의 바이트에 숫자 8개에 대한 on/off 즉, bool로 사용할 수 있다.
- 7이 소수인지 확인하는 방법은 아래와 같다.
- return sieve[ 7 >> 3 ] & (1<< (7 & 7)));
    ->   sieve[   0    ] & (1000 0000(2진수)) => 결국 , sieve[0] 값 중 7번째에 해당하는 비트 1
    써져있으면 1을 리턴, 0이 써져 있으면 0을 리턴하게 된다.
```

```
int n;
unsigned char sieve[(MAX_N + 7)/ 8 ];
//k가 소수인지 확인한다.

inline bool isPrime(int k) {
  return sieve[k >> 3] & (1 << (k & 7))'
}
// k가 소수가 아니라고 표시한다.
inline void setComposite(int k){
  sieve[ k >> 3]  &= ~( 1<< (k & 7));
}
// 비트마스크를 사용하는 에라토스테네스의 체의 구현
// 이 함수를 수행하고 난 뒤, isPrime()을 이용해서 각 수가 소수인지 알 수 있다.
void eratosthenes(){
  memset(sieve, 255, sizeof(sieve));
  setComposite(0);
  setComposite(1);
  int sqrtn = int(sqrt(n));
  for( int  i = 2; i<sqrtn; i++)
    // 이 수가 아직 지워지지 않았다면
    if(isPrime(i))
      // i의 배수 j들에 대해 isPrime[j] = false로 둔다.
      // i*i 미만의 배수는 이미 지워졌으므로 신경쓰지 않는다.
      for(int j = i*i; j<=n; j+=i)
        setComposite(j);
}
```

## 15퍼즐 상태 표현하기
* 비트마스크를 이용하여 표현해야 하는 값의 범위가 작을 때는, 2비트씩, 3비트씩 묵어서 배열로 쓸 수도 있습니다.
* 15퍼즐의 상태는 0부터 15까지의 숫자가 들어있는 4x4크기의 배열로 표현할 수 있습니다.
* 각 숫자는 4비트로 표현할 수 있고, 15개의 숫자가 있기 때문에 비트마스크를 사용하면 이 배열 전체를 64비트 정수 하나로 표현할 수 있습니다.
```
typedef unsigned long long uint64;
// mask의 index 위치에 쓰인 값을 반환한다.
int get(uint64 mask, int index){
  return (mask >> (index << 2)) & 15;
}
// mask의 index 위치를 value로 바꾼 결과를 반환한다.
uint64 set(uint64 mask, int index, uint64 value){
  return mask & ~(15LL << (index <<2) | (value << ( index << 2 ));
}
```

```
get함수 (index = 10 라고 한다면)
return (mask >> (index << 2 )) & 15;
        mask >> (10을 왼쪽으로 2번 shift하면 40이 된다.)
        mask를 오른쪽으로 40칸 shift한 결과의 1111(15)와 AND연산
        0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
        0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   (번째 숫자)

- mask의 최상위 비트를 40번 우측으로 shift하고 1111과 AND연산 한다면, 10번째 index의 값을 가젝 되어 get의 역할을 수행한다.
```

## O(1) 우선순위 큐 
* 우선순위 큐는 원소 중에서 우선순위가 가장 높은 원소를 빠르게 찾아낼 수 있는 자료구조입니다.
* 이 우선순위 큐에 자료를 추가하거나 삭제하는 작업은 N개의 원소가 있을 때 O(logN)의 시간이 걸립니다.

> 그런데 우선순위가 특정 범위로 제한되어 있을경우 비트마스크를 이용하면 모든 작업을 O(1)에 할 수 있는 우선순위 큐를 만들 수 있습니다.
> * 예를 들어 우리가 큐에 넣는 원소의 우선순위가 1이상 140이하의 정수하고 합시다.
> * 각 우선순위를 갖는 원소들을 담는 140개의 큐를 만들고, 각 큐에 원소가 있는지 여부를 비트마스크로 표현합시다.
> * 140 개의 불린값을 64비트 정수 세개에 저장하면 첫 번째 비트를 찾는 연산을 이용해 모든큐를 뒤질 필요 없이 가장 우선순위가 높은 원소가 어디에 있는지를 쉽게 찾을 수 있습니다. 
> * 이와 같은 우선순위 큐는 실제로 리눅스 커널의 프로세스 관리를 위해 사용된 적이 있습니다.

```
queue<int> pq[140];

//  140개의 불린 값 -> 64*3 = 192, uint64를 통해 index 사용가능
uint64 x[3]; // 140개의 불린 값을 64비트 정수 세 개에 저장
// .... .... 1000 0000 으로 표시되어 있는경우, 8번째 우선순위를 갖는 녀석이 on 되어 있다고 확인할 수 있습니다.
```

## 예제 : 극대 안정 집합
* N(N<=20)개의 화학물질을 운반해야 한다고 하자.
* 각 화학 물질은 무해하지만, 같이 두었을 때 서로 반응해 폭발하는 물질들이 있습니다.
* 이때 한 상자에 넣어도 폭발하지 않는 물질의 집합을 안정적이라고 부릅시다.
* 물질이 하나만 있는 집합은 항상 안정적입니다.
* 때문에 안정된 집합은 여러개가 있을 수 있는데, 그중 물질을 하나라도 추가하면 폭발이 일어나는 집합들을 극대 안정 집합이라고 부릅니다.
* 극대 안정 집합 또한 여러개가 있을 수 있습니다.
* 예를들어 4개의 화학물질 a,b,c,d가 있는데 a와 b를 같은 상자에 넣거나, c와 d를 같은 상자에 넣으면 폭발한다고 합니다.
  * 그러면 다음과 같은 4개의 극대 안정 집합이 있을 겁니다.
  * {a,c}, {a,d}, {b,c}, {b,d}
* 각 화학 물질의 정보가 주어질 때 극대 안정 집합의 수를 세는 코드를 작성해 봅시다.
* 아래 코드 중 어떤 안정 집합에 다른 원소 add를 넣을 수 있는지를 isStable()를 다시 호출하는 대신 explodes[add] & set이 0인지만 확인하는 것을 눈여겨 보세요.
```
int n;
int explodes[MAXN];
bool isStable(int set){
  for(int i = 0; i<n ;i ++)
    if((set & (1<<i))&& (set & explodes[i]))
      return false;
  return true;
}
int countStableSet(){
  int ret = 0;
  for(int set = 1; set < (1<<n); ++set){
    if(!isStable(set)) continue;
    bool canExtend = false;
    for(int addd = 0; add <n; ++add)
      if((set & (1 <<add )) && (explodes[add] & set == 0)){
        canExtend = true;
        break;
      }
    if(!canExtend)
      ++ret;
  }
  return ret;
}
```
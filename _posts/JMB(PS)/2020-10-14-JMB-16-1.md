---
layout: post
title: Ch.16-1-Bit Mask
subtitle: "JMB, bitmask"
categories: book
tags: JMB
comments: true
---
> 알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)

# 도입
 * 현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현합니다.
 * 이와 같은 특성을 이용해 정수의 이진수 표현을 자료구조로 쓰는 기법을 BitMask라고 합니다.


> ### 비트마스크의 장점 
> * 더 빠른 수행시간 
>   * 비트 마스크 연산은 O(1)에 구현되는것이 만기 때문에, 적절히 사용할 경우 다른 자료구조를 사용하는것보다 훨씬 빨리 동작합니다.
> * 더 간결한 코드
>   * 다양한 집합 연산들을 반복문 없이 한줄에 쓸 수 있기 때문에 비트 마스크를 적절히 상요하면 굉장히 짧은 코드를 작성할수 있습니다.
> * 더 작은 메모리 사용량
>   * 비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있습니다.
> * 연관 배열을 배열로 대체
>   * 불린값 배열을 키로 갖는 연관배열 객체 map<vector,int>를 사용한고 있다고 합시다.
>   * 이때 비트마스크를 써서 같은 정보를 정수 변수로 나타내면 단순한 배열 int[]를 사용해 같은 정보를 나타낼수 있습니다.

# 용어 정의
* 부호없는 N비트 정수형 변수는 N자리의 이진수로 쓸 수 있습니다.
* 이때 각 비트가 표현하는 값은 2^0 부터 2^N-1까지 입니다.
* 2^N-1에 해당하는 비트를 최상위 비트, 2^0을 나타내는 비트를 최하위 비트라고 부릅니다.
* 어떤 정수를 표현했을때 어떤 비트의 위치가 1이라면 해당 비트가 "켜져있다"라고 말하고, 0이라면 "꺼져있다"라고 말합니다.

# AND 
* 입력받은 두 정수를 한 비트씩 비교하면서, 두 정수에 해당 비트가 모두 켜져 있을 때만 결과의 비트를 켭니다.

# OR, XOR
* AND와 같이 비트별로 동작하지만 OR연산은 두 비트중 하나라도 켜져 있을 경우, XOR연산은 두 비트가 같으면 결과비트를 끄고 두비트가 다르면 결과비트를 켜는 차이점이 존재합니다.

# NOT
* 정수 하나를 입력받아 켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과를 반환합니다.

# SHIFT
* 정수 a의 비트들을 왼쪽 또는 오른쪽으로 이동시키며 왼쪽은 2^N으로 증가하며 오른쪽은 2^N-1으로 감소합니다.

# 유의사항
* C++,JAVA에서 &,^등의 비트 연산자의 우선순위는 == 혹은 !=등의 비교연산자 보다 낮습니다.

```
int c = (6 & 4 == 4);
```
* 위의식에서 == 연산자가 먼저 수행되고 &연산자가 수행됩니다. 

```
int c = ((6 & 4) == 4);
```
* 이와 같이 괄호를 이용하여 우선순위를 지정해야합니다.

```
bool isBitSet(unsigned long long a, int b){
    return (a & (1 << b)) > 0;
}
```
* c++에서 1은 부호 있는 32비트 상수로 취급되기 때문에, b가 32이상이면 (1 << b)에서 오버플로가 발생합니다.
* 이 문제를 해결하기 위해서는 int b가 아닌 a와 같은 타입으로 설정해야합니다.


# 부호 있는 정수형의 사용
* 부호있는 정수형에서 최상위 비트가 켜진 숫자는 음수를 표현합니다.
* 예를 들면 음수를 오른쪽으로 시프트할때 왼쪽끝 비트들이 0이 아니라 1로 채워진다든지 하는 차이가 있습니다.
* 따라서 변수의 모든 비트를 다 쓰고 싶을때는 부호없는 정수형을 쓰는것이 좋습니다. 

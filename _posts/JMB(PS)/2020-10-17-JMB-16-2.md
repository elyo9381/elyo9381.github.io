---
layout: post
title: Ch.16-2-Bit Mask
subtitle: "JMB, bitmask"
categories: book
tags: JMB
comments: true
---
> 알고리즘 문제해결 전략 a.k.a - JMB(JongMan Book)

## 비트마스크를 이용한 집합의 구현
 * 비트 마스크의 가장 중요한 사용 사례는 집합을 구현하는 것입니다.
   * 이 표현에서 N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 됩니다.

 * 예를들어 {1,4,5,6,7,9}을 표현하는 정수는 754임을 다음과 같이 알수있습니다.
 * 2^1+2^4+2^5+2^6+2^7+2^9 = 10 1111 0010 = 754

## 피자집 예제
* 고객들이 원하는 토핑을 골라 주문할 수 있는 피자집의 주문 시스템을 만든다고 합시다.
* 이 피자집에는 0부터 19까지의 번호를 갖는 스무가지 토핑이 있고, 주문시 토핑을 넣기/넣지않기를 선택할 수 있습니다.

## 공집합과 꽉 찬 집합 구하기
* 토핑을 올리지 않은 피자는 상수 0으로 나타냅니다.
* '전부 다'피자는 아래와 같이 표현할 수 있습니다.

```
int fullPizza = (1<<20) -1;
```
* 1<<20은 이진수로 1뒤에 20개의 0이 있는 정수인데, 여기서 1을 빼면 20개의 비트가 모두 켜진 숫자를 얻을 수 있습니다.

## 원소 추가
* 집합의 가장 기초적인 연산은 원소를 추가하고 삭제하는 것입니다.
* 토핑중 하나인 페퍼로니(p)(0<=p<20)은 아래와 같이 추가할 수 있습니다.
```
topping |= (1 <<p);
```

## 원소의 포함 여부 확인
```
if(toppings & (1<<p)) cout <<"pepperoni is in"<<endl;
```
* &연산의 결과값이 0 또는 1 << p라는 점에 유의하세요.
* 대부분의 논리 연산처럼 원소가 포함되어 있는경우 1, 혹은 true를 반환한다고 생각하면 아래와 같은 코드를 작성하는 실수를 범함니다.
```
//제대로 동작하지 않음!
if((toppings & (1<<p)) == 1 ) cout <<"pepperoni is in " << endl;
```

## 원소의 삭제
```
toppings -= (1<<p);
```
* 만약 페퍼로니가 없는데 위와같은 코드를 쓰면 큰일납니다.
* 토핑이 없을때도 정상적으로 동작하는 방법은 다음돠 같은 코드를 사용하는 것입니다.
```
toppings &= ~(1<<p);
```

## 원소의 토글
* 토글은 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜는 것이며 XOR이 이와 같은 일을 합니다.
```
toppings ^= (1<<p);
```

## 두 집합에 대해 연산하기
* 토핑 집합 a 와 b에 대하여 
```
int added = (a | b);        // a와 b의 합집합
int intersection = (a & b); // a와 b의 교집합
int removed = (a & ~b);     // a에서 b를 뺀 차집합
int toggled = (a ^ b);      // a와 b중 하나에만 포함된 원소들의 집합
```

## 집합의 크기 구하기
* 가장 간단한 방버은 각 비트를 순회하면서 켜저있는 비트를 직접 세는 것입니다.
```
int bitCount(int x){
    if(x == 0) return 0;
    return x % 2 + bitCount(x / 2);
}
```
* 여러 프로그래밍 환경에서 이와 관련된 내장 명령어를 제공합니다.
* 다음 목록은 32 비트 부호 없는 정수 toppings에 켜진 비트의 수를 구하는 코드를 각 언어 혹은 컴파일러 별로 보여줍니다.
```
gcc/g++ __builtin_popcount(toppings)
Visual C++ __popcnt(toppings)
java Integer.bitCount(toppings)
```

## 최소 원소 찾기
* 이 연산은 "이 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇개인가?"와 같은 의미입니다.
* 켜져 있는 최하위 비트 미틔 비트들은 전부 0일테니, 이 연산은 켜져 있는 최하위 비트의 번호를 반환하게 됩니다.
```
gcc/g++ __builtin_ctz(toppings)
Visual C++ _BitScanForward(&index, toppings)
java Integer.numberOfTrailingZeros(toppings)
```
* 2의 보수를 이용한 방법
  ```
  int firstTopping = ( toppings & -toppings);
  ```
  * 이것은 대두분의 컴퓨터가 음수를 표현하기 위해 2의보수를 사용한다는 점을 이용합니다.
  * 2의 보수를 사용하는 시스템에서는 음수 -toppings를 표현하기 위해서는 toppings에 NOT연산을 적용후 1을 더하여 2의보수를 만들어냅니다.


## 최소원소 지우기
```
topping &= ( toppings -1 );
```
* toppings-1의 이진수 표현은 toppings에서 켜져 있는 최하위 비트를 끄고 그 밑의 비트들은 전부 켠 컷입니다.
* 따라서 두 값을 비트별 AND 연산하면 최하위 비트와 그 이하의 비트들을 전부 0이 됩니다.

## 모든 부분 집합 순회하기
* 또 하나 아주 유용한 팁은 주어진 집합의 모든 부분 집합을 순회 하는 것입니다.
```
for(int subset = pizza; subset; subset = ((subset -1) & pizza){
    //subset은 pizza의 부분집합
}
```
* subset에서 1을 빼면 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜지게 됩니다.
* 이 결과와 pizza의 교집합을 구하면 그중 pizza에 속하지 않는 비트들은 모두 꺼지게 됩니다.
* for문은 subset = 0인 시점에서 종료하므로 공집합은 방문하지 않는다는 점을 깜박하지 않도록 합시다.